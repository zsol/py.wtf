{"name": "charset-normalizer", "metadata": {"name": "charset-normalizer", "version": "3.4.1", "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3 :: Only", "Programming Language :: Python :: 3.10", "Programming Language :: Python :: 3.11", "Programming Language :: Python :: 3.12", "Programming Language :: Python :: 3.13", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3.9", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Text Processing :: Linguistic", "Topic :: Utilities", "Typing :: Typed"], "home_page": null, "license": "MIT", "documentation_url": "https://charset-normalizer.readthedocs.io/", "dependencies": [], "summary": "The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet.", "upload_time": 1735063952}, "documentation": ["<h1 align=\"center\">Charset Detection, for Everyone \ud83d\udc4b</h1>\n\n<p align=\"center\">\n  <sup>The Real First Universal Charset Detector</sup><br>\n  <a href=\"https://pypi.org/project/charset-normalizer\">\n    <img src=\"https://img.shields.io/pypi/pyversions/charset_normalizer.svg?orange=blue\" />\n  </a>\n  <a href=\"https://pepy.tech/project/charset-normalizer/\">\n    <img alt=\"Download Count Total\" src=\"https://static.pepy.tech/badge/charset-normalizer/month\" />\n  </a>\n  <a href=\"https://bestpractices.coreinfrastructure.org/projects/7297\">\n    <img src=\"https://bestpractices.coreinfrastructure.org/projects/7297/badge\">\n  </a>\n</p>\n<p align=\"center\">\n  <sup><i>Featured Packages</i></sup><br>\n  <a href=\"https://github.com/jawah/niquests\">\n   <img alt=\"Static Badge\" src=\"https://img.shields.io/badge/Niquests-Best_HTTP_Client-cyan\">\n  </a>\n  <a href=\"https://github.com/jawah/wassima\">\n   <img alt=\"Static Badge\" src=\"https://img.shields.io/badge/Wassima-Certifi_Killer-cyan\">\n  </a>\n</p>\n<p align=\"center\">\n  <sup><i>In other language (unofficial port - by the community)</i></sup><br>\n  <a href=\"https://github.com/nickspring/charset-normalizer-rs\">\n   <img alt=\"Static Badge\" src=\"https://img.shields.io/badge/Rust-red\">\n  </a>\n</p>\n\n> A library that helps you read text from an unknown charset encoding.<br /> Motivated by `chardet`,\n> I'm trying to resolve the issue by taking a new approach.\n> All IANA character set names for which the Python core library provides codecs are supported.\n\n<p align=\"center\">\n  >>>>> <a href=\"https://charsetnormalizerweb.ousret.now.sh\" target=\"_blank\">\ud83d\udc49 Try Me Online Now, Then Adopt Me \ud83d\udc48 </a> <<<<<\n</p>\n\nThis project offers you an alternative to **Universal Charset Encoding Detector**, also known as **Chardet**.\n\n| Feature                                          | [Chardet](https://github.com/chardet/chardet) |                                         Charset Normalizer                                         | [cChardet](https://github.com/PyYoshi/cChardet) |\n|--------------------------------------------------|:---------------------------------------------:|:--------------------------------------------------------------------------------------------------:|:-----------------------------------------------:|\n| `Fast`                                           |                       \u274c                       |                                                 \u2705                                                  |                        \u2705                        |\n| `Universal**`                                    |                       \u274c                       |                                                 \u2705                                                  |                        \u274c                        |\n| `Reliable` **without** distinguishable standards |                       \u274c                       |                                                 \u2705                                                  |                        \u2705                        |\n| `Reliable` **with** distinguishable standards    |                       \u2705                       |                                                 \u2705                                                  |                        \u2705                        |\n| `License`                                        |           LGPL-2.1<br>_restrictive_           |                                                MIT                                                 |            MPL-1.1<br>_restrictive_             |\n| `Native Python`                                  |                       \u2705                       |                                                 \u2705                                                  |                        \u274c                        |\n| `Detect spoken language`                         |                       \u274c                       |                                                 \u2705                                                  |                       N/A                       |\n| `UnicodeDecodeError Safety`                      |                       \u274c                       |                                                 \u2705                                                  |                        \u274c                        |\n| `Whl Size (min)`                                 |                   193.6 kB                    |                                               42 kB                                                |                     ~200 kB                     |\n| `Supported Encoding`                             |                      33                       | \ud83c\udf89 [99](https://charset-normalizer.readthedocs.io/en/latest/user/support.html#supported-encodings) |                       40                        |\n\n<p align=\"center\">\n<img src=\"https://i.imgflip.com/373iay.gif\" alt=\"Reading Normalized Text\" width=\"226\"/><img src=\"https://media.tenor.com/images/c0180f70732a18b4965448d33adba3d0/tenor.gif\" alt=\"Cat Reading Text\" width=\"200\"/>\n</p>\n\n*\\*\\* : They are clearly using specific code for a specific encoding even if covering most of used one*<br>\n\n## \u26a1 Performance\n\nThis package offer better performance than its counterpart Chardet. Here are some numbers.\n\n| Package                                       | Accuracy | Mean per file (ms) | File per sec (est) |\n|-----------------------------------------------|:--------:|:------------------:|:------------------:|\n| [chardet](https://github.com/chardet/chardet) |   86 %   |       63 ms        |    16 file/sec     |\n| charset-normalizer                            | **98 %** |     **10 ms**      |    100 file/sec    |\n\n| Package                                       | 99th percentile | 95th percentile | 50th percentile |\n|-----------------------------------------------|:---------------:|:---------------:|:---------------:|\n| [chardet](https://github.com/chardet/chardet) |     265 ms      |      71 ms      |      7 ms       |\n| charset-normalizer                            |     100 ms      |      50 ms      |      5 ms       |\n\n_updated as of december 2024 using CPython 3.12_\n\nChardet's performance on larger file (1MB+) are very poor. Expect huge difference on large payload.\n\n> Stats are generated using 400+ files using default parameters. More details on used files, see GHA workflows.\n> And yes, these results might change at any time. The dataset can be updated to include more files.\n> The actual delays heavily depends on your CPU capabilities. The factors should remain the same.\n> Keep in mind that the stats are generous and that Chardet accuracy vs our is measured using Chardet initial capability\n> (e.g. Supported Encoding) Challenge-them if you want.\n\n## \u2728 Installation\n\nUsing pip:\n\n```sh\npip install charset-normalizer -U\n```\n\n## \ud83d\ude80 Basic Usage\n\n### CLI\nThis package comes with a CLI.\n\n```\nusage: normalizer [-h] [-v] [-a] [-n] [-m] [-r] [-f] [-t THRESHOLD]\n                  file [file ...]\n\nThe Real First Universal Charset Detector. Discover originating encoding used\non text file. Normalize text to unicode.\n\npositional arguments:\n  files                 File(s) to be analysed\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --verbose         Display complementary information about file if any.\n                        Stdout will contain logs about the detection process.\n  -a, --with-alternative\n                        Output complementary possibilities if any. Top-level\n                        JSON WILL be a list.\n  -n, --normalize       Permit to normalize input file. If not set, program\n                        does not write anything.\n  -m, --minimal         Only output the charset detected to STDOUT. Disabling\n                        JSON output.\n  -r, --replace         Replace file when trying to normalize it instead of\n                        creating a new one.\n  -f, --force           Replace file without asking if you are sure, use this\n                        flag with caution.\n  -t THRESHOLD, --threshold THRESHOLD\n                        Define a custom maximum amount of chaos allowed in\n                        decoded content. 0. <= chaos <= 1.\n  --version             Show version information and exit.\n```\n\n```bash\nnormalizer ./data/sample.1.fr.srt\n```\n\nor\n\n```bash\npython -m charset_normalizer ./data/sample.1.fr.srt\n```\n\n\ud83c\udf89 Since version 1.4.0 the CLI produce easily usable stdout result in JSON format.\n\n```json\n{\n    \"path\": \"/home/default/projects/charset_normalizer/data/sample.1.fr.srt\",\n    \"encoding\": \"cp1252\",\n    \"encoding_aliases\": [\n        \"1252\",\n        \"windows_1252\"\n    ],\n    \"alternative_encodings\": [\n        \"cp1254\",\n        \"cp1256\",\n        \"cp1258\",\n        \"iso8859_14\",\n        \"iso8859_15\",\n        \"iso8859_16\",\n        \"iso8859_3\",\n        \"iso8859_9\",\n        \"latin_1\",\n        \"mbcs\"\n    ],\n    \"language\": \"French\",\n    \"alphabets\": [\n        \"Basic Latin\",\n        \"Latin-1 Supplement\"\n    ],\n    \"has_sig_or_bom\": false,\n    \"chaos\": 0.149,\n    \"coherence\": 97.152,\n    \"unicode_path\": null,\n    \"is_preferred\": true\n}\n```\n\n### Python\n*Just print out normalized text*\n```python\nfrom charset_normalizer import from_path\n\nresults = from_path('./my_subtitle.srt')\n\nprint(str(results.best()))\n```\n\n*Upgrade your code without effort*\n```python\nfrom charset_normalizer import detect\n```\n\nThe above code will behave the same as **chardet**. We ensure that we offer the best (reasonable) BC result possible.\n\nSee the docs for advanced usage : [readthedocs.io](https://charset-normalizer.readthedocs.io/en/latest/)\n\n## \ud83d\ude07 Why\n\nWhen I started using Chardet, I noticed that it was not suited to my expectations, and I wanted to propose a\nreliable alternative using a completely different method. Also! I never back down on a good challenge!\n\nI **don't care** about the **originating charset** encoding, because **two different tables** can\nproduce **two identical rendered string.**\nWhat I want is to get readable text, the best I can.\n\nIn a way, **I'm brute forcing text decoding.** How cool is that ? \ud83d\ude0e\n\nDon't confuse package **ftfy** with charset-normalizer or chardet. ftfy goal is to repair Unicode string whereas charset-normalizer to convert raw file in unknown encoding to unicode.\n\n## \ud83c\udf70 How\n\n  - Discard all charset encoding table that could not fit the binary content.\n  - Measure noise, or the mess once opened (by chunks) with a corresponding charset encoding.\n  - Extract matches with the lowest mess detected.\n  - Additionally, we measure coherence / probe for a language.\n\n**Wait a minute**, what is noise/mess and coherence according to **YOU ?**\n\n*Noise :* I opened hundred of text files, **written by humans**, with the wrong encoding table. **I observed**, then\n**I established** some ground rules about **what is obvious** when **it seems like** a mess (aka. defining noise in rendered text).\n I know that my interpretation of what is noise is probably incomplete, feel free to contribute in order to\n improve or rewrite it.\n\n*Coherence :* For each language there is on earth, we have computed ranked letter appearance occurrences (the best we can). So I thought\nthat intel is worth something here. So I use those records against decoded text to check if I can detect intelligent design.\n\n## \u26a1 Known limitations\n\n  - Language detection is unreliable when text contains two or more languages sharing identical letters. (eg. HTML (english tags) + Turkish content (Sharing Latin characters))\n  - Every charset detector heavily depends on sufficient content. In common cases, do not bother run detection on very tiny content.\n\n## \u26a0\ufe0f About Python EOLs\n\n**If you are running:**\n\n- Python >=2.7,<3.5: Unsupported\n- Python 3.5: charset-normalizer < 2.1\n- Python 3.6: charset-normalizer < 3.1\n- Python 3.7: charset-normalizer < 4.0\n\nUpgrade your Python interpreter as soon as possible.\n\n## \ud83d\udc64 Contributing\n\nContributions, issues and feature requests are very much welcome.<br />\nFeel free to check [issues page](https://github.com/ousret/charset_normalizer/issues) if you want to contribute.\n\n## \ud83d\udcdd License\n\nCopyright \u00a9 [Ahmed TAHRI @Ousret](https://github.com/Ousret).<br />\nThis project is [MIT](https://github.com/Ousret/charset_normalizer/blob/master/LICENSE) licensed.\n\nCharacters frequencies used in this project \u00a9 2012 [Denny Vrande\u010di\u0107](http://simia.net/letters/)\n\n## \ud83d\udcbc For Enterprise\n\nProfessional support for charset-normalizer is available as part of the [Tidelift\nSubscription][1]. Tidelift gives software development teams a single source for\npurchasing and maintaining their software, with professional grade assurances\nfrom the experts who know it best, while seamlessly integrating with existing\ntools.\n\n[1]: https://tidelift.com/subscription/pkg/pypi-charset-normalizer?utm_source=pypi-charset-normalizer&utm_medium=readme\n\n[![OpenSSF Best Practices](https://www.bestpractices.dev/projects/7297/badge)](https://www.bestpractices.dev/projects/7297)\n\n# Changelog\nAll notable changes to charset-normalizer will be documented in this file. This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n\n## [3.4.1](https://github.com/Ousret/charset_normalizer/compare/3.4.0...3.4.1) (2024-12-24)\n\n### Changed\n- Project metadata are now stored using `pyproject.toml` instead of `setup.cfg` using setuptools as the build backend.\n- Enforce annotation delayed loading for a simpler and consistent types in the project.\n- Optional mypyc compilation upgraded to version 1.14 for Python >= 3.8\n\n### Added\n- pre-commit configuration.\n- noxfile.\n\n### Removed\n- `build-requirements.txt` as per using `pyproject.toml` native build configuration.\n- `bin/integration.py` and `bin/serve.py` in favor of downstream integration test (see noxfile).\n- `setup.cfg` in favor of `pyproject.toml` metadata configuration.\n- Unused `utils.range_scan` function.\n\n### Fixed\n- Converting content to Unicode bytes may insert `utf_8` instead of preferred `utf-8`. (#572)\n- Deprecation warning \"'count' is passed as positional argument\" when converting to Unicode bytes on Python 3.13+\n\n## [3.4.0](https://github.com/Ousret/charset_normalizer/compare/3.3.2...3.4.0) (2024-10-08)\n\n### Added\n- Argument `--no-preemptive` in the CLI to prevent the detector to search for hints.\n- Support for Python 3.13 (#512)\n\n### Fixed\n- Relax the TypeError exception thrown when trying to compare a CharsetMatch with anything else than a CharsetMatch.\n- Improved the general reliability of the detector based on user feedbacks. (#520) (#509) (#498) (#407) (#537)\n- Declared charset in content (preemptive detection) not changed when converting to utf-8 bytes. (#381)\n\n## [3.3.2](https://github.com/Ousret/charset_normalizer/compare/3.3.1...3.3.2) (2023-10-31)\n\n### Fixed\n- Unintentional memory usage regression when using large payload that match several encoding (#376)\n- Regression on some detection case showcased in the documentation (#371)\n\n### Added\n- Noise (md) probe that identify malformed arabic representation due to the presence of letters in isolated form (credit to my wife)\n\n## [3.3.1](https://github.com/Ousret/charset_normalizer/compare/3.3.0...3.3.1) (2023-10-22)\n\n### Changed\n- Optional mypyc compilation upgraded to version 1.6.1 for Python >= 3.8\n- Improved the general detection reliability based on reports from the community\n\n## [3.3.0](https://github.com/Ousret/charset_normalizer/compare/3.2.0...3.3.0) (2023-09-30)\n\n### Added\n- Allow to execute the CLI (e.g. normalizer) through `python -m charset_normalizer.cli` or `python -m charset_normalizer`\n- Support for 9 forgotten encoding that are supported by Python but unlisted in `encoding.aliases` as they have no alias (#323)\n\n### Removed\n- (internal) Redundant utils.is_ascii function and unused function is_private_use_only\n- (internal) charset_normalizer.assets is moved inside charset_normalizer.constant\n\n### Changed\n- (internal) Unicode code blocks in constants are updated using the latest v15.0.0 definition to improve detection\n- Optional mypyc compilation upgraded to version 1.5.1 for Python >= 3.8\n\n### Fixed\n- Unable to properly sort CharsetMatch when both chaos/noise and coherence were close due to an unreachable condition in \\_\\_lt\\_\\_ (#350)\n\n## [3.2.0](https://github.com/Ousret/charset_normalizer/compare/3.1.0...3.2.0) (2023-06-07)\n\n### Changed\n- Typehint for function `from_path` no longer enforce `PathLike` as its first argument\n- Minor improvement over the global detection reliability\n\n### Added\n- Introduce function `is_binary` that relies on main capabilities, and optimized to detect binaries\n- Propagate `enable_fallback` argument throughout `from_bytes`, `from_path`, and `from_fp` that allow a deeper control over the detection (default True)\n- Explicit support for Python 3.12\n\n### Fixed\n- Edge case detection failure where a file would contain 'very-long' camel cased word (Issue #289)\n\n## [3.1.0](https://github.com/Ousret/charset_normalizer/compare/3.0.1...3.1.0) (2023-03-06)\n\n### Added\n- Argument `should_rename_legacy` for legacy function `detect` and disregard any new arguments without errors (PR #262)\n\n### Removed\n- Support for Python 3.6 (PR #260)\n\n### Changed\n- Optional speedup provided by mypy/c 1.0.1\n\n## [3.0.1](https://github.com/Ousret/charset_normalizer/compare/3.0.0...3.0.1) (2022-11-18)\n\n### Fixed\n- Multi-bytes cutter/chunk generator did not always cut correctly (PR #233)\n\n### Changed\n- Speedup provided by mypy/c 0.990 on Python >= 3.7\n\n## [3.0.0](https://github.com/Ousret/charset_normalizer/compare/2.1.1...3.0.0) (2022-10-20)\n\n### Added\n- Extend the capability of explain=True when cp_isolation contains at most two entries (min one), will log in details of the Mess-detector results\n- Support for alternative language frequency set in charset_normalizer.assets.FREQUENCIES\n- Add parameter `language_threshold` in `from_bytes`, `from_path` and `from_fp` to adjust the minimum expected coherence ratio\n- `normalizer --version` now specify if current version provide extra speedup (meaning mypyc compilation whl)\n\n### Changed\n- Build with static metadata using 'build' frontend\n- Make the language detection stricter\n- Optional: Module `md.py` can be compiled using Mypyc to provide an extra speedup up to 4x faster than v2.1\n\n### Fixed\n- CLI with opt --normalize fail when using full path for files\n- TooManyAccentuatedPlugin induce false positive on the mess detection when too few alpha character have been fed to it\n- Sphinx warnings when generating the documentation\n\n### Removed\n- Coherence detector no longer return 'Simple English' instead return 'English'\n- Coherence detector no longer return 'Classical Chinese' instead return 'Chinese'\n- Breaking: Method `first()` and `best()` from CharsetMatch\n- UTF-7 will no longer appear as \"detected\" without a recognized SIG/mark (is unreliable/conflict with ASCII)\n- Breaking: Class aliases CharsetDetector, CharsetDoctor, CharsetNormalizerMatch and CharsetNormalizerMatches\n- Breaking: Top-level function `normalize`\n- Breaking: Properties `chaos_secondary_pass`, `coherence_non_latin` and `w_counter` from CharsetMatch\n- Support for the backport `unicodedata2`\n\n## [3.0.0rc1](https://github.com/Ousret/charset_normalizer/compare/3.0.0b2...3.0.0rc1) (2022-10-18)\n\n### Added\n- Extend the capability of explain=True when cp_isolation contains at most two entries (min one), will log in details of the Mess-detector results\n- Support for alternative language frequency set in charset_normalizer.assets.FREQUENCIES\n- Add parameter `language_threshold` in `from_bytes`, `from_path` and `from_fp` to adjust the minimum expected coherence ratio\n\n### Changed\n- Build with static metadata using 'build' frontend\n- Make the language detection stricter\n\n### Fixed\n- CLI with opt --normalize fail when using full path for files\n- TooManyAccentuatedPlugin induce false positive on the mess detection when too few alpha character have been fed to it\n\n### Removed\n- Coherence detector no longer return 'Simple English' instead return 'English'\n- Coherence detector no longer return 'Classical Chinese' instead return 'Chinese'\n\n## [3.0.0b2](https://github.com/Ousret/charset_normalizer/compare/3.0.0b1...3.0.0b2) (2022-08-21)\n\n### Added\n- `normalizer --version` now specify if current version provide extra speedup (meaning mypyc compilation whl)\n\n### Removed\n- Breaking: Method `first()` and `best()` from CharsetMatch\n- UTF-7 will no longer appear as \"detected\" without a recognized SIG/mark (is unreliable/conflict with ASCII)\n\n### Fixed\n- Sphinx warnings when generating the documentation\n\n## [3.0.0b1](https://github.com/Ousret/charset_normalizer/compare/2.1.0...3.0.0b1) (2022-08-15)\n\n### Changed\n- Optional: Module `md.py` can be compiled using Mypyc to provide an extra speedup up to 4x faster than v2.1\n\n### Removed\n- Breaking: Class aliases CharsetDetector, CharsetDoctor, CharsetNormalizerMatch and CharsetNormalizerMatches\n- Breaking: Top-level function `normalize`\n- Breaking: Properties `chaos_secondary_pass`, `coherence_non_latin` and `w_counter` from CharsetMatch\n- Support for the backport `unicodedata2`\n\n## [2.1.1](https://github.com/Ousret/charset_normalizer/compare/2.1.0...2.1.1) (2022-08-19)\n\n### Deprecated\n- Function `normalize` scheduled for removal in 3.0\n\n### Changed\n- Removed useless call to decode in fn is_unprintable (#206)\n\n### Fixed\n- Third-party library (i18n xgettext) crashing not recognizing utf_8 (PEP 263) with underscore from [@aleksandernovikov](https://github.com/aleksandernovikov) (#204)\n\n## [2.1.0](https://github.com/Ousret/charset_normalizer/compare/2.0.12...2.1.0) (2022-06-19)\n\n### Added\n- Output the Unicode table version when running the CLI with `--version` (PR #194)\n\n### Changed\n- Re-use decoded buffer for single byte character sets from [@nijel](https://github.com/nijel) (PR #175)\n- Fixing some performance bottlenecks from [@deedy5](https://github.com/deedy5) (PR #183)\n\n### Fixed\n- Workaround potential bug in cpython with Zero Width No-Break Space located in Arabic Presentation Forms-B, Unicode 1.1 not acknowledged as space (PR #175)\n- CLI default threshold aligned with the API threshold from [@oleksandr-kuzmenko](https://github.com/oleksandr-kuzmenko) (PR #181)\n\n### Removed\n- Support for Python 3.5 (PR #192)\n\n### Deprecated\n- Use of backport unicodedata from `unicodedata2` as Python is quickly catching up, scheduled for removal in 3.0 (PR #194)\n\n## [2.0.12](https://github.com/Ousret/charset_normalizer/compare/2.0.11...2.0.12) (2022-02-12)\n\n### Fixed\n- ASCII miss-detection on rare cases (PR #170)\n\n## [2.0.11](https://github.com/Ousret/charset_normalizer/compare/2.0.10...2.0.11) (2022-01-30)\n\n### Added\n- Explicit support for Python 3.11 (PR #164)\n\n### Changed\n- The logging behavior have been completely reviewed, now using only TRACE and DEBUG levels (PR #163 #165)\n\n## [2.0.10](https://github.com/Ousret/charset_normalizer/compare/2.0.9...2.0.10) (2022-01-04)\n\n### Fixed\n- Fallback match entries might lead to UnicodeDecodeError for large bytes sequence (PR #154)\n\n### Changed\n- Skipping the language-detection (CD) on ASCII (PR #155)\n\n## [2.0.9](https://github.com/Ousret/charset_normalizer/compare/2.0.8...2.0.9) (2021-12-03)\n\n### Changed\n- Moderating the logging impact (since 2.0.8) for specific environments (PR #147)\n\n### Fixed\n- Wrong logging level applied when setting kwarg `explain` to True (PR #146)\n\n## [2.0.8](https://github.com/Ousret/charset_normalizer/compare/2.0.7...2.0.8) (2021-11-24)\n### Changed\n- Improvement over Vietnamese detection (PR #126)\n- MD improvement on trailing data and long foreign (non-pure latin) data (PR #124)\n- Efficiency improvements in cd/alphabet_languages from [@adbar](https://github.com/adbar) (PR #122)\n- call sum() without an intermediary list following PEP 289 recommendations from [@adbar](https://github.com/adbar) (PR #129)\n- Code style as refactored by Sourcery-AI (PR #131)\n- Minor adjustment on the MD around european words (PR #133)\n- Remove and replace SRTs from assets / tests (PR #139)\n- Initialize the library logger with a `NullHandler` by default from [@nmaynes](https://github.com/nmaynes) (PR #135)\n- Setting kwarg `explain` to True will add provisionally (bounded to function lifespan) a specific stream handler (PR #135)\n\n### Fixed\n- Fix large (misleading) sequence giving UnicodeDecodeError (PR #137)\n- Avoid using too insignificant chunk (PR #137)\n\n### Added\n- Add and expose function `set_logging_handler` to configure a specific StreamHandler from [@nmaynes](https://github.com/nmaynes) (PR #135)\n- Add `CHANGELOG.md` entries, format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/) (PR #141)\n\n## [2.0.7](https://github.com/Ousret/charset_normalizer/compare/2.0.6...2.0.7) (2021-10-11)\n### Added\n- Add support for Kazakh (Cyrillic) language detection (PR #109)\n\n### Changed\n- Further, improve inferring the language from a given single-byte code page (PR #112)\n- Vainly trying to leverage PEP263 when PEP3120 is not supported (PR #116)\n- Refactoring for potential performance improvements in loops from [@adbar](https://github.com/adbar) (PR #113)\n- Various detection improvement (MD+CD) (PR #117)\n\n### Removed\n- Remove redundant logging entry about detected language(s) (PR #115)\n\n### Fixed\n- Fix a minor inconsistency between Python 3.5 and other versions regarding language detection (PR #117 #102)\n\n## [2.0.6](https://github.com/Ousret/charset_normalizer/compare/2.0.5...2.0.6) (2021-09-18)\n### Fixed\n- Unforeseen regression with the loss of the backward-compatibility with some older minor of Python 3.5.x (PR #100)\n- Fix CLI crash when using --minimal output in certain cases (PR #103)\n\n### Changed\n- Minor improvement to the detection efficiency (less than 1%) (PR #106 #101)\n\n## [2.0.5](https://github.com/Ousret/charset_normalizer/compare/2.0.4...2.0.5) (2021-09-14)\n### Changed\n- The project now comply with: flake8, mypy, isort and black to ensure a better overall quality (PR #81)\n- The BC-support with v1.x was improved, the old staticmethods are restored (PR #82)\n- The Unicode detection is slightly improved (PR #93)\n- Add syntax sugar \\_\\_bool\\_\\_ for results CharsetMatches list-container (PR #91)\n\n### Removed\n- The project no longer raise warning on tiny content given for detection, will be simply logged as warning instead (PR #92)\n\n### Fixed\n- In some rare case, the chunks extractor could cut in the middle of a multi-byte character and could mislead the mess detection (PR #95)\n- Some rare 'space' characters could trip up the UnprintablePlugin/Mess detection (PR #96)\n- The MANIFEST.in was not exhaustive (PR #78)\n\n## [2.0.4](https://github.com/Ousret/charset_normalizer/compare/2.0.3...2.0.4) (2021-07-30)\n### Fixed\n- The CLI no longer raise an unexpected exception when no encoding has been found (PR #70)\n- Fix accessing the 'alphabets' property when the payload contains surrogate characters (PR #68)\n- The logger could mislead (explain=True) on detected languages and the impact of one MBCS match (PR #72)\n- Submatch factoring could be wrong in rare edge cases (PR #72)\n- Multiple files given to the CLI were ignored when publishing results to STDOUT. (After the first path) (PR #72)\n- Fix line endings from CRLF to LF for certain project files (PR #67)\n\n### Changed\n- Adjust the MD to lower the sensitivity, thus improving the global detection reliability (PR #69 #76)\n- Allow fallback on specified encoding if any (PR #71)\n\n## [2.0.3](https://github.com/Ousret/charset_normalizer/compare/2.0.2...2.0.3) (2021-07-16)\n### Changed\n- Part of the detection mechanism has been improved to be less sensitive, resulting in more accurate detection results. Especially ASCII. (PR #63)\n- According to the community wishes, the detection will fall back on ASCII or UTF-8 in a last-resort case. (PR #64)\n\n## [2.0.2](https://github.com/Ousret/charset_normalizer/compare/2.0.1...2.0.2) (2021-07-15)\n### Fixed\n- Empty/Too small JSON payload miss-detection fixed. Report from [@tseaver](https://github.com/tseaver) (PR #59)\n\n### Changed\n- Don't inject unicodedata2 into sys.modules from [@akx](https://github.com/akx) (PR #57)\n\n## [2.0.1](https://github.com/Ousret/charset_normalizer/compare/2.0.0...2.0.1) (2021-07-13)\n### Fixed\n- Make it work where there isn't a filesystem available, dropping assets frequencies.json. Report from [@sethmlarson](https://github.com/sethmlarson). (PR #55)\n- Using explain=False permanently disable the verbose output in the current runtime (PR #47)\n- One log entry (language target preemptive) was not show in logs when using explain=True (PR #47)\n- Fix undesired exception (ValueError) on getitem of instance CharsetMatches (PR #52)\n\n### Changed\n- Public function normalize default args values were not aligned with from_bytes (PR #53)\n\n### Added\n- You may now use charset aliases in cp_isolation and cp_exclusion arguments (PR #47)\n\n## [2.0.0](https://github.com/Ousret/charset_normalizer/compare/1.4.1...2.0.0) (2021-07-02)\n### Changed\n- 4x to 5 times faster than the previous 1.4.0 release. At least 2x faster than Chardet.\n- Accent has been made on UTF-8 detection, should perform rather instantaneous.\n- The backward compatibility with Chardet has been greatly improved. The legacy detect function returns an identical charset name whenever possible.\n- The detection mechanism has been slightly improved, now Turkish content is detected correctly (most of the time)\n- The program has been rewritten to ease the readability and maintainability. (+Using static typing)+\n- utf_7 detection has been reinstated.\n\n### Removed\n- This package no longer require anything when used with Python 3.5 (Dropped cached_property)\n- Removed support for these languages: Catalan, Esperanto, Kazakh, Baque, Volap\u00fck, Azeri, Galician, Nynorsk, Macedonian, and Serbocroatian.\n- The exception hook on UnicodeDecodeError has been removed.\n\n### Deprecated\n- Methods coherence_non_latin, w_counter, chaos_secondary_pass of the class CharsetMatch are now deprecated and scheduled for removal in v3.0\n\n### Fixed\n- The CLI output used the relative path of the file(s). Should be absolute.\n\n## [1.4.1](https://github.com/Ousret/charset_normalizer/compare/1.4.0...1.4.1) (2021-05-28)\n### Fixed\n- Logger configuration/usage no longer conflict with others (PR #44)\n\n## [1.4.0](https://github.com/Ousret/charset_normalizer/compare/1.3.9...1.4.0) (2021-05-21)\n### Removed\n- Using standard logging instead of using the package loguru.\n- Dropping nose test framework in favor of the maintained pytest.\n- Choose to not use dragonmapper package to help with gibberish Chinese/CJK text.\n- Require cached_property only for Python 3.5 due to constraint. Dropping for every other interpreter version.\n- Stop support for UTF-7 that does not contain a SIG.\n- Dropping PrettyTable, replaced with pure JSON output in CLI.\n\n### Fixed\n- BOM marker in a CharsetNormalizerMatch instance could be False in rare cases even if obviously present. Due to the sub-match factoring process.\n- Not searching properly for the BOM when trying utf32/16 parent codec.\n\n### Changed\n- Improving the package final size by compressing frequencies.json.\n- Huge improvement over the larges payload.\n\n### Added\n- CLI now produces JSON consumable output.\n- Return ASCII if given sequences fit. Given reasonable confidence.\n\n## [1.3.9](https://github.com/Ousret/charset_normalizer/compare/1.3.8...1.3.9) (2021-05-13)\n\n### Fixed\n- In some very rare cases, you may end up getting encode/decode errors due to a bad bytes payload (PR #40)\n\n## [1.3.8](https://github.com/Ousret/charset_normalizer/compare/1.3.7...1.3.8) (2021-05-12)\n\n### Fixed\n- Empty given payload for detection may cause an exception if trying to access the `alphabets` property. (PR #39)\n\n## [1.3.7](https://github.com/Ousret/charset_normalizer/compare/1.3.6...1.3.7) (2021-05-12)\n\n### Fixed\n- The legacy detect function should return UTF-8-SIG if sig is present in the payload. (PR #38)\n\n## [1.3.6](https://github.com/Ousret/charset_normalizer/compare/1.3.5...1.3.6) (2021-02-09)\n\n### Changed\n- Amend the previous release to allow prettytable 2.0 (PR #35)\n\n## [1.3.5](https://github.com/Ousret/charset_normalizer/compare/1.3.4...1.3.5) (2021-02-08)\n\n### Fixed\n- Fix error while using the package with a python pre-release interpreter (PR #33)\n\n### Changed\n- Dependencies refactoring, constraints revised.\n\n### Added\n- Add python 3.9 and 3.10 to the supported interpreters\n\nMIT License\n\nCopyright (c) 2025 TAHRI Ahmed R.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"], "modules": [{"name": "charset_normalizer.cli", "documentation": [], "functions": [], "variables": [], "classes": [], "exports": [{"name": "charset_normalizer.cli.cli_detect", "xref": {"fqname": "charset_normalizer.cli.__main__.cli_detect", "project": null}}, {"name": "charset_normalizer.cli.query_yes_no", "xref": {"fqname": "charset_normalizer.cli.__main__.query_yes_no", "project": null}}]}, {"name": "charset_normalizer.cli.__main__", "documentation": [], "functions": [{"name": "charset_normalizer.cli.__main__.query_yes_no", "asynchronous": false, "params": [{"name": "question", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "default", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Ask a yes/no question via input() and return their answer.\n\n\"question\" is a string that is presented to the user.\n\"default\" is the presumed answer if the user just hits <Enter>.\n    It must be \"yes\" (the default), \"no\" or None (meaning\n    an answer is required of the user).\n\nThe \"answer\" return value is True for \"yes\" or False for \"no\".\n\nCredit goes to (c) https://stackoverflow.com/questions/3041986/apt-command-line-interface-like-yes-no-input"]}, {"name": "charset_normalizer.cli.__main__.cli_detect", "asynchronous": false, "params": [{"name": "argv", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": ["CLI assistant using ARGV and ArgumentParser\n\\:param argv:\n\\:return: 0 if everything is fine, anything else equal trouble\n"]}], "variables": [], "classes": [], "exports": []}, {"name": "charset_normalizer.models", "documentation": [], "functions": [], "variables": [{"name": "charset_normalizer.models.CoherenceMatch", "type": null, "documentation": []}, {"name": "charset_normalizer.models.CoherenceMatches", "type": null, "documentation": []}], "classes": [{"name": "charset_normalizer.models.CharsetMatch", "bases": [], "methods": [{"name": "charset_normalizer.models.CharsetMatch.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "payload", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "guessed_encoding", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "mean_mess_ratio", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": null}, {"name": "has_sig_or_bom", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}, {"name": "languages", "type": {"name": "CoherenceMatches", "xref": {"fqname": "CoherenceMatches", "project": null}, "params": null}, "default": null}, {"name": "decoded_payload", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "preemptive_declaration", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": null, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.__eq__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.__lt__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Implemented to make sorted available upon CharsetMatches items."]}, {"name": "charset_normalizer.models.CharsetMatch.multi_byte_usage", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.__str__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.add_submatch", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "CharsetMatch", "xref": {"fqname": "charset_normalizer.models.CharsetMatch", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.encoding", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.encoding_aliases", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Encoding name are known by many name, using this could help when searching for IBM855 when it's listed as CP855."]}, {"name": "charset_normalizer.models.CharsetMatch.bom", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.byte_order_mark", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.languages", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Return the complete list of possible languages found in decoded sequence.\nUsually not really useful. Returned list may be empty even if 'language' property return something != 'Unknown'."]}, {"name": "charset_normalizer.models.CharsetMatch.language", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Most probable language found in decoded sequence. If none were detected or inferred, the property will return\n\"Unknown\"."]}, {"name": "charset_normalizer.models.CharsetMatch.chaos", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.coherence", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.percent_chaos", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.percent_coherence", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.raw", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Original untouched bytes."]}, {"name": "charset_normalizer.models.CharsetMatch.submatch", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "CharsetMatch", "xref": {"fqname": "charset_normalizer.models.CharsetMatch", "project": null}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.has_submatch", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.alphabets", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatch.could_be_from_charset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["The complete list of encoding that output the exact SAME str result and therefore could be the originating\nencoding.\nThis list does include the encoding available in property 'encoding'."]}, {"name": "charset_normalizer.models.CharsetMatch.output", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "encoding", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Method to get re-encoded bytes payload using given target encoding. Default to UTF-8.\nAny errors will be simply ignored by the encoder NOT replaced."]}, {"name": "charset_normalizer.models.CharsetMatch.fingerprint", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Retrieve the unique SHA256 computed using the transformed (re-encoded) payload. Not the original one."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.models.CharsetMatches", "bases": [], "methods": [{"name": "charset_normalizer.models.CharsetMatches.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "results", "type": {"name": "list[CharsetMatch] | None", "xref": null, "params": null}, "default": "..."}], "returns": null, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatches.__iter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "CharsetMatch", "xref": {"fqname": "charset_normalizer.models.CharsetMatch", "project": null}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatches.__getitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "item", "type": {"name": "int | str", "xref": null, "params": null}, "default": null}], "returns": {"name": "CharsetMatch", "xref": {"fqname": "charset_normalizer.models.CharsetMatch", "project": null}, "params": null}, "documentation": ["Retrieve a single item either by its position or encoding name (alias may be used here).\nRaise KeyError upon invalid index or encoding not present in results."]}, {"name": "charset_normalizer.models.CharsetMatches.__len__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatches.__bool__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.models.CharsetMatches.append", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "item", "type": {"name": "CharsetMatch", "xref": {"fqname": "charset_normalizer.models.CharsetMatch", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Insert a single match. Will be inserted accordingly to preserve sort.\nCan be inserted as a submatch."]}, {"name": "charset_normalizer.models.CharsetMatches.best", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "CharsetMatch | None", "xref": null, "params": null}, "documentation": ["Simply return the first match. Strict equivalent to matches[0]."]}, {"name": "charset_normalizer.models.CharsetMatches.first", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "CharsetMatch | None", "xref": null, "params": null}, "documentation": ["Redundant method, call the method best(). Kept for BC reasons."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Container with every CharsetMatch items ordered by default from most probable to the less one.\nAct like a list(iterable) but does not implements all related methods."]}, {"name": "charset_normalizer.models.CliDetectionResult", "bases": [], "methods": [{"name": "charset_normalizer.models.CliDetectionResult.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "path", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "encoding", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "encoding_aliases", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "alternative_encodings", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "language", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "alphabets", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "has_sig_or_bom", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}, {"name": "chaos", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": null}, {"name": "coherence", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": null}, {"name": "unicode_path", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "is_preferred", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}], "returns": null, "documentation": []}, {"name": "charset_normalizer.models.CliDetectionResult.__dict__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.models.CliDetectionResult.to_json", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "charset_normalizer.__main__", "documentation": [], "functions": [], "variables": [], "classes": [], "exports": []}, {"name": "charset_normalizer.version", "documentation": ["Expose version"], "functions": [], "variables": [{"name": "charset_normalizer.version.__version__", "type": null, "documentation": []}, {"name": "charset_normalizer.version.VERSION", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "charset_normalizer.legacy", "documentation": [], "functions": [{"name": "charset_normalizer.legacy.detect", "asynchronous": false, "params": [{"name": "byte_str", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "should_rename_legacy", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "**kwargs", "type": {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "ResultDict", "xref": {"fqname": "charset_normalizer.legacy.ResultDict", "project": null}, "params": null}, "documentation": ["chardet legacy method\nDetect the encoding of the given byte string. It should be mostly backward-compatible.\nEncoding name will match Chardet own writing whenever possible. (Not on encoding name unsupported by it)\nThis function is deprecated and should be used to migrate your project easily, consult the documentation for\nfurther information. Not planned for removal.\n\n```\nparam byte_str\n\nThe byte sequence to examine.\n\nparam should_rename_legacy\n\nShould we rename legacy encodings\nto their more modern equivalents?\n```\n"]}], "variables": [], "classes": [{"name": "charset_normalizer.legacy.ResultDict", "bases": ["TypedDict"], "methods": [], "class_variables": [{"name": "charset_normalizer.legacy.ResultDict.encoding", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "charset_normalizer.legacy.ResultDict.language", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.legacy.ResultDict.confidence", "type": {"name": "float | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "charset_normalizer.api", "documentation": [], "functions": [{"name": "charset_normalizer.api.from_bytes", "asynchronous": false, "params": [{"name": "sequences", "type": {"name": "bytes | bytearray", "xref": null, "params": null}, "default": null}, {"name": "steps", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "chunk_size", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "cp_isolation", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "cp_exclusion", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "preemptive_behaviour", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "explain", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "language_threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enable_fallback", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "CharsetMatches", "xref": {"fqname": "charset_normalizer.api.models.CharsetMatches", "project": null}, "params": null}, "documentation": ["Given a raw bytes sequence, return the best possibles charset usable to render str objects.\nIf there is no results, it is a strong indicator that the source is binary/not text.\nBy default, the process will extract 5 blocks of 512o each to assess the mess and coherence of a given sequence.\nAnd will give up a particular code page after 20% of measured mess. Those criteria are customizable at will.\n\nThe preemptive behavior DOES NOT replace the traditional detection workflow, it prioritize a particular code page\nbut never take it for granted. Can improve the performance.\n\nYou may want to focus your attention to some code page or/and not others, use cp_isolation and cp_exclusion for that\npurpose.\n\nThis function will strip the SIG in the payload/sequence every time except on UTF-16, UTF-32.\nBy default the library does not setup any handler other than the NullHandler, if you choose to set the 'explain'\ntoggle to True it will alter the logger configuration to add a StreamHandler that is suitable for debugging.\nCustom logging format and handler can be set manually."]}, {"name": "charset_normalizer.api.from_fp", "asynchronous": false, "params": [{"name": "fp", "type": {"name": "BinaryIO", "xref": {"fqname": "typing.BinaryIO", "project": "--std--"}, "params": null}, "default": null}, {"name": "steps", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "chunk_size", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "cp_isolation", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "cp_exclusion", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "preemptive_behaviour", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "explain", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "language_threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enable_fallback", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "CharsetMatches", "xref": {"fqname": "charset_normalizer.api.models.CharsetMatches", "project": null}, "params": null}, "documentation": ["Same thing than the function from_bytes but using a file pointer that is already ready.\nWill not close the file pointer."]}, {"name": "charset_normalizer.api.from_path", "asynchronous": false, "params": [{"name": "path", "type": {"name": "str | bytes | PathLike", "xref": null, "params": null}, "default": null}, {"name": "steps", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "chunk_size", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "cp_isolation", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "cp_exclusion", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "preemptive_behaviour", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "explain", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "language_threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enable_fallback", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "CharsetMatches", "xref": {"fqname": "charset_normalizer.api.models.CharsetMatches", "project": null}, "params": null}, "documentation": ["Same thing than the function from_bytes but with one extra step. Opening and reading given file path in binary mode.\nCan raise IOError."]}, {"name": "charset_normalizer.api.is_binary", "asynchronous": false, "params": [{"name": "fp_or_path_or_payload", "type": {"name": "PathLike | str | BinaryIO | bytes", "xref": null, "params": null}, "default": null}, {"name": "steps", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "chunk_size", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "cp_isolation", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "cp_exclusion", "type": {"name": "list[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "preemptive_behaviour", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "explain", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "language_threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enable_fallback", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Detect if the given input (file, bytes, or path) points to a binary file. aka. not a string.\nBased on the same main heuristic algorithms and default kwargs at the sole exception that fallbacks match\nare disabled to be stricter around ASCII-compatible but unlikely to be a string."]}], "variables": [{"name": "charset_normalizer.api.logger", "type": null, "documentation": []}, {"name": "charset_normalizer.api.explain_handler", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "charset_normalizer.cd", "documentation": [], "functions": [{"name": "charset_normalizer.cd.encoding_unicode_range", "asynchronous": false, "params": [{"name": "iana_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Return associated unicode ranges in a single byte code page."]}, {"name": "charset_normalizer.cd.unicode_range_languages", "asynchronous": false, "params": [{"name": "primary_range", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Return inferred languages used with a unicode range."]}, {"name": "charset_normalizer.cd.encoding_languages", "asynchronous": false, "params": [{"name": "iana_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Single-byte encoding language association. Some code page are heavily linked to particular language(s).\nThis function does the correspondence."]}, {"name": "charset_normalizer.cd.mb_encoding_languages", "asynchronous": false, "params": [{"name": "iana_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Multi-byte encoding language association. Some code page are heavily linked to particular language(s).\nThis function does the correspondence."]}, {"name": "charset_normalizer.cd.get_target_features", "asynchronous": false, "params": [{"name": "language", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}]}, "documentation": ["Determine main aspects from a supported language if it contains accents and if is pure Latin."]}, {"name": "charset_normalizer.cd.alphabet_languages", "asynchronous": false, "params": [{"name": "characters", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "ignore_non_latin", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Return associated languages associated to given characters."]}, {"name": "charset_normalizer.cd.characters_popularity_compare", "asynchronous": false, "params": [{"name": "language", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "ordered_characters", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": ["Determine if a ordered characters list (by occurrence from most appearance to rarest) match a particular language.\nThe result is a ratio between 0. (absolutely no correspondence) and 1. (near perfect fit).\nBeware that is function is not strict on the match in order to ease the detection. (Meaning close match is 1.)"]}, {"name": "charset_normalizer.cd.alpha_unicode_split", "asynchronous": false, "params": [{"name": "decoded_sequence", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Given a decoded text sequence, return a list of str. Unicode range / alphabet separation.\nEx. a text containing English/Latin with a bit a Hebrew will return two items in the resulting list;\nOne containing the latin letters and the other hebrew."]}, {"name": "charset_normalizer.cd.merge_coherence_ratios", "asynchronous": false, "params": [{"name": "results", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "CoherenceMatches", "xref": {"fqname": "charset_normalizer.cd.models.CoherenceMatches", "project": null}, "params": null}]}, "default": null}], "returns": {"name": "CoherenceMatches", "xref": {"fqname": "charset_normalizer.cd.models.CoherenceMatches", "project": null}, "params": null}, "documentation": ["This function merge results previously given by the function coherence_ratio.\nThe return type is the same as coherence_ratio."]}, {"name": "charset_normalizer.cd.filter_alt_coherence_matches", "asynchronous": false, "params": [{"name": "results", "type": {"name": "CoherenceMatches", "xref": {"fqname": "charset_normalizer.cd.models.CoherenceMatches", "project": null}, "params": null}, "default": null}], "returns": {"name": "CoherenceMatches", "xref": {"fqname": "charset_normalizer.cd.models.CoherenceMatches", "project": null}, "params": null}, "documentation": ["We shall NOT return \"English\u2014\" in CoherenceMatches because it is an alternative\nof \"English\". This function only keeps the best match and remove the em-dash in it."]}, {"name": "charset_normalizer.cd.coherence_ratio", "asynchronous": false, "params": [{"name": "decoded_sequence", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "lg_inclusion", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "CoherenceMatches", "xref": {"fqname": "charset_normalizer.cd.models.CoherenceMatches", "project": null}, "params": null}, "documentation": ["Detect ANY language that can be identified in given sequence. The sequence will be analysed by layers.\nA layer = Character extraction by alphabets/ranges."]}], "variables": [], "classes": [], "exports": []}, {"name": "charset_normalizer", "documentation": ["Charset-Normalizer\n~~~~~~~~~~~~~~\nThe Real First Universal Charset Detector.\nA library that helps you read text from an unknown charset encoding.\nMotivated by chardet, This package is trying to resolve the issue by taking a new approach.\nAll IANA character set names for which the Python core library provides codecs are supported.\n\nBasic usage:\n   >>> from charset_normalizer import from_bytes\n   >>> results = from_bytes('B\u0441\u0435\u043a\u0438 \u0447\u043e\u0432\u0435\u043a \u0438\u043c\u0430 \u043f\u0440\u0430\u0432\u043e \u043d\u0430 \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435. O\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u0442\u043e!'.encode('utf_8'))\n   >>> best_guess = results.best()\n   >>> str(best_guess)\n   'B\u0441\u0435\u043a\u0438 \u0447\u043e\u0432\u0435\u043a \u0438\u043c\u0430 \u043f\u0440\u0430\u0432\u043e \u043d\u0430 \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435. O\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u0442\u043e!'\n\nOthers methods and usages are available - see the full documentation\nat <https://github.com/Ousret/charset_normalizer>.\n:copyright: (c) 2021 by Ahmed TAHRI\n:license: MIT, see LICENSE for more details."], "functions": [], "variables": [], "classes": [], "exports": [{"name": "charset_normalizer.__version__", "xref": {"fqname": "charset_normalizer.version.__version__", "project": null}}, {"name": "charset_normalizer.CharsetMatch", "xref": {"fqname": "charset_normalizer.models.CharsetMatch", "project": null}}, {"name": "charset_normalizer.CharsetMatches", "xref": {"fqname": "charset_normalizer.models.CharsetMatches", "project": null}}, {"name": "charset_normalizer.detect", "xref": {"fqname": "charset_normalizer.legacy.detect", "project": null}}, {"name": "charset_normalizer.from_bytes", "xref": {"fqname": "charset_normalizer.api.from_bytes", "project": null}}, {"name": "charset_normalizer.from_fp", "xref": {"fqname": "charset_normalizer.api.from_fp", "project": null}}, {"name": "charset_normalizer.from_path", "xref": {"fqname": "charset_normalizer.api.from_path", "project": null}}, {"name": "charset_normalizer.is_binary", "xref": {"fqname": "charset_normalizer.api.is_binary", "project": null}}, {"name": "charset_normalizer.set_logging_handler", "xref": {"fqname": "charset_normalizer.utils.set_logging_handler", "project": null}}, {"name": "charset_normalizer.VERSION", "xref": {"fqname": "charset_normalizer.version.VERSION", "project": null}}]}, {"name": "charset_normalizer.utils", "documentation": [], "functions": [{"name": "charset_normalizer.utils.is_accentuated", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.remove_accent", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.unicode_range", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Retrieve the Unicode range official name from a single character."]}, {"name": "charset_normalizer.utils.is_latin", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_punctuation", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_symbol", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_emoticon", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_separator", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_case_variable", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_cjk", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_hiragana", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_katakana", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_hangul", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_thai", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_arabic", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_arabic_isolated_form", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_unicode_range_secondary", "asynchronous": false, "params": [{"name": "range_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_unprintable", "asynchronous": false, "params": [{"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.any_specified_encoding", "asynchronous": false, "params": [{"name": "sequence", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "search_zone", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Extract using ASCII-only decoder any specified encoding in the first n-bytes."]}, {"name": "charset_normalizer.utils.is_multi_byte_encoding", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Verify is a specific encoding is a multi byte one based on it IANA name"]}, {"name": "charset_normalizer.utils.identify_sig_or_bom", "asynchronous": false, "params": [{"name": "sequence", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str | None", "xref": null, "params": null}, {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": ["Identify and extract SIG/BOM in given sequence."]}, {"name": "charset_normalizer.utils.should_strip_sig_or_bom", "asynchronous": false, "params": [{"name": "iana_encoding", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.iana_name", "asynchronous": false, "params": [{"name": "cp_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "strict", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Returns the Python normalized encoding name (Not the IANA official name)."]}, {"name": "charset_normalizer.utils.cp_similarity", "asynchronous": false, "params": [{"name": "iana_name_a", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "iana_name_b", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.is_cp_similar", "asynchronous": false, "params": [{"name": "iana_name_a", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "iana_name_b", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Determine if two code page are at least 80% similar. IANA_SUPPORTED_SIMILAR dict was generated using\nthe function cp_similarity."]}, {"name": "charset_normalizer.utils.set_logging_handler", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "level", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "format_string", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.utils.cut_sequence_chunks", "asynchronous": false, "params": [{"name": "sequences", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "encoding_iana", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "offsets", "type": {"name": "range", "xref": {"fqname": "functions.range", "project": "--std--"}, "params": null}, "default": null}, {"name": "chunk_size", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "bom_or_sig_available", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}, {"name": "strip_sig_or_bom", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}, {"name": "sig_payload", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "is_multi_byte_decoder", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}, {"name": "decoded_payload", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "Generator", "xref": {"fqname": "typing.Generator", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}]}, "documentation": []}], "variables": [], "classes": [], "exports": []}, {"name": "charset_normalizer.md", "documentation": [], "functions": [{"name": "charset_normalizer.md.is_suspiciously_successive_range", "asynchronous": false, "params": [{"name": "unicode_range_a", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "unicode_range_b", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Determine if two Unicode range seen next to each other can be considered as suspicious."]}, {"name": "charset_normalizer.md.mess_ratio", "asynchronous": false, "params": [{"name": "decoded_sequence", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "maximum_threshold", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "debug", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": ["Compute a mess ratio given a decoded bytes sequence. The maximum threshold does stop the computation earlier."]}], "variables": [], "classes": [{"name": "charset_normalizer.md.MessDetectorPlugin", "bases": [], "methods": [{"name": "charset_normalizer.md.MessDetectorPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Determine if given character should be fed in."]}, {"name": "charset_normalizer.md.MessDetectorPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["The main routine to be executed upon character.\nInsert the logic in witch the text would be considered chaotic."]}, {"name": "charset_normalizer.md.MessDetectorPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Permit to reset the plugin to the initial state."]}, {"name": "charset_normalizer.md.MessDetectorPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": ["Compute the chaos ratio based on what your feed() has seen.\nMust NOT be lower than 0.; No restriction gt 0."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Base abstract class used for mess detection plugins.\nAll detectors MUST extend and implement given methods."]}, {"name": "charset_normalizer.md.TooManySymbolOrPunctuationPlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.TooManySymbolOrPunctuationPlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManySymbolOrPunctuationPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManySymbolOrPunctuationPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManySymbolOrPunctuationPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManySymbolOrPunctuationPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.md.TooManyAccentuatedPlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.TooManyAccentuatedPlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManyAccentuatedPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManyAccentuatedPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManyAccentuatedPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.TooManyAccentuatedPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.md.UnprintablePlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.UnprintablePlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.UnprintablePlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.UnprintablePlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.UnprintablePlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.UnprintablePlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.md.SuspiciousDuplicateAccentPlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.SuspiciousDuplicateAccentPlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousDuplicateAccentPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousDuplicateAccentPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousDuplicateAccentPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousDuplicateAccentPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.md.SuspiciousRange", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.SuspiciousRange.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousRange.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousRange.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousRange.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuspiciousRange.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.md.SuperWeirdWordPlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.SuperWeirdWordPlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuperWeirdWordPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuperWeirdWordPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuperWeirdWordPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.SuperWeirdWordPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.md.CjkInvalidStopPlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.CjkInvalidStopPlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.CjkInvalidStopPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.CjkInvalidStopPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.CjkInvalidStopPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.CjkInvalidStopPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["GB(Chinese) based encoding often render the stop incorrectly when the content does not fit and\ncan be easily detected. Searching for the overuse of '\u4e05' and '\u4e04'."]}, {"name": "charset_normalizer.md.ArchaicUpperLowerPlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.ArchaicUpperLowerPlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArchaicUpperLowerPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArchaicUpperLowerPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArchaicUpperLowerPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArchaicUpperLowerPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "charset_normalizer.md.ArabicIsolatedFormPlugin", "bases": ["MessDetectorPlugin"], "methods": [{"name": "charset_normalizer.md.ArabicIsolatedFormPlugin.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArabicIsolatedFormPlugin.reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArabicIsolatedFormPlugin.eligible", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArabicIsolatedFormPlugin.feed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "character", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.md.ArabicIsolatedFormPlugin.ratio", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "charset_normalizer.constant", "documentation": [], "functions": [], "variables": [{"name": "charset_normalizer.constant.ENCODING_MARKS", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "bytes | list[bytes]", "xref": null, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.TOO_SMALL_SEQUENCE", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.constant.TOO_BIG_SEQUENCE", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.constant.UTF8_MAXIMAL_ALLOCATION", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.constant.UNICODE_RANGES_COMBINED", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "range", "xref": {"fqname": "functions.range", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.UNICODE_SECONDARY_RANGE_KEYWORD", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.RE_POSSIBLE_ENCODING_INDICATION", "type": null, "documentation": []}, {"name": "charset_normalizer.constant.IANA_NO_ALIASES", "type": null, "documentation": []}, {"name": "charset_normalizer.constant.IANA_SUPPORTED", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.IANA_SUPPORTED_COUNT", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.constant.IANA_SUPPORTED_SIMILAR", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}]}, "documentation": []}, {"name": "charset_normalizer.constant.CHARDET_CORRESPONDENCE", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.COMMON_SAFE_ASCII_CHARACTERS", "type": {"name": "set", "xref": {"fqname": "functions.set", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.KO_NAMES", "type": {"name": "set", "xref": {"fqname": "functions.set", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.ZH_NAMES", "type": {"name": "set", "xref": {"fqname": "functions.set", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "charset_normalizer.constant.TRACE", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "charset_normalizer.constant.FREQUENCIES", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}]}, "documentation": []}, {"name": "charset_normalizer.constant.LANGUAGE_SUPPORTED_COUNT", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}], "classes": [], "exports": []}]}