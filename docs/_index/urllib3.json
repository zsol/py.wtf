{"name": "urllib3", "metadata": {"name": "urllib3", "version": "2.3.0", "classifiers": ["Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3 :: Only", "Programming Language :: Python :: 3.10", "Programming Language :: Python :: 3.11", "Programming Language :: Python :: 3.12", "Programming Language :: Python :: 3.13", "Programming Language :: Python :: 3.9", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development :: Libraries"], "home_page": null, "license": null, "documentation_url": "https://urllib3.readthedocs.io", "dependencies": [], "summary": "HTTP library with thread-safe connection pooling, file post, and more.", "upload_time": 1734853648}, "documentation": ["<h1 align=\"center\">\n\n![urllib3](https://github.com/urllib3/urllib3/raw/main/docs/_static/banner_github.svg)\n\n</h1>\n\n<p align=\"center\">\n  <a href=\"https://pypi.org/project/urllib3\"><img alt=\"PyPI Version\" src=\"https://img.shields.io/pypi/v/urllib3.svg?maxAge=86400\" /></a>\n  <a href=\"https://pypi.org/project/urllib3\"><img alt=\"Python Versions\" src=\"https://img.shields.io/pypi/pyversions/urllib3.svg?maxAge=86400\" /></a>\n  <a href=\"https://discord.gg/urllib3\"><img alt=\"Join our Discord\" src=\"https://img.shields.io/discord/756342717725933608?color=%237289da&label=discord\" /></a>\n  <a href=\"https://github.com/urllib3/urllib3/actions?query=workflow%3ACI\"><img alt=\"Coverage Status\" src=\"https://img.shields.io/badge/coverage-100%25-success\" /></a>\n  <a href=\"https://github.com/urllib3/urllib3/actions/workflows/ci.yml?query=branch%3Amain\"><img alt=\"Build Status on GitHub\" src=\"https://github.com/urllib3/urllib3/actions/workflows/ci.yml/badge.svg?branch:main&workflow:CI\" /></a>\n  <a href=\"https://urllib3.readthedocs.io\"><img alt=\"Documentation Status\" src=\"https://readthedocs.org/projects/urllib3/badge/?version=latest\" /></a><br>\n  <a href=\"https://deps.dev/pypi/urllib3\"><img alt=\"OpenSSF Scorecard\" src=\"https://api.securityscorecards.dev/projects/github.com/urllib3/urllib3/badge\" /></a>\n  <a href=\"https://slsa.dev\"><img alt=\"SLSA 3\" src=\"https://slsa.dev/images/gh-badge-level3.svg\" /></a>\n  <a href=\"https://bestpractices.coreinfrastructure.org/projects/6227\"><img alt=\"CII Best Practices\" src=\"https://bestpractices.coreinfrastructure.org/projects/6227/badge\" /></a>\n</p>\n\nurllib3 is a powerful, *user-friendly* HTTP client for Python. Much of the\nPython ecosystem already uses urllib3 and you should too.\nurllib3 brings many critical features that are missing from the Python\nstandard libraries:\n\n- Thread safety.\n- Connection pooling.\n- Client-side SSL/TLS verification.\n- File uploads with multipart encoding.\n- Helpers for retrying requests and dealing with HTTP redirects.\n- Support for gzip, deflate, brotli, and zstd encoding.\n- Proxy support for HTTP and SOCKS.\n- 100% test coverage.\n\nurllib3 is powerful and easy to use:\n\n```python3\n>>> import urllib3\n>>> resp = urllib3.request(\"GET\", \"http://httpbin.org/robots.txt\")\n>>> resp.status\n200\n>>> resp.data\nb\"User-agent: *\\nDisallow: /deny\\n\"\n```\n\n## Installing\n\nurllib3 can be installed with [pip](https://pip.pypa.io):\n\n```bash\n$ python -m pip install urllib3\n```\n\nAlternatively, you can grab the latest source code from [GitHub](https://github.com/urllib3/urllib3):\n\n```bash\n$ git clone https://github.com/urllib3/urllib3.git\n$ cd urllib3\n$ pip install .\n```\n\n\n## Documentation\n\nurllib3 has usage and reference documentation at [urllib3.readthedocs.io](https://urllib3.readthedocs.io).\n\n\n## Community\n\nurllib3 has a [community Discord channel](https://discord.gg/urllib3) for asking questions and\ncollaborating with other contributors. Drop by and say hello \ud83d\udc4b\n\n\n## Contributing\n\nurllib3 happily accepts contributions. Please see our\n[contributing documentation](https://urllib3.readthedocs.io/en/latest/contributing.html)\nfor some tips on getting started.\n\n\n## Security Disclosures\n\nTo report a security vulnerability, please use the\n[Tidelift security contact](https://tidelift.com/security).\nTidelift will coordinate the fix and disclosure with maintainers.\n\n\n## Maintainers\n\n- [@sethmlarson](https://github.com/sethmlarson) (Seth M. Larson)\n- [@pquentin](https://github.com/pquentin) (Quentin Pradet)\n- [@illia-v](https://github.com/illia-v) (Illia Volochii)\n- [@theacodes](https://github.com/theacodes) (Thea Flowers)\n- [@haikuginger](https://github.com/haikuginger) (Jess Shapiro)\n- [@lukasa](https://github.com/lukasa) (Cory Benfield)\n- [@sigmavirus24](https://github.com/sigmavirus24) (Ian Stapleton Cordasco)\n- [@shazow](https://github.com/shazow) (Andrey Petrov)\n\n\ud83d\udc4b\n\n\n## Sponsorship\n\nIf your company benefits from this library, please consider [sponsoring its\ndevelopment](https://urllib3.readthedocs.io/en/latest/sponsors.html).\n\n\n## For Enterprise\n\nProfessional support for urllib3 is available as part of the [Tidelift\nSubscription][1].  Tidelift gives software development teams a single source for\npurchasing and maintaining their software, with professional grade assurances\nfrom the experts who know it best, while seamlessly integrating with existing\ntools.\n\n[1]: https://tidelift.com/subscription/pkg/pypi-urllib3?utm_source=pypi-urllib3&utm_medium=referral&utm_campaign=readme\n"], "modules": [{"name": "urllib3._version", "documentation": ["file generated by setuptools_scm", "don't change, don't track in version control"], "functions": [], "variables": [{"name": "urllib3._version.TYPE_CHECKING", "type": null, "documentation": []}, {"name": "urllib3._version.VERSION_TUPLE", "type": null, "documentation": []}, {"name": "urllib3._version.VERSION_TUPLE", "type": null, "documentation": []}, {"name": "urllib3._version.version", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._version.__version__", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._version.__version_tuple__", "type": {"name": "VERSION_TUPLE", "xref": {"fqname": "VERSION_TUPLE", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._version.version_tuple", "type": {"name": "VERSION_TUPLE", "xref": {"fqname": "VERSION_TUPLE", "project": null}, "params": null}, "documentation": []}], "classes": [], "exports": []}, {"name": "urllib3.filepost", "documentation": [], "functions": [{"name": "urllib3.filepost.choose_boundary", "asynchronous": false, "params": [], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Our embarrassingly-simple replacement for mimetools.choose_boundary."]}, {"name": "urllib3.filepost.iter_field_objects", "asynchronous": false, "params": [{"name": "fields", "type": {"name": "_TYPE_FIELDS", "xref": {"fqname": "_TYPE_FIELDS", "project": null}, "params": null}, "default": null}], "returns": {"name": "typing.Iterable", "xref": {"fqname": "typing.Iterable", "project": "--std--"}, "params": [{"name": "RequestField", "xref": {"fqname": "urllib3.filepost.fields.RequestField", "project": null}, "params": null}]}, "documentation": ["Iterate over fields.\n\nSupports list of (k, v) tuples and dicts, and lists of\n{class}`~urllib3.fields.RequestField`.\n"]}, {"name": "urllib3.filepost.encode_multipart_formdata", "asynchronous": false, "params": [{"name": "fields", "type": {"name": "_TYPE_FIELDS", "xref": {"fqname": "_TYPE_FIELDS", "project": null}, "params": null}, "default": null}, {"name": "boundary", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Encode a dictionary of `fields` using the multipart/form-data MIME format.\n\n```\nparam fields\n\nDictionary of fields or list of (key, ).\nValues are processed by .\n\nparam boundary\n\nIf not specified, then a random boundary will be generated using\n.\n```\n"]}], "variables": [{"name": "urllib3.filepost.writer", "type": null, "documentation": []}, {"name": "urllib3.filepost._TYPE_FIELDS_SEQUENCE", "type": null, "documentation": []}, {"name": "urllib3.filepost._TYPE_FIELDS", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "urllib3._base_connection", "documentation": [], "functions": [], "variables": [{"name": "urllib3._base_connection._TYPE_BODY", "type": null, "documentation": []}], "classes": [{"name": "urllib3._base_connection.ProxyConfig", "bases": ["typing.NamedTuple"], "methods": [], "class_variables": [{"name": "urllib3._base_connection.ProxyConfig.ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.ProxyConfig.use_forwarding_for_https", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.ProxyConfig.assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.ProxyConfig.assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3._base_connection._ResponseOptions", "bases": ["typing.NamedTuple"], "methods": [], "class_variables": [{"name": "urllib3._base_connection._ResponseOptions.request_method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection._ResponseOptions.request_url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection._ResponseOptions.preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection._ResponseOptions.decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection._ResponseOptions.enforce_content_length", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection", "bases": ["Protocol"], "methods": [{"name": "urllib3._base_connection.BaseHTTPConnection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "urllib3._base_connection.util.timeout._TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "socket_options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.set_tunnel", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "scheme", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.connect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "chunked", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enforce_content_length", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.getresponse", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3._base_connection.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.is_closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Whether the connection either is brand new or has been previously closed.\nIf this property is True then both `is_connected` and `has_connected_to_proxy`\nproperties must be False.\n"]}, {"name": "urllib3._base_connection.BaseHTTPConnection.is_connected", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Whether the connection is actively connected to any origin (proxy or target)"]}, {"name": "urllib3._base_connection.BaseHTTPConnection.has_connected_to_proxy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Whether the connection has successfully connected to its proxy.\nThis returns False if no proxy is in use. Used to determine whether\nerrors are coming from the proxy layer or from tunnelling to the target origin."]}], "class_variables": [{"name": "urllib3._base_connection.BaseHTTPConnection.default_port", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.default_socket_options", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "_TYPE_SOCKET_OPTIONS", "xref": {"fqname": "urllib3._base_connection.util.connection._TYPE_SOCKET_OPTIONS", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.port", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.timeout", "type": {"name": "None | (\n    float\n)", "xref": null, "params": null}, "documentation": ["Instance doesn't store _DEFAULT_TIMEOUT, must be resolved."]}, {"name": "urllib3._base_connection.BaseHTTPConnection.blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.socket_options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.is_verified", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPConnection.proxy_is_verified", "type": {"name": "bool | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection", "bases": ["BaseHTTPConnection", "Protocol"], "methods": [{"name": "urllib3._base_connection.BaseHTTPSConnection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "urllib3._base_connection.util.timeout._TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "socket_options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "default": "..."}, {"name": "assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3._base_connection.BaseHTTPSConnection.default_port", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.default_socket_options", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "_TYPE_SOCKET_OPTIONS", "xref": {"fqname": "urllib3._base_connection.util.connection._TYPE_SOCKET_OPTIONS", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "documentation": ["Deprecated"]}, {"name": "urllib3._base_connection.BaseHTTPSConnection.cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.key_file", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._base_connection.BaseHTTPSConnection.key_password", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.exceptions", "documentation": [], "functions": [], "variables": [{"name": "urllib3.exceptions._TYPE_REDUCE_RESULT", "type": null, "documentation": []}, {"name": "urllib3.exceptions.ConnectionError", "type": null, "documentation": []}], "classes": [{"name": "urllib3.exceptions.HTTPError", "bases": ["Exception"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Base exception used by this module.", "Base Exceptions"]}, {"name": "urllib3.exceptions.HTTPWarning", "bases": ["Warning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Base warning used by this module."]}, {"name": "urllib3.exceptions.PoolError", "bases": ["HTTPError"], "methods": [{"name": "urllib3.exceptions.PoolError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "pool", "type": {"name": "ConnectionPool", "xref": {"fqname": "urllib3.exceptions.connectionpool.ConnectionPool", "project": null}, "params": null}, "default": null}, {"name": "message", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.exceptions.PoolError.__reduce__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "_TYPE_REDUCE_RESULT", "xref": {"fqname": "_TYPE_REDUCE_RESULT", "project": null}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Base exception for errors caused within a pool."]}, {"name": "urllib3.exceptions.RequestError", "bases": ["PoolError"], "methods": [{"name": "urllib3.exceptions.RequestError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "pool", "type": {"name": "ConnectionPool", "xref": {"fqname": "urllib3.exceptions.connectionpool.ConnectionPool", "project": null}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "message", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.exceptions.RequestError.__reduce__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "_TYPE_REDUCE_RESULT", "xref": {"fqname": "_TYPE_REDUCE_RESULT", "project": null}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Base exception for PoolErrors that have associated URLs."]}, {"name": "urllib3.exceptions.SSLError", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when SSL certificate fails in an HTTPS connection."]}, {"name": "urllib3.exceptions.ProxyError", "bases": ["HTTPError"], "methods": [{"name": "urllib3.exceptions.ProxyError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "message", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "error", "type": {"name": "Exception", "xref": {"fqname": "functions.Exception", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3.exceptions.ProxyError.original_error", "type": {"name": "Exception", "xref": {"fqname": "functions.Exception", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when the connection to a proxy fails."]}, {"name": "urllib3.exceptions.DecodeError", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when automatic decoding based on Content-Type fails."]}, {"name": "urllib3.exceptions.ProtocolError", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when something unexpected happens mid-request/response."]}, {"name": "urllib3.exceptions.MaxRetryError", "bases": ["RequestError"], "methods": [{"name": "urllib3.exceptions.MaxRetryError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "pool", "type": {"name": "ConnectionPool", "xref": {"fqname": "urllib3.exceptions.connectionpool.ConnectionPool", "project": null}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "reason", "type": {"name": "Exception | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when the maximum number of retries is exceeded.\n\n```\nparam pool\n\nThe connection pool\n\ntype pool\n\n\n\nparam str url\n\nThe requested Url\n\nparam reason\n\nThe underlying error\n\ntype reason\n\n```\n", "Leaf Exceptions"]}, {"name": "urllib3.exceptions.HostChangedError", "bases": ["RequestError"], "methods": [{"name": "urllib3.exceptions.HostChangedError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "pool", "type": {"name": "ConnectionPool", "xref": {"fqname": "urllib3.exceptions.connectionpool.ConnectionPool", "project": null}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "retries", "type": {"name": "Retry | int", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when an existing pool gets a request for a foreign host."]}, {"name": "urllib3.exceptions.TimeoutStateError", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when passing an invalid state to a timeout"]}, {"name": "urllib3.exceptions.TimeoutError", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when a socket timeout error occurs.\n\nCatching this error will catch both {exc}`ReadTimeoutErrors\n<ReadTimeoutError>` and {exc}`ConnectTimeoutErrors <ConnectTimeoutError>`.\n"]}, {"name": "urllib3.exceptions.ReadTimeoutError", "bases": ["TimeoutError", "RequestError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when a socket timeout occurs while receiving data from a server"]}, {"name": "urllib3.exceptions.ConnectTimeoutError", "bases": ["TimeoutError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when a socket timeout occurs while connecting to a server", "This timeout error does not have a URL attached and needs to inherit from the", "base HTTPError"]}, {"name": "urllib3.exceptions.NewConnectionError", "bases": ["ConnectTimeoutError", "HTTPError"], "methods": [{"name": "urllib3.exceptions.NewConnectionError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": {"name": "HTTPConnection", "xref": {"fqname": "urllib3.exceptions.connection.HTTPConnection", "project": null}, "params": null}, "default": null}, {"name": "message", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.exceptions.NewConnectionError.__reduce__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "_TYPE_REDUCE_RESULT", "xref": {"fqname": "_TYPE_REDUCE_RESULT", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.exceptions.NewConnectionError.pool", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "HTTPConnection", "xref": {"fqname": "urllib3.exceptions.connection.HTTPConnection", "project": null}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when we fail to establish a new connection. Usually ECONNREFUSED."]}, {"name": "urllib3.exceptions.NameResolutionError", "bases": ["NewConnectionError"], "methods": [{"name": "urllib3.exceptions.NameResolutionError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "conn", "type": {"name": "HTTPConnection", "xref": {"fqname": "urllib3.exceptions.connection.HTTPConnection", "project": null}, "params": null}, "default": null}, {"name": "reason", "type": {"name": "socket.gaierror", "xref": {"fqname": "socket.gaierror", "project": "--std--"}, "params": null}, "default": null}], "returns": null, "documentation": []}, {"name": "urllib3.exceptions.NameResolutionError.__reduce__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "_TYPE_REDUCE_RESULT", "xref": {"fqname": "_TYPE_REDUCE_RESULT", "project": null}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when host name resolution fails."]}, {"name": "urllib3.exceptions.EmptyPoolError", "bases": ["PoolError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when a pool runs out of connections and no more are allowed."]}, {"name": "urllib3.exceptions.FullPoolError", "bases": ["PoolError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when we try to add a connection to a full pool in blocking mode."]}, {"name": "urllib3.exceptions.ClosedPoolError", "bases": ["PoolError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when a request enters a pool after the pool has been closed."]}, {"name": "urllib3.exceptions.LocationValueError", "bases": ["ValueError", "HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when there is something wrong with a given URL input."]}, {"name": "urllib3.exceptions.LocationParseError", "bases": ["LocationValueError"], "methods": [{"name": "urllib3.exceptions.LocationParseError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "location", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when get_host or similar fails to parse the URL input."]}, {"name": "urllib3.exceptions.URLSchemeUnknown", "bases": ["LocationValueError"], "methods": [{"name": "urllib3.exceptions.URLSchemeUnknown.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "scheme", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised when a URL input has an unsupported scheme."]}, {"name": "urllib3.exceptions.ResponseError", "bases": ["HTTPError"], "methods": [], "class_variables": [{"name": "urllib3.exceptions.ResponseError.GENERIC_ERROR", "type": null, "documentation": []}, {"name": "urllib3.exceptions.ResponseError.SPECIFIC_ERROR", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Used as a container for an error reason supplied in a MaxRetryError."]}, {"name": "urllib3.exceptions.SecurityWarning", "bases": ["HTTPWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Warned when performing security reducing actions"]}, {"name": "urllib3.exceptions.InsecureRequestWarning", "bases": ["SecurityWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Warned when making an unverified HTTPS request."]}, {"name": "urllib3.exceptions.NotOpenSSLWarning", "bases": ["SecurityWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Warned when using unsupported SSL library"]}, {"name": "urllib3.exceptions.SystemTimeWarning", "bases": ["SecurityWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Warned when system time is suspected to be wrong"]}, {"name": "urllib3.exceptions.InsecurePlatformWarning", "bases": ["SecurityWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Warned when certain TLS/SSL configuration is not available on a platform."]}, {"name": "urllib3.exceptions.DependencyWarning", "bases": ["HTTPWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Warned when an attempt is made to import a module with missing optional\ndependencies."]}, {"name": "urllib3.exceptions.ResponseNotChunked", "bases": ["ProtocolError", "ValueError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Response needs to be chunked in order to read it as chunks."]}, {"name": "urllib3.exceptions.BodyNotHttplibCompatible", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Body should be {class}`http.client.HTTPResponse` like\n(have an fp attribute which returns raw chunks) for read_chunked().\n"]}, {"name": "urllib3.exceptions.IncompleteRead", "bases": ["HTTPError", "httplib_IncompleteRead"], "methods": [{"name": "urllib3.exceptions.IncompleteRead.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "partial", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "expected", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.exceptions.IncompleteRead.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3.exceptions.IncompleteRead.partial", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": ["type: ignore[assignment]"]}, {"name": "urllib3.exceptions.IncompleteRead.expected", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Response length doesn't match expected Content-Length\n\nSubclass of {class}`http.client.IncompleteRead` to allow int value\nfor `partial` to avoid creating large objects on streamed reads.\n"]}, {"name": "urllib3.exceptions.InvalidChunkLength", "bases": ["HTTPError", "httplib_IncompleteRead"], "methods": [{"name": "urllib3.exceptions.InvalidChunkLength.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "response", "type": {"name": "HTTPResponse", "xref": {"fqname": "urllib3.exceptions.response.HTTPResponse", "project": null}, "params": null}, "default": null}, {"name": "length", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.exceptions.InvalidChunkLength.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Invalid chunk length in a chunked response."]}, {"name": "urllib3.exceptions.InvalidHeader", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The header provided was somehow invalid."]}, {"name": "urllib3.exceptions.ProxySchemeUnknown", "bases": ["AssertionError", "URLSchemeUnknown"], "methods": [{"name": "urllib3.exceptions.ProxySchemeUnknown.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["TODO(t-8ch): Stop inheriting from AssertionError in v2.0."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["ProxyManager does not support the supplied scheme"]}, {"name": "urllib3.exceptions.ProxySchemeUnsupported", "bases": ["ValueError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Fetching HTTPS resources through HTTPS proxies is unsupported"]}, {"name": "urllib3.exceptions.HeaderParsingError", "bases": ["HTTPError"], "methods": [{"name": "urllib3.exceptions.HeaderParsingError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "defects", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "MessageDefect", "xref": {"fqname": "email.errors.MessageDefect", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "unparsed_data", "type": {"name": "bytes | str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Raised by assert_header_parsing, but we convert it to a log.warning statement."]}, {"name": "urllib3.exceptions.UnrewindableBodyError", "bases": ["HTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["urllib3 encountered an error when trying to rewind a body"]}], "exports": []}, {"name": "urllib3.http2.probe", "documentation": [], "functions": [], "variables": [{"name": "urllib3.http2.probe._HTTP2_PROBE_CACHE", "type": null, "documentation": []}, {"name": "urllib3.http2.probe.set_and_release", "type": null, "documentation": []}, {"name": "urllib3.http2.probe.acquire_and_get", "type": null, "documentation": []}, {"name": "urllib3.http2.probe._values", "type": null, "documentation": []}, {"name": "urllib3.http2.probe._reset", "type": null, "documentation": []}], "classes": [{"name": "urllib3.http2.probe._HTTP2ProbeCache", "bases": [], "methods": [{"name": "urllib3.http2.probe._HTTP2ProbeCache.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.probe._HTTP2ProbeCache.acquire_and_get", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.http2.probe._HTTP2ProbeCache.set_and_release", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "supports_http2", "type": {"name": "bool | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.probe._HTTP2ProbeCache._values", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, {"name": "bool | None", "xref": null, "params": null}]}, "documentation": ["This function is for testing purposes only. Gets the current state of the probe cache"]}, {"name": "urllib3.http2.probe._HTTP2ProbeCache._reset", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["This function is for testing purposes only. Reset the cache values"]}], "class_variables": [{"name": "urllib3.http2.probe._HTTP2ProbeCache.__slots__", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": [{"name": "urllib3.http2.probe.acquire_and_get", "xref": {"fqname": "urllib3.http2.probe.acquire_and_get", "project": null}}, {"name": "urllib3.http2.probe.set_and_release", "xref": {"fqname": "urllib3.http2.probe.set_and_release", "project": null}}]}, {"name": "urllib3._collections", "documentation": [], "functions": [{"name": "urllib3._collections.ensure_can_construct_http_header_dict", "asynchronous": false, "params": [{"name": "potential", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "ValidHTTPHeaderSource | None", "xref": null, "params": null}, "documentation": []}], "variables": [{"name": "urllib3._collections._KT", "type": null, "documentation": []}, {"name": "urllib3._collections._VT", "type": null, "documentation": []}, {"name": "urllib3._collections._DT", "type": null, "documentation": []}, {"name": "urllib3._collections.ValidHTTPHeaderSource", "type": null, "documentation": []}], "classes": [{"name": "urllib3._collections.HasGettableStringKeys", "bases": ["Protocol"], "methods": [{"name": "urllib3._collections.HasGettableStringKeys.keys", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3._collections.HasGettableStringKeys.__getitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3._collections._Sentinel", "bases": ["Enum"], "methods": [], "class_variables": [{"name": "urllib3._collections._Sentinel.not_passed", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer", "bases": [], "methods": [{"name": "urllib3._collections.RecentlyUsedContainer.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "maxsize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "dispose_func", "type": {"name": "typing.Callable[[_VT], None] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.__getitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "_KT", "xref": {"fqname": "_KT", "project": null}, "params": null}, "default": null}], "returns": {"name": "_VT", "xref": {"fqname": "_VT", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.__setitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "_KT", "xref": {"fqname": "_KT", "project": null}, "params": null}, "default": null}, {"name": "value", "type": {"name": "_VT", "xref": {"fqname": "_VT", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.__delitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "_KT", "xref": {"fqname": "_KT", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.__len__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.__iter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.NoReturn", "xref": {"fqname": "typing.NoReturn", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.clear", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.keys", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "set", "xref": {"fqname": "functions.set", "project": "--std--"}, "params": [{"name": "_KT", "xref": {"fqname": "_KT", "project": null}, "params": null}]}, "documentation": []}], "class_variables": [{"name": "urllib3._collections.RecentlyUsedContainer._container", "type": {"name": "typing.OrderedDict", "xref": {"fqname": "typing.OrderedDict", "project": "--std--"}, "params": [{"name": "_KT", "xref": {"fqname": "_KT", "project": null}, "params": null}, {"name": "_VT", "xref": {"fqname": "_VT", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer._maxsize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.dispose_func", "type": {"name": "typing.Callable[[_VT], None] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._collections.RecentlyUsedContainer.lock", "type": {"name": "RLock", "xref": {"fqname": "threading.RLock", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Provides a thread-safe dict-like container which maintains up to\n`maxsize` keys while throwing away the least-recently-used keys beyond\n`maxsize`.\n\n```\nparam maxsize\n\nMaximum number of recent elements to retain.\n\nparam dispose_func\n\nEvery time an item is evicted from the container,\ndispose_func(value) is called.  Callback which will get called\n```\n"]}, {"name": "urllib3._collections.HTTPHeaderDictItemView", "bases": [], "methods": [{"name": "urllib3._collections.HTTPHeaderDictItemView.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "headers", "type": {"name": "HTTPHeaderDict", "xref": {"fqname": "HTTPHeaderDict", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDictItemView.__len__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDictItemView.__iter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}]}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDictItemView.__contains__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "item", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3._collections.HTTPHeaderDictItemView._headers", "type": {"name": "HTTPHeaderDict", "xref": {"fqname": "HTTPHeaderDict", "project": null}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of\naddress.\n\nIf we directly try to get an item with a particular name, we will get a string\nback that is the concatenated version of all the values:\n\n```pycon\n>>> d['X-Header-Name']\n'Value1, Value2, Value3'\n```\n\nHowever, if we iterate over an HTTPHeaderDict's items, we will optionally combine\nthese values based on whether combine=True was called when building up the dictionary\n\n```pycon\n>>> d = HTTPHeaderDict({\"A\": \"1\", \"B\": \"foo\"})\n>>> d.add(\"A\", \"2\", combine=True)\n>>> d.add(\"B\", \"bar\")\n>>> list(d.items())\n[\n    ('A', '1, 2'),\n    ('B', 'foo'),\n    ('B', 'bar'),\n]\n```\n\nThis class conforms to the interface required by the MutableMapping ABC while\nalso giving us the nonstandard iteration behavior we want; items with duplicate\nkeys, ordered by time of first insertion.\n"]}, {"name": "urllib3._collections.HTTPHeaderDict", "bases": [], "methods": [{"name": "urllib3._collections.HTTPHeaderDict.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "headers", "type": {"name": "ValidHTTPHeaderSource | None", "xref": null, "params": null}, "default": "..."}, {"name": "**kwargs", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": null, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__setitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "val", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__getitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__delitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__contains__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.setdefault", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "default", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__eq__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__ne__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__len__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__iter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.discard", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.add", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "val", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "combine", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Adds a (name, value) pair, doesn't overwrite the value if it already\nexists.\n\nIf this is called with combine=True, instead of adding a new header value\nas a distinct item during iteration, this will instead append the value to\nany existing header value with a comma. If no existing header value exists\nfor the key, then the value will simply be added, ignoring the combine parameter.\n\n```pycon\n>>> headers = HTTPHeaderDict(foo='bar')\n>>> headers.add('Foo', 'baz')\n>>> headers['foo']\n'bar, baz'\n>>> list(headers.items())\n[('foo', 'bar'), ('foo', 'baz')]\n>>> headers.add('foo', 'quz', combine=True)\n>>> list(headers.items())\n[('foo', 'bar, baz, quz')]\n```\n"]}, {"name": "urllib3._collections.HTTPHeaderDict.extend", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*args", "type": {"name": "ValidHTTPHeaderSource", "xref": {"fqname": "ValidHTTPHeaderSource", "project": null}, "params": null}, "default": null}, {"name": "**kwargs", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Generic import function for any type of header-like object.\nAdapted version of MutableMapping.update in order to insert items\nwith self.add instead of self.__setitem__"]}, {"name": "urllib3._collections.HTTPHeaderDict.getlist", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.getlist", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "default", "type": {"name": "_DT", "xref": {"fqname": "_DT", "project": null}, "params": null}, "default": null}], "returns": {"name": "list[str] | _DT", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.getlist", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "default", "type": {"name": "_Sentinel | _DT", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "list[str] | _DT", "xref": null, "params": null}, "documentation": ["Returns a list of all the values for the named field. Returns an\nempty list if the key doesn't exist."]}, {"name": "urllib3._collections.HTTPHeaderDict._prepare_for_method_change", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": ["Remove content-specific header fields before changing the request\nmethod to GET or HEAD according to RFC 9110, Section 15.4."]}, {"name": "urllib3._collections.HTTPHeaderDict.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict._copy_from", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "HTTPHeaderDict", "xref": {"fqname": "urllib3._collections.HTTPHeaderDict", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.copy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.iteritems", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}]}, "documentation": ["Iterate over all header lines, including duplicate ones."]}, {"name": "urllib3._collections.HTTPHeaderDict.itermerged", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}]}, "documentation": ["Iterate over all headers, merging duplicate ones together."]}, {"name": "urllib3._collections.HTTPHeaderDict.items", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "HTTPHeaderDictItemView", "xref": {"fqname": "urllib3._collections.HTTPHeaderDictItemView", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict._has_value_for_header", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "header_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "potential_value", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__ior__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "HTTPHeaderDict", "xref": {"fqname": "urllib3._collections.HTTPHeaderDict", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__or__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.__ror__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3._collections.HTTPHeaderDict._container", "type": {"name": "typing.MutableMapping", "xref": {"fqname": "typing.MutableMapping", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}]}, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.getheaders", "type": null, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.getallmatchingheaders", "type": null, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.iget", "type": null, "documentation": []}, {"name": "urllib3._collections.HTTPHeaderDict.get_all", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["---\nparam headers: |-\n  An iterable of field-value pairs. Must not contain multiple field names\n  when compared case-insensitively.\nparam kwargs: Additional field-value pairs to pass in to `dict.update`.\n---\n\nA `dict` like container for storing HTTP Headers.\n\nField names are stored and compared case-insensitively in compliance with\nRFC 7230. Iteration provides the first case-sensitive key seen for each\ncase-insensitive pair.\n\nUsing `__setitem__` syntax overwrites fields that compare equal\ncase-insensitively in order to maintain `dict`'s api. For fields that\ncompare equal, instead create a new `HTTPHeaderDict` and use `.add`\nin a loop.\n\nIf multiple fields that are equal case-insensitively are passed to the\nconstructor or `.update`, the behavior is undefined and some will be\nlost.\n\n```pycon\n>>> headers = HTTPHeaderDict()\n>>> headers.add('Set-Cookie', 'foo=bar')\n>>> headers.add('set-cookie', 'baz=quxx')\n>>> headers['content-length'] = '7'\n>>> headers['SET-cookie']\n'foo=bar, baz=quxx'\n>>> headers['Content-Length']\n'7'\n```\n"]}], "exports": [{"name": "urllib3._collections.HTTPHeaderDict", "xref": {"fqname": "urllib3._collections.HTTPHeaderDict", "project": null}}, {"name": "urllib3._collections.RecentlyUsedContainer", "xref": {"fqname": "urllib3._collections.RecentlyUsedContainer", "project": null}}]}, {"name": "urllib3.http2", "documentation": [], "functions": [{"name": "urllib3.http2.inject_into_urllib3", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.extract_from_urllib3", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "variables": [{"name": "urllib3.http2.orig_HTTPSConnection", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "documentation": []}], "classes": [], "exports": [{"name": "urllib3.http2.extract_from_urllib3", "xref": {"fqname": "urllib3.http2.extract_from_urllib3", "project": null}}, {"name": "urllib3.http2.inject_into_urllib3", "xref": {"fqname": "urllib3.http2.inject_into_urllib3", "project": null}}]}, {"name": "urllib3.util.wait", "documentation": [], "functions": [{"name": "urllib3.util.wait.select_wait_for_socket", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "read", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "write", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "float | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["How should we wait on sockets?", "There are two types of APIs you can use for waiting on sockets: the fancy", "modern stateful APIs like epoll/kqueue, and the older stateless APIs like", "select/poll. The stateful APIs are more efficient when you have a lots of", "sockets to keep track of, because you can set them up once and then use them", "lots of times. But we only ever want to wait on a single socket at a time", "and don't want to keep track of state, so the stateless APIs are actually", "more efficient. So we want to use select() or poll().", "Now, how do we choose between select() and poll()? On traditional Unixes,", "select() has a strange calling convention that makes it slow, or fail", "altogether, for high-numbered file descriptors. The point of poll() is to fix", "that, so on Unixes, we prefer poll().", "On Windows, there is no poll() (or at least Python doesn't provide a wrapper", "for it), but that's OK, because on Windows, select() doesn't have this", "strange calling convention; plain select() works fine.", "So: on Windows we use select(), and everywhere else we use poll(). We also", "fall back to select() in case poll() is somehow broken or missing."]}, {"name": "urllib3.util.wait.poll_wait_for_socket", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "read", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "write", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "float | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.wait._have_working_poll", "asynchronous": false, "params": [], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.wait.wait_for_socket", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "read", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "write", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "float | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.wait.wait_for_read", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "timeout", "type": {"name": "float | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Waits for reading to be available on a given socket.\nReturns True if the socket is readable, or False if the timeout expired."]}, {"name": "urllib3.util.wait.wait_for_write", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "timeout", "type": {"name": "float | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Waits for writing to be available on a given socket.\nReturns True if the socket is readable, or False if the timeout expired."]}], "variables": [], "classes": [], "exports": [{"name": "urllib3.util.wait.wait_for_read", "xref": {"fqname": "urllib3.util.wait.wait_for_read", "project": null}}, {"name": "urllib3.util.wait.wait_for_write", "xref": {"fqname": "urllib3.util.wait.wait_for_write", "project": null}}]}, {"name": "urllib3.http2.connection", "documentation": [], "functions": [{"name": "urllib3.http2.connection._is_legal_header_name", "asynchronous": false, "params": [{"name": "name", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["\"An implementation that validates fields according to the definitions in Sections\n5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\ninclude uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n\n`http.client._is_legal_header_name` does not validate the field name according to the\nHTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.\n\nThis does not allow for the `:` character in the header name, so should not\nbe used to validate pseudo-headers."]}, {"name": "urllib3.http2.connection._is_illegal_header_value", "asynchronous": false, "params": [{"name": "value", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["\"A field value MUST NOT contain the zero value (ASCII NUL, 0x00), line feed\n(ASCII LF, 0x0a), or carriage return (ASCII CR, 0x0d) at any position. A field\nvalue MUST NOT start or end with an ASCII whitespace character (ASCII SP or HTAB,\n0x20 or 0x09).\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)"]}], "variables": [{"name": "urllib3.http2.connection.orig_HTTPSConnection", "type": null, "documentation": []}, {"name": "urllib3.http2.connection.T", "type": null, "documentation": []}, {"name": "urllib3.http2.connection.log", "type": null, "documentation": []}, {"name": "urllib3.http2.connection.RE_IS_LEGAL_HEADER_NAME", "type": null, "documentation": []}, {"name": "urllib3.http2.connection.RE_IS_ILLEGAL_HEADER_VALUE", "type": null, "documentation": []}], "classes": [{"name": "urllib3.http2.connection._LockedObject", "bases": [], "methods": [{"name": "urllib3.http2.connection._LockedObject.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "obj", "type": {"name": "T", "xref": {"fqname": "T", "project": null}, "params": null}, "default": null}], "returns": null, "documentation": []}, {"name": "urllib3.http2.connection._LockedObject.__enter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "T", "xref": {"fqname": "T", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection._LockedObject.__exit__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "exc_type", "type": {"name": "type[BaseException] | None", "xref": null, "params": null}, "default": null}, {"name": "exc_val", "type": {"name": "BaseException | None", "xref": null, "params": null}, "default": null}, {"name": "exc_tb", "type": {"name": "types.TracebackType | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3.http2.connection._LockedObject.__slots__", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["A wrapper class that hides a specific object behind a lock.\nThe goal here is to provide a simple way to protect access to an object\nthat cannot safely be simultaneously accessed from multiple threads. The\nintended use of this class is simple: take hold of it with a context\nmanager, which returns the protected object."]}, {"name": "urllib3.http2.connection.HTTP2Connection", "bases": ["HTTPSConnection"], "methods": [{"name": "urllib3.http2.connection.HTTP2Connection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "**kwargs", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Connection._new_h2_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "_LockedObject", "xref": {"fqname": "urllib3.http2.connection._LockedObject", "project": null}, "params": [{"name": "h2.connection.H2Connection", "xref": {"fqname": "h2.connection.H2Connection", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Connection.connect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Connection.putrequest", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "**kwargs", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["putrequest\nThis deviates from the HTTPConnection method signature since we never need to override\nsending accept-encoding headers or the host header."]}, {"name": "urllib3.http2.connection.HTTP2Connection.putheader", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "header", "type": {"name": "str | bytes", "xref": null, "params": null}, "default": null}, {"name": "*values", "type": {"name": "str | bytes", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Connection.endheaders", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "message_body", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Connection.send", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Send data to the server.\n`data` can be: `str`, `bytes`, an iterable, or file-like objects\nthat support a .read() method."]}, {"name": "urllib3.http2.connection.HTTP2Connection.set_tunnel", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "scheme", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Connection.getresponse", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "HTTP2Response", "xref": {"fqname": "HTTP2Response", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Connection.request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enforce_content_length", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "**kwargs", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Send an HTTP/2 request"]}, {"name": "urllib3.http2.connection.HTTP2Connection.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Response", "bases": ["BaseHTTPResponse"], "methods": [{"name": "urllib3.http2.connection.HTTP2Response.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "status", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "headers", "type": {"name": "HTTPHeaderDict", "xref": {"fqname": "urllib3.http2._collections.HTTPHeaderDict", "project": null}, "params": null}, "default": null}, {"name": "request_url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["TODO: This is a woefully incomplete response object, but works for non-streaming."]}, {"name": "urllib3.http2.connection.HTTP2Response.data", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Response.get_redirect_location", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.http2.connection.HTTP2Response.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.util.connection", "documentation": [], "functions": [{"name": "urllib3.util.connection.is_connection_dropped", "asynchronous": false, "params": [{"name": "conn", "type": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.util._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Returns True if the connection is dropped and should be closed.\n\\:param conn: {class}`urllib3.connection.HTTPConnection` object.\n"]}, {"name": "urllib3.util.connection.create_connection", "asynchronous": false, "params": [{"name": "address", "type": {"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "urllib3.util.connection.timeout._TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "socket_options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "documentation": ["Connect to *address* and return the socket object.\n\nConvenience function. Connect to *address* (a 2-tuple `(host,\nport)`) and return the socket object. Passing the optional\n*timeout* parameter will set the timeout on the socket instance\nbefore attempting to connect. If no *timeout* is supplied, the\nglobal default timeout setting returned by {func}`socket.getdefaulttimeout`\nis used. If *source_address* is set it must be a tuple of (host, port)\nfor the socket to bind as a source address before making the connection.\nAn host of '' or port 0 tells the OS to use the default.\n", "This function is copied from socket.py in the Python 2.7 standard", "library test suite. Added to its signature is only `socket_options`.", "One additional modification is that we avoid binding to IPv6 servers", "discovered in DNS if the system doesn't have IPv6 functionality."]}, {"name": "urllib3.util.connection._set_socket_options", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.connection.allowed_gai_family", "asynchronous": false, "params": [], "returns": {"name": "socket.AddressFamily", "xref": {"fqname": "socket.AddressFamily", "project": "--std--"}, "params": null}, "documentation": ["This function is designed to work in the context of\ngetaddrinfo, where family=socket.AF_UNSPEC is the default and\nwill perform a DNS search for both IPv6 and IPv4 records."]}, {"name": "urllib3.util.connection._has_ipv6", "asynchronous": false, "params": [{"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Returns True if the system can bind an IPv6 address."]}], "variables": [{"name": "urllib3.util.connection._TYPE_SOCKET_OPTIONS", "type": null, "documentation": []}, {"name": "urllib3.util.connection.HAS_IPV6", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "urllib3.util.proxy", "documentation": [], "functions": [{"name": "urllib3.util.proxy.connection_requires_http_tunnel", "asynchronous": false, "params": [{"name": "proxy_url", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}, {"name": "destination_scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Returns True if the connection requires an HTTP CONNECT through the proxy.\n\n:param URL proxy_url:\n    URL of the proxy.\n:param ProxyConfig proxy_config:\n    Proxy configuration from poolmanager.py\n:param str destination_scheme:\n    The scheme of the destination. (i.e https, http, etc)"]}], "variables": [], "classes": [], "exports": []}, {"name": "urllib3.connection", "documentation": [], "functions": [{"name": "urllib3.connection._ssl_wrap_socket_and_match_hostname", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "cert_reqs", "type": {"name": "None | str | int", "xref": null, "params": null}, "default": null}, {"name": "ssl_version", "type": {"name": "None | str | int", "xref": null, "params": null}, "default": null}, {"name": "ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": null}, {"name": "ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": null}, {"name": "cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "key_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": null}, {"name": "assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "default": null}, {"name": "assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "default": null}, {"name": "tls_in_tls", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "_WrappedAndVerifiedSocket", "xref": {"fqname": "urllib3.connection._WrappedAndVerifiedSocket", "project": null}, "params": null}, "documentation": ["Logic for constructing an SSLContext from all TLS parameters, passing\nthat down into ssl_wrap_socket, and then doing certificate verification\neither via hostname or fingerprint. This function exists to guarantee\nthat both proxies and targets have the same behavior when connecting via TLS."]}, {"name": "urllib3.connection._match_hostname", "asynchronous": false, "params": [{"name": "cert", "type": {"name": "_TYPE_PEER_CERT_RET_DICT | None", "xref": null, "params": null}, "default": null}, {"name": "asserted_hostname", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "hostname_checks_common_name", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection._wrap_proxy_error", "asynchronous": false, "params": [{"name": "err", "type": {"name": "Exception", "xref": {"fqname": "functions.Exception", "project": "--std--"}, "params": null}, "default": null}, {"name": "proxy_scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "ProxyError", "xref": {"fqname": "urllib3.connection.exceptions.ProxyError", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.connection._get_default_user_agent", "asynchronous": false, "params": [], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection._url_from_connection", "asynchronous": false, "params": [{"name": "conn", "type": {"name": "HTTPConnection | HTTPSConnection", "xref": null, "params": null}, "default": null}, {"name": "path", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Returns the URL from a given connection. This is mainly used for testing and logging."]}], "variables": [{"name": "urllib3.connection.BaseSSLError", "type": null, "documentation": []}, {"name": "urllib3.connection.ssl", "type": null, "documentation": ["type: ignore[assignment]"]}, {"name": "urllib3.connection.ConnectionError", "type": null, "documentation": []}, {"name": "urllib3.connection.BrokenPipeError", "type": null, "documentation": []}, {"name": "urllib3.connection.log", "type": null, "documentation": []}, {"name": "urllib3.connection.port_by_scheme", "type": null, "documentation": []}, {"name": "urllib3.connection.RECENT_DATE", "type": null, "documentation": []}, {"name": "urllib3.connection._CONTAINS_CONTROL_CHAR_RE", "type": null, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection", "type": null, "documentation": ["type: ignore[misc, assignment] # noqa: F811"]}, {"name": "urllib3.connection.VerifiedHTTPSConnection", "type": null, "documentation": []}], "classes": [{"name": "urllib3.connection.BaseSSLError", "bases": ["BaseException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.connection.HTTPConnection", "bases": ["_HTTPConnection"], "methods": [{"name": "urllib3.connection.HTTPConnection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "urllib3.connection.util.timeout._TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "socket_options", "type": {"name": "None | (\n        connection._TYPE_SOCKET_OPTIONS\n    )", "xref": null, "params": null}, "default": "..."}, {"name": "proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Getter method to remove any trailing dots that indicate the hostname is an FQDN.\n\nIn general, SSL certificates don't include the trailing dot indicating a\nfully-qualified domain name, and thus, they don't validate properly when\nchecked against a domain name that includes the dot. In addition, some\nservers may not expect to receive the trailing dot when provided.\n\nHowever, the hostname with trailing dot is critical to DNS resolution; doing a\nlookup with the trailing dot will properly only resolve the appropriate FQDN,\nwhereas a lookup without a trailing dot will search the system's search domain\nlist. Thus, it's important to keep the original host around for use only in\nthose cases where it's appropriate (i.e., when doing DNS lookup to establish the\nactual TCP connection across which we're going to send HTTP requests)."]}, {"name": "urllib3.connection.HTTPConnection.host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "value", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Setter for the `host` property.\n\nWe assume that only urllib3 uses the _dns_host attribute; httplib itself\nonly uses `host`, and it seems reasonable that other libraries follow suit."]}, {"name": "urllib3.connection.HTTPConnection._new_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "documentation": ["Establish a socket connection and set nodelay settings on it.\n\n```\nreturn\n\nNew socket connection.\n```\n"]}, {"name": "urllib3.connection.HTTPConnection.set_tunnel", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "scheme", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection._tunnel", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.connect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.is_closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.is_connected", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.has_connected_to_proxy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.proxy_is_forwarding", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Return True if a forwarding proxy is configured, else return False"]}, {"name": "urllib3.connection.HTTPConnection.proxy_is_tunneling", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Return True if a tunneling proxy is configured, else return False"]}, {"name": "urllib3.connection.HTTPConnection.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.putrequest", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "skip_host", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "skip_accept_encoding", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": [""]}, {"name": "urllib3.connection.HTTPConnection.putheader", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "header", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "*values", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": [""]}, {"name": "urllib3.connection.HTTPConnection.request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "chunked", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enforce_content_length", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["`request` method's signature intentionally violates LSP.", "urllib3's API is different from `http.client.HTTPConnection` and the subclassing is only incidental."]}, {"name": "urllib3.connection.HTTPConnection.request_chunked", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Alternative to the common request method, which sends the\nbody with chunked encoding and not as one block"]}, {"name": "urllib3.connection.HTTPConnection.getresponse", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "HTTPResponse", "xref": {"fqname": "urllib3.connection.response.HTTPResponse", "project": null}, "params": null}, "documentation": ["Get the response from the server.\n\nIf the HTTPConnection is in the correct state, returns an instance of HTTPResponse or of whatever object is returned by the response_class variable.\n\nIf a request has not been sent or if a previous response has not be handled, ResponseNotReady is raised. If the HTTP response indicates that the connection should be closed, then it will be closed before the response is returned. When the connection is closed, the underlying socket is closed."]}], "class_variables": [{"name": "urllib3.connection.HTTPConnection.default_port", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": ["type: ignore[misc]"]}, {"name": "urllib3.connection.HTTPConnection.default_socket_options", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "connection._TYPE_SOCKET_OPTIONS", "xref": {"fqname": "urllib3.connection.util.connection._TYPE_SOCKET_OPTIONS", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.is_verified", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.proxy_is_verified", "type": {"name": "bool | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection.socket_options", "type": {"name": "connection._TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection._has_connected_to_proxy", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection._response_options", "type": {"name": "_ResponseOptions | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection._tunnel_host", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection._tunnel_port", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPConnection._tunnel_scheme", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Based on {class}`http.client.HTTPConnection` but provides an extra constructor\nbackwards-compatibility layer between older and newer Pythons.\n\nAdditional keyword parameters are used to configure attributes of the connection.\nAccepted parameters include:\n\n- `source_address`: Set the source address for the current connection.\n\n- `socket_options`: Set specific options on the underlying socket. If not specified, then\n  defaults are loaded from `HTTPConnection.default_socket_options` which includes disabling\n  Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.\n\n  For example, if you wish to enable TCP Keep Alive in addition to the defaults,\n  you might pass:\n\n  ```python\n  HTTPConnection.default_socket_options + [\n      (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),\n  ]\n  ```\n\n  Or you may want to disable the defaults by passing an empty list (e.g., `[]`).\n"]}, {"name": "urllib3.connection.HTTPSConnection", "bases": ["HTTPConnection"], "methods": [{"name": "urllib3.connection.HTTPSConnection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "urllib3.connection.util.timeout._TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "socket_options", "type": {"name": "None | (\n        connection._TYPE_SOCKET_OPTIONS\n    )", "xref": null, "params": null}, "default": "..."}, {"name": "proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "default": "..."}, {"name": "assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.set_cert", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "default": "..."}, {"name": "assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["This method should only be called once, before the connection is used."]}, {"name": "urllib3.connection.HTTPSConnection.connect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection._connect_tls_proxy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "hostname", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "ssl.SSLSocket", "xref": {"fqname": "ssl.SSLSocket", "project": "--std--"}, "params": null}, "documentation": ["Establish a TLS connection to the proxy using the provided SSL context."]}], "class_variables": [{"name": "urllib3.connection.HTTPSConnection.default_port", "type": null, "documentation": ["type: ignore[misc]"]}, {"name": "urllib3.connection.HTTPSConnection.cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection.assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection.HTTPSConnection._connect_callback", "type": {"name": "typing.Callable[..., None] | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Many of the parameters to this constructor are passed to the underlying SSL\nsocket by means of {py:func}`urllib3.util.ssl_wrap_socket`.\n"]}, {"name": "urllib3.connection._WrappedAndVerifiedSocket", "bases": ["typing.NamedTuple"], "methods": [], "class_variables": [{"name": "urllib3.connection._WrappedAndVerifiedSocket.socket", "type": {"name": "ssl.SSLSocket | SSLTransport", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connection._WrappedAndVerifiedSocket.is_verified", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Wrapped socket and whether the connection is\nverified after the TLS handshake"]}, {"name": "urllib3.connection.DummyConnection", "bases": [], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Used to detect a failed ConnectionCls import."]}], "exports": []}, {"name": "urllib3.util.response", "documentation": [], "functions": [{"name": "urllib3.util.response.is_fp_closed", "asynchronous": false, "params": [{"name": "obj", "type": {"name": "object", "xref": {"fqname": "functions.object", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Checks whether a given file-like object is closed.\n\n```\nparam obj\n\nThe file-like object to check.\n```\n"]}, {"name": "urllib3.util.response.assert_header_parsing", "asynchronous": false, "params": [{"name": "headers", "type": {"name": "httplib.HTTPMessage", "xref": {"fqname": "http.client.HTTPMessage", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Asserts whether all headers have been successfully parsed.\nExtracts encountered errors from the result of parsing headers.\n\nOnly works on Python 3.\n\n```\nparam http.client.HTTPMessage headers\n\nHeaders to verify.\n\nraises urllib3.exceptions.HeaderParsingError\n\nIf parsing errors are found.\n```\n"]}, {"name": "urllib3.util.response.is_response_to_head", "asynchronous": false, "params": [{"name": "response", "type": {"name": "httplib.HTTPResponse", "xref": {"fqname": "http.client.HTTPResponse", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Checks whether the request of a response has been a HEAD-request.\n\n:param http.client.HTTPResponse response:\n    Response to check if the originating request\n    used 'HEAD' as a method."]}], "variables": [], "classes": [], "exports": []}, {"name": "urllib3.util.ssltransport", "documentation": [], "functions": [], "variables": [{"name": "urllib3.util.ssltransport._WriteBuffer", "type": null, "documentation": []}, {"name": "urllib3.util.ssltransport._ReturnValue", "type": null, "documentation": []}, {"name": "urllib3.util.ssltransport.SSL_BLOCKSIZE", "type": null, "documentation": []}], "classes": [{"name": "urllib3.util.ssltransport.SSLTransport", "bases": [], "methods": [{"name": "urllib3.util.ssltransport.SSLTransport._validate_ssl_context_for_tls_in_tls", "asynchronous": false, "params": [{"name": "ssl_context", "type": {"name": "ssl.SSLContext", "xref": {"fqname": "ssl.SSLContext", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Raises a ProxySchemeUnsupported if the provided ssl_context can't be used\nfor TLS in TLS.\n\nThe only requirement is that the ssl_context provides the 'wrap_bio'\nmethods."]}, {"name": "urllib3.util.ssltransport.SSLTransport.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "socket", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext", "xref": {"fqname": "ssl.SSLContext", "project": "--std--"}, "params": null}, "default": null}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "suppress_ragged_eofs", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Create an SSLTransport around socket using the provided ssl_context."]}, {"name": "urllib3.util.ssltransport.SSLTransport.__enter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.__exit__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*_", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.fileno", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.read", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "len", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "buffer", "type": {"name": "typing.Any | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "int | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.recv", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "buflen", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "flags", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "int | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.recv_into", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "buffer", "type": {"name": "_WriteBuffer", "xref": {"fqname": "_WriteBuffer", "project": null}, "params": null}, "default": null}, {"name": "nbytes", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "flags", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None | int | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.sendall", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "flags", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.send", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "flags", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.makefile", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "mode", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "buffering", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "encoding", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "errors", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "newline", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.BinaryIO | typing.TextIO | socket.SocketIO", "xref": null, "params": null}, "documentation": ["Python's httpclient uses makefile and buffered io when reading HTTP\nmessages and we need to support it.\n\nThis is unfortunately a copy and paste of socket.py makefile with small\nchanges to point to the socket directly."]}, {"name": "urllib3.util.ssltransport.SSLTransport.unwrap", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.getpeercert", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "binary_form", "type": {"name": "typing.Literal", "xref": {"fqname": "typing.Literal", "project": "--std--"}, "params": [{"name": "False", "xref": null, "params": null}]}, "default": "..."}], "returns": {"name": "_TYPE_PEER_CERT_RET_DICT | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.getpeercert", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "binary_form", "type": {"name": "typing.Literal", "xref": {"fqname": "typing.Literal", "project": "--std--"}, "params": [{"name": "True", "xref": null, "params": null}]}, "default": null}], "returns": {"name": "bytes | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.getpeercert", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "binary_form", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "_TYPE_PEER_CERT_RET", "xref": {"fqname": "urllib3.util.ssltransport.ssl_._TYPE_PEER_CERT_RET", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.version", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.cipher", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "tuple[str, str, int] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.selected_alpn_protocol", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.shared_ciphers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "list[tuple[str, str, int]] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.compression", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.settimeout", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "value", "type": {"name": "float | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport.gettimeout", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport._decref_socketios", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport._wrap_ssl_read", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "len", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "buffer", "type": {"name": "bytearray | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "int | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssltransport.SSLTransport._ssl_io_loop", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "func", "type": {"name": "typing.Callable", "xref": {"fqname": "typing.Callable", "project": "--std--"}, "params": [{"name": "", "xref": null, "params": []}, {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["func is sslobj.do_handshake or sslobj.unwrap"]}, {"name": "urllib3.util.ssltransport.SSLTransport._ssl_io_loop", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "func", "type": {"name": "typing.Callable", "xref": {"fqname": "typing.Callable", "project": "--std--"}, "params": [{"name": "", "xref": null, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "arg1", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": ["func is sslobj.write, arg1 is data"]}, {"name": "urllib3.util.ssltransport.SSLTransport._ssl_io_loop", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "func", "type": {"name": "typing.Callable", "xref": {"fqname": "typing.Callable", "project": "--std--"}, "params": [{"name": "", "xref": null, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, {"name": "bytearray | None", "xref": null, "params": null}]}, {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "arg1", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "arg2", "type": {"name": "bytearray | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["func is sslobj.read, arg1 is len, arg2 is buffer"]}, {"name": "urllib3.util.ssltransport.SSLTransport._ssl_io_loop", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "func", "type": {"name": "typing.Callable", "xref": {"fqname": "typing.Callable", "project": "--std--"}, "params": [{"name": "...", "xref": null, "params": null}, {"name": "_ReturnValue", "xref": {"fqname": "_ReturnValue", "project": null}, "params": null}]}, "default": null}, {"name": "arg1", "type": {"name": "None | bytes | int", "xref": null, "params": null}, "default": "..."}, {"name": "arg2", "type": {"name": "bytearray | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "_ReturnValue", "xref": {"fqname": "_ReturnValue", "project": null}, "params": null}, "documentation": ["Performs an I/O loop between incoming/outgoing and the socket."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The SSLTransport wraps an existing socket and establishes an SSL connection.\n\nContrary to Python's implementation of SSLSocket, it allows you to chain\nmultiple TLS connections together. It's particularly useful if you need to\nimplement TLS within TLS.\n\nThe class supports most of the socket API operations."]}], "exports": []}, {"name": "urllib3.util", "documentation": ["For backwards compatibility, provide imports that used to be here."], "functions": [], "variables": [], "classes": [], "exports": [{"name": "urllib3.util.ALPN_PROTOCOLS", "xref": {"fqname": "urllib3.util.ssl_.ALPN_PROTOCOLS", "project": null}}, {"name": "urllib3.util.assert_fingerprint", "xref": {"fqname": "urllib3.util.ssl_.assert_fingerprint", "project": null}}, {"name": "urllib3.util.create_urllib3_context", "xref": {"fqname": "urllib3.util.ssl_.create_urllib3_context", "project": null}}, {"name": "urllib3.util.is_connection_dropped", "xref": {"fqname": "urllib3.util.connection.is_connection_dropped", "project": null}}, {"name": "urllib3.util.is_fp_closed", "xref": {"fqname": "urllib3.util.response.is_fp_closed", "project": null}}, {"name": "urllib3.util.IS_PYOPENSSL", "xref": {"fqname": "urllib3.util.ssl_.IS_PYOPENSSL", "project": null}}, {"name": "urllib3.util.make_headers", "xref": {"fqname": "urllib3.util.request.make_headers", "project": null}}, {"name": "urllib3.util.parse_url", "xref": {"fqname": "urllib3.util.url.parse_url", "project": null}}, {"name": "urllib3.util.resolve_cert_reqs", "xref": {"fqname": "urllib3.util.ssl_.resolve_cert_reqs", "project": null}}, {"name": "urllib3.util.resolve_ssl_version", "xref": {"fqname": "urllib3.util.ssl_.resolve_ssl_version", "project": null}}, {"name": "urllib3.util.Retry", "xref": {"fqname": "urllib3.util.retry.Retry", "project": null}}, {"name": "urllib3.util.SKIP_HEADER", "xref": {"fqname": "urllib3.util.request.SKIP_HEADER", "project": null}}, {"name": "urllib3.util.SKIPPABLE_HEADERS", "xref": {"fqname": "urllib3.util.request.SKIPPABLE_HEADERS", "project": null}}, {"name": "urllib3.util.ssl_wrap_socket", "xref": {"fqname": "urllib3.util.ssl_.ssl_wrap_socket", "project": null}}, {"name": "urllib3.util.SSLContext", "xref": {"fqname": "urllib3.util.ssl_.SSLContext", "project": null}}, {"name": "urllib3.util.Timeout", "xref": {"fqname": "urllib3.util.timeout.Timeout", "project": null}}, {"name": "urllib3.util.Url", "xref": {"fqname": "urllib3.util.url.Url", "project": null}}, {"name": "urllib3.util.wait_for_read", "xref": {"fqname": "urllib3.util.wait.wait_for_read", "project": null}}, {"name": "urllib3.util.wait_for_write", "xref": {"fqname": "urllib3.util.wait.wait_for_write", "project": null}}]}, {"name": "urllib3.util.util", "documentation": [], "functions": [{"name": "urllib3.util.util.to_bytes", "asynchronous": false, "params": [{"name": "x", "type": {"name": "str | bytes", "xref": null, "params": null}, "default": null}, {"name": "encoding", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "errors", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.util.to_str", "asynchronous": false, "params": [{"name": "x", "type": {"name": "str | bytes", "xref": null, "params": null}, "default": null}, {"name": "encoding", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "errors", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.util.reraise", "asynchronous": false, "params": [{"name": "tp", "type": {"name": "type[BaseException] | None", "xref": null, "params": null}, "default": null}, {"name": "value", "type": {"name": "BaseException", "xref": {"fqname": "functions.BaseException", "project": "--std--"}, "params": null}, "default": null}, {"name": "tb", "type": {"name": "TracebackType | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.NoReturn", "xref": {"fqname": "typing.NoReturn", "project": "--std--"}, "params": null}, "documentation": []}], "variables": [], "classes": [], "exports": []}, {"name": "urllib3.util.ssl_", "documentation": [], "functions": [{"name": "urllib3.util.ssl_._is_bpo_43522_fixed", "asynchronous": false, "params": [{"name": "implementation_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "version_info", "type": {"name": "_TYPE_VERSION_INFO", "xref": {"fqname": "_TYPE_VERSION_INFO", "project": null}, "params": null}, "default": null}, {"name": "pypy_version_info", "type": {"name": "_TYPE_VERSION_INFO | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Return True for CPython 3.9.3+ or 3.10+ and PyPy 7.3.8+ where\nsetting SSLContext.hostname_checks_common_name to False works.\n\nOutside of CPython and PyPy we don't know which implementations work\nor not so we conservatively use our hostname matching as we know that works\non all implementations.\n\nhttps://github.com/urllib3/urllib3/issues/2192#issuecomment-821832963\nhttps://foss.heptapod.net/pypy/pypy/-/issues/3539"]}, {"name": "urllib3.util.ssl_._is_has_never_check_common_name_reliable", "asynchronous": false, "params": [{"name": "openssl_version", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "openssl_version_number", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "implementation_name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "version_info", "type": {"name": "_TYPE_VERSION_INFO", "xref": {"fqname": "_TYPE_VERSION_INFO", "project": null}, "params": null}, "default": null}, {"name": "pypy_version_info", "type": {"name": "_TYPE_VERSION_INFO | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssl_.assert_fingerprint", "asynchronous": false, "params": [{"name": "cert", "type": {"name": "bytes | None", "xref": null, "params": null}, "default": null}, {"name": "fingerprint", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Checks if given fingerprint matches the supplied certificate.\n\n```\nparam cert\n\nCertificate as bytes object.\n\nparam fingerprint\n\nFingerprint as string of hexdigits, can be interspersed by colons.\n```\n"]}, {"name": "urllib3.util.ssl_.resolve_cert_reqs", "asynchronous": false, "params": [{"name": "candidate", "type": {"name": "None | int | str", "xref": null, "params": null}, "default": null}], "returns": {"name": "VerifyMode", "xref": {"fqname": "ssl.VerifyMode", "project": "--std--"}, "params": null}, "documentation": ["Resolves the argument to a numeric constant, which can be passed to\nthe wrap_socket function/method from the ssl module.\nDefaults to {data}`ssl.CERT_REQUIRED`.\nIf given a string it is assumed to be the name of the constant in the\n{mod}`ssl` module or its abbreviation.\n(So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\nIf it's neither `None` nor a string we assume it is already the numeric\nconstant which can directly be passed to wrap_socket.\n"]}, {"name": "urllib3.util.ssl_.resolve_ssl_version", "asynchronous": false, "params": [{"name": "candidate", "type": {"name": "None | int | str", "xref": null, "params": null}, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": ["like resolve_cert_reqs"]}, {"name": "urllib3.util.ssl_.create_urllib3_context", "asynchronous": false, "params": [{"name": "ssl_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "options", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ciphers", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "ssl.SSLContext", "xref": {"fqname": "ssl.SSLContext", "project": "--std--"}, "params": null}, "documentation": ["Creates and configures an {class}`ssl.SSLContext` instance for use with urllib3.\n\n```\nparam ssl_version\n\nThe desired protocol version to use. This will default to\nPROTOCOL_SSLv23 which will negotiate the highest protocol that both\nthe server and your installation of OpenSSL support.\n\nThis parameter is deprecated instead use 'ssl_minimum_version'.\n\nparam ssl_minimum_version\n\nThe minimum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value.\n\nparam ssl_maximum_version\n\nThe maximum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value.\nNot recommended to set to anything other than 'ssl.TLSVersion.MAXIMUM_SUPPORTED' which is the\ndefault value.\n\nparam cert_reqs\n\nWhether to require the certificate verification. This defaults to\nssl.CERT_REQUIRED.\n\nparam options\n\nSpecific OpenSSL options. These default to ssl.OP_NO_SSLv2,\nssl.OP_NO_SSLv3, ssl.OP_NO_COMPRESSION, and ssl.OP_NO_TICKET.\n\nparam ciphers\n\nWhich cipher suites to allow the server to select. Defaults to either system configured\nciphers if OpenSSL 1.1.1+, otherwise uses a secure default set of ciphers.\n\nreturns\n\nConstructed SSLContext object with specified options\n\nrtype\n\nSSLContext\n```\n"]}, {"name": "urllib3.util.ssl_.ssl_wrap_socket", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "keyfile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "certfile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ciphers", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}, {"name": "tls_in_tls", "type": {"name": "typing.Literal", "xref": {"fqname": "typing.Literal", "project": "--std--"}, "params": [{"name": "False", "xref": null, "params": null}]}, "default": "..."}], "returns": {"name": "ssl.SSLSocket", "xref": {"fqname": "ssl.SSLSocket", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.ssl_.ssl_wrap_socket", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "keyfile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "certfile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ciphers", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}, {"name": "tls_in_tls", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "ssl.SSLSocket | SSLTransportType", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.ssl_.ssl_wrap_socket", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "keyfile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "certfile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ciphers", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}, {"name": "tls_in_tls", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "ssl.SSLSocket | SSLTransportType", "xref": null, "params": null}, "documentation": ["All arguments except for server_hostname, ssl_context, tls_in_tls, ca_cert_data and\nca_cert_dir have the same meaning as they do when using\n{func}`ssl.create_default_context`, {meth}`ssl.SSLContext.load_cert_chain`,\n{meth}`ssl.SSLContext.set_ciphers` and {meth}`ssl.SSLContext.wrap_socket`.\n\n```\nparam server_hostname\n\nWhen SNI is supported, the expected hostname of the certificate\n\nparam ssl_context\n\nA pre-made  object. If none is provided, one will\nbe created using .\n\nparam ciphers\n\nA string of ciphers we wish the client to support.\n\nparam ca_cert_dir\n\nA directory containing CA certificates in multiple separate files, as\nsupported by OpenSSL's -CApath flag or the capath argument to\nSSLContext.load_verify_locations().\n\nparam key_password\n\nOptional password if the keyfile is encrypted.\n\nparam ca_cert_data\n\nOptional string containing CA certificates in PEM format suitable for\npassing as the cadata parameter to SSLContext.load_verify_locations()\n\nparam tls_in_tls\n\nUse SSLTransport to wrap the existing socket.\n```\n"]}, {"name": "urllib3.util.ssl_.is_ipaddress", "asynchronous": false, "params": [{"name": "hostname", "type": {"name": "str | bytes", "xref": null, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Detects whether the hostname given is an IPv4 or IPv6 address.\nAlso detects IPv6 addresses with Zone IDs.\n\n```\nparam str hostname\n\nHostname to examine.\n\nreturn\n\nTrue if the hostname is an IP address, False otherwise.\n```\n"]}, {"name": "urllib3.util.ssl_._is_key_file_encrypted", "asynchronous": false, "params": [{"name": "key_file", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Detects if a key file is encrypted or not."]}, {"name": "urllib3.util.ssl_._ssl_wrap_socket_impl", "asynchronous": false, "params": [{"name": "sock", "type": {"name": "socket.socket", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "ssl_context", "type": {"name": "ssl.SSLContext", "xref": {"fqname": "ssl.SSLContext", "project": "--std--"}, "params": null}, "default": null}, {"name": "tls_in_tls", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "ssl.SSLSocket | SSLTransportType", "xref": null, "params": null}, "documentation": []}], "variables": [{"name": "urllib3.util.ssl_.SSLContext", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_.SSLTransport", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_.HAS_NEVER_CHECK_COMMON_NAME", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_.IS_PYOPENSSL", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_.ALPN_PROTOCOLS", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_._TYPE_VERSION_INFO", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_.HASHFUNC_MAP", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_._SSL_VERSION_TO_TLS_VERSION", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.util.ssl_.PROTOCOL_SSLv23", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_.HAS_NEVER_CHECK_COMMON_NAME", "type": null, "documentation": []}, {"name": "urllib3.util.ssl_.OP_NO_COMPRESSION", "type": null, "documentation": ["type: ignore[assignment]"]}, {"name": "urllib3.util.ssl_.OP_NO_TICKET", "type": null, "documentation": ["type: ignore[assignment]"]}, {"name": "urllib3.util.ssl_.OP_NO_SSLv2", "type": null, "documentation": ["type: ignore[assignment]"]}, {"name": "urllib3.util.ssl_.OP_NO_SSLv3", "type": null, "documentation": ["type: ignore[assignment]"]}, {"name": "urllib3.util.ssl_.PROTOCOL_TLS_CLIENT", "type": null, "documentation": ["type: ignore[assignment]"]}, {"name": "urllib3.util.ssl_._TYPE_PEER_CERT_RET", "type": null, "documentation": []}], "classes": [{"name": "urllib3.util.ssl_._TYPE_PEER_CERT_RET_DICT", "bases": ["TypedDict"], "methods": [], "class_variables": [{"name": "urllib3.util.ssl_._TYPE_PEER_CERT_RET_DICT.subjectAltName", "type": {"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, {"name": "...", "xref": null, "params": null}]}, "documentation": []}, {"name": "urllib3.util.ssl_._TYPE_PEER_CERT_RET_DICT.subject", "type": {"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, {"name": "...", "xref": null, "params": null}]}, {"name": "...", "xref": null, "params": null}]}, "documentation": []}, {"name": "urllib3.util.ssl_._TYPE_PEER_CERT_RET_DICT.serialNumber", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.util.retry", "documentation": [], "functions": [], "variables": [{"name": "urllib3.util.retry.log", "type": null, "documentation": []}, {"name": "urllib3.util.retry.Retry.DEFAULT", "type": null, "documentation": []}], "classes": [{"name": "urllib3.util.retry.RequestHistory", "bases": ["typing.NamedTuple"], "methods": [], "class_variables": [{"name": "urllib3.util.retry.RequestHistory.method", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.RequestHistory.url", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.RequestHistory.error", "type": {"name": "Exception | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.RequestHistory.status", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.RequestHistory.redirect_location", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Data structure for representing the metadata of requests that result in a retry."]}, {"name": "urllib3.util.retry.Retry", "bases": [], "methods": [{"name": "urllib3.util.retry.Retry.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "total", "type": {"name": "bool | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "connect", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "read", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "redirect", "type": {"name": "bool | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "status", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "other", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "allowed_methods", "type": {"name": "typing.Collection[str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "status_forcelist", "type": {"name": "typing.Collection[int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "backoff_factor", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "backoff_max", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "raise_on_redirect", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "raise_on_status", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "history", "type": {"name": "tuple[RequestHistory, ...] | None", "xref": null, "params": null}, "default": "..."}, {"name": "respect_retry_after_header", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "remove_headers_on_redirect", "type": {"name": "typing.Collection", "xref": {"fqname": "typing.Collection", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": "..."}, {"name": "backoff_jitter", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.Retry.new", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "**kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.Retry.from_int", "asynchronous": false, "params": [{"name": "cls", "type": null, "default": null}, {"name": "retries", "type": {"name": "Retry | bool | int | None", "xref": null, "params": null}, "default": null}, {"name": "redirect", "type": {"name": "bool | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "default", "type": {"name": "Retry | bool | int | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "Retry", "xref": {"fqname": "urllib3.util.retry.Retry", "project": null}, "params": null}, "documentation": ["Backwards-compatibility for the old retries format."]}, {"name": "urllib3.util.retry.Retry.get_backoff_time", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": ["Formula for computing the current backoff\n\n```\nrtype\n\nfloat\n```\n"]}, {"name": "urllib3.util.retry.Retry.parse_retry_after", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "retry_after", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.Retry.get_retry_after", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "response", "type": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.util.response.BaseHTTPResponse", "project": null}, "params": null}, "default": null}], "returns": {"name": "float | None", "xref": null, "params": null}, "documentation": ["Get the value of Retry-After in seconds."]}, {"name": "urllib3.util.retry.Retry.sleep_for_retry", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "response", "type": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.util.response.BaseHTTPResponse", "project": null}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.Retry._sleep_backoff", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.retry.Retry.sleep", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "response", "type": {"name": "BaseHTTPResponse | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Sleep between retry attempts.\n\nThis method will respect a server's `Retry-After` response header\nand sleep the duration of the time requested. If that is not present, it\nwill use an exponential backoff. By default, the backoff factor is 0 and\nthis method will return immediately.\n"]}, {"name": "urllib3.util.retry.Retry._is_connection_error", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "err", "type": {"name": "Exception", "xref": {"fqname": "functions.Exception", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Errors when we're fairly sure that the server did not receive the\nrequest, so it should be safe to retry."]}, {"name": "urllib3.util.retry.Retry._is_read_error", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "err", "type": {"name": "Exception", "xref": {"fqname": "functions.Exception", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Errors that occur after the request has been started, so we should\nassume that the server began processing it."]}, {"name": "urllib3.util.retry.Retry._is_method_retryable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Checks if a given HTTP method should be retried upon, depending if\nit is included in the allowed_methods"]}, {"name": "urllib3.util.retry.Retry.is_retry", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "status_code", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "has_retry_after", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Is this method/status code retryable? (Based on allowlists and control\nvariables such as the number of total retries to allow, whether to\nrespect the Retry-After header, whether this header is present, and\nwhether the returned status code is on the list of status codes to\nbe retried upon on the presence of the aforementioned header)"]}, {"name": "urllib3.util.retry.Retry.is_exhausted", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Are we out of retries?"]}, {"name": "urllib3.util.retry.Retry.increment", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "url", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "response", "type": {"name": "BaseHTTPResponse | None", "xref": null, "params": null}, "default": "..."}, {"name": "error", "type": {"name": "Exception | None", "xref": null, "params": null}, "default": "..."}, {"name": "_pool", "type": {"name": "ConnectionPool | None", "xref": null, "params": null}, "default": "..."}, {"name": "_stacktrace", "type": {"name": "TracebackType | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": ["Return a new Retry object with incremented retry counters.\n\n```\nparam response\n\nA response object, or None, if the server did not\nreturn a response.\n\ntype response\n\n\n\nparam Exception error\n\nAn error encountered during the request, or\nNone if the response was received successfully.\n\nreturn\n\nA new Retry object.\n```\n"]}, {"name": "urllib3.util.retry.Retry.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3.util.retry.Retry.DEFAULT_ALLOWED_METHODS", "type": null, "documentation": []}, {"name": "urllib3.util.retry.Retry.RETRY_AFTER_STATUS_CODES", "type": null, "documentation": []}, {"name": "urllib3.util.retry.Retry.DEFAULT_REMOVE_HEADERS_ON_REDIRECT", "type": null, "documentation": []}, {"name": "urllib3.util.retry.Retry.DEFAULT_BACKOFF_MAX", "type": null, "documentation": []}, {"name": "urllib3.util.retry.Retry.DEFAULT", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "Retry", "xref": {"fqname": "urllib3.util.retry.Retry", "project": null}, "params": null}]}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Retry configuration.\n\nEach retry attempt will create a new Retry object with updated values, so\nthey can be safely reused.\n\nRetries can be defined as a default for a pool:\n\n```python\nretries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request(\"GET\", \"https://example.com/\")\n```\n\nOr per-request (which overrides the default for the pool):\n\n```python\nresponse = http.request(\"GET\", \"https://example.com/\", retries=Retry(10))\n```\n\nRetries can be disabled by passing `False`:\n\n```python\nresponse = http.request(\"GET\", \"https://example.com/\", retries=False)\n```\n\nErrors will be wrapped in {class}`~urllib3.exceptions.MaxRetryError` unless\nretries are disabled, in which case the causing exception will be raised.\n\n```\nparam int total\n\nTotal number of retries to allow. Takes precedence over other counts.\n\nSet to None to remove this constraint and fall back on other\ncounts.\n\nSet to 0 to fail on the first retry.\n\nSet to False to disable and imply raise_on_redirect=False.\n\nparam int connect\n\nHow many connection-related errors to retry on.\n\nThese are errors raised before the request is sent to the remote server,\nwhich we assume has not triggered the server to process the request.\n\nSet to 0 to fail on the first retry of this type.\n\nparam int read\n\nHow many times to retry on read errors.\n\nThese errors are raised after the request was sent to the server, so the\nrequest may have side-effects.\n\nSet to 0 to fail on the first retry of this type.\n\nparam int redirect\n\nHow many redirects to perform. Limit this to avoid infinite redirect\nloops.\n\nA redirect is a HTTP response with a status code 301, 302, 303, 307 or\n308.\n\nSet to 0 to fail on the first retry of this type.\n\nSet to False to disable and imply raise_on_redirect=False.\n\nparam int status\n\nHow many times to retry on bad status codes.\n\nThese are retries made on responses, where status code matches\nstatus_forcelist.\n\nSet to 0 to fail on the first retry of this type.\n\nparam int other\n\nHow many times to retry on other errors.\n\nOther errors are errors that are not connect, read, redirect or status errors.\nThese errors might be raised after the request was sent to the server, so the\nrequest might have side-effects.\n\nSet to 0 to fail on the first retry of this type.\n\nIf total is not set, it's a good idea to set this to 0 to account\nfor unexpected edge cases and avoid infinite retry loops.\n\nparam Collection allowed_methods\n\nSet of uppercased HTTP method verbs that we should retry on.\n\nBy default, we only retry on methods which are considered to be\nidempotent (multiple requests with the same parameters end with the\nsame state). See .\n\nSet to a None value to retry on any verb.\n\nparam Collection status_forcelist\n\nA set of integer HTTP status codes that we should force a retry on.\nA retry is initiated if the request method is in allowed_methods\nand the response status code is in status_forcelist.\n\nBy default, this is disabled with None.\n\nparam float backoff_factor\n\nA backoff factor to apply between attempts after the second try\n(most errors are resolved immediately by a second try without a\ndelay). urllib3 will sleep for:\n\n{backoff factor} * (2 ** ({number of previous retries}))\n\nseconds. If  is non-zero, this sleep is extended by:\n\nrandom.uniform(0, {backoff jitter})\n\nseconds. For example, if the backoff_factor is 0.1, then  will\nsleep for [0.0s, 0.2s, 0.4s, 0.8s, ...] between retries. No backoff will ever\nbe longer than .\n\nBy default, backoff is disabled (factor set to 0).\n\nparam bool raise_on_redirect\n\nWhether, if the number of redirects is\nexhausted, to raise a MaxRetryError, or to return a response with a\nresponse code in the 3xx range.\n\nparam bool raise_on_status\n\nSimilar meaning to raise_on_redirect:\nwhether we should raise an exception, or return a response,\nif status falls in status_forcelist range and retries have\nbeen exhausted.\n\nparam tuple history\n\nThe history of the request encountered during\neach call to . The list is in the order\nthe requests occurred. Each list item is of class .\n\nparam bool respect_retry_after_header\n\nWhether to respect Retry-After header on status codes defined as\n or not.\n\nparam Collection remove_headers_on_redirect\n\nSequence of headers to remove from the request when a response\nindicating a redirect is returned before firing off the redirected\nrequest.\n```\n"]}], "exports": []}, {"name": "urllib3.util.request", "documentation": [], "functions": [{"name": "urllib3.util.request.make_headers", "asynchronous": false, "params": [{"name": "keep_alive", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "accept_encoding", "type": {"name": "bool | list[str] | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "user_agent", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "basic_auth", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_basic_auth", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "disable_cache", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Shortcuts for generating request headers.\n\n```\nparam keep_alive\n\nIf True, adds 'connection: keep-alive' header.\n\nparam accept_encoding\n\nCan be a boolean, list, or string.\nTrue translates to 'gzip,deflate'.  If the dependencies for\nBrotli (either the brotli or brotlicffi package) and/or Zstandard\n(the zstandard package) algorithms are installed, then their encodings are\nincluded in the string ('br' and 'zstd', respectively).\nList will get joined by comma.\nString will be used as provided.\n\nparam user_agent\n\nString representing the user-agent you want, such as\n\"python-urllib3/0.6\"\n\nparam basic_auth\n\nColon-separated username:password string for 'authorization: basic ...'\nauth header.\n\nparam proxy_basic_auth\n\nColon-separated username:password string for 'proxy-authorization: basic ...'\nauth header.\n\nparam disable_cache\n\nIf True, adds 'cache-control: no-cache' header.\n```\n\nExample:\n\n```python\nimport urllib3\n\nprint(urllib3.util.make_headers(keep_alive=True, user_agent=\"Batman/1.0\"))\n# {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\nprint(urllib3.util.make_headers(accept_encoding=True))\n# {'accept-encoding': 'gzip,deflate'}\n```\n"]}, {"name": "urllib3.util.request.set_file_position", "asynchronous": false, "params": [{"name": "body", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "pos", "type": {"name": "_TYPE_BODY_POSITION | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "_TYPE_BODY_POSITION | None", "xref": null, "params": null}, "documentation": ["If a position is provided, move file to that point.\nOtherwise, we'll attempt to record a position for future use."]}, {"name": "urllib3.util.request.rewind_body", "asynchronous": false, "params": [{"name": "body", "type": {"name": "typing.IO", "xref": {"fqname": "typing.IO", "project": "--std--"}, "params": [{"name": "typing.AnyStr", "xref": {"fqname": "typing.AnyStr", "project": "--std--"}, "params": null}]}, "default": null}, {"name": "body_pos", "type": {"name": "_TYPE_BODY_POSITION", "xref": {"fqname": "_TYPE_BODY_POSITION", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Attempt to rewind body to a certain position.\nPrimarily used for request redirects and retries.\n\n```\nparam body\n\nFile-like object that supports seek.\n\nparam int pos\n\nPosition to seek to in file.\n```\n"]}, {"name": "urllib3.util.request.body_to_chunks", "asynchronous": false, "params": [{"name": "body", "type": {"name": "typing.Any | None", "xref": null, "params": null}, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "ChunksAndContentLength", "xref": {"fqname": "urllib3.util.request.ChunksAndContentLength", "project": null}, "params": null}, "documentation": ["Takes the HTTP request method, body, and blocksize and\ntransforms them into an iterable of chunks to pass to\nsocket.sendall() and an optional 'Content-Length' header.\n\nA 'Content-Length' of 'None' indicates the length of the body\ncan't be determined so should use 'Transfer-Encoding: chunked'\nfor framing instead."]}], "variables": [{"name": "urllib3.util.request.SKIP_HEADER", "type": null, "documentation": []}, {"name": "urllib3.util.request.SKIPPABLE_HEADERS", "type": null, "documentation": []}, {"name": "urllib3.util.request.ACCEPT_ENCODING", "type": null, "documentation": []}, {"name": "urllib3.util.request._FAILEDTELL", "type": {"name": "Final", "xref": {"fqname": "typing.Final", "project": "--std--"}, "params": [{"name": "_TYPE_FAILEDTELL", "xref": {"fqname": "urllib3.util.request._TYPE_FAILEDTELL", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3.util.request._TYPE_BODY_POSITION", "type": null, "documentation": []}, {"name": "urllib3.util.request._METHODS_NOT_EXPECTING_BODY", "type": null, "documentation": []}], "classes": [{"name": "urllib3.util.request._TYPE_FAILEDTELL", "bases": ["Enum"], "methods": [], "class_variables": [{"name": "urllib3.util.request._TYPE_FAILEDTELL.token", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.util.request.ChunksAndContentLength", "bases": ["typing.NamedTuple"], "methods": [], "class_variables": [{"name": "urllib3.util.request.ChunksAndContentLength.chunks", "type": {"name": "typing.Iterable[bytes] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.request.ChunksAndContentLength.content_length", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.connectionpool", "documentation": [], "functions": [{"name": "urllib3.connectionpool.connection_from_url", "asynchronous": false, "params": [{"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "**kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "HTTPConnectionPool", "xref": {"fqname": "urllib3.connectionpool.HTTPConnectionPool", "project": null}, "params": null}, "documentation": ["Given a url, return an {class}`.ConnectionPool` instance of its host.\n\nThis is a shortcut for not having to parse out the scheme, host, and port\nof the url before creating an {class}`.ConnectionPool` instance.\n\n```\nparam url\n\nAbsolute URL string that must include the scheme. Port is optional.\n\nparam **kw\n\nPasses additional parameters to the constructor of the appropriate\n. Useful for specifying things like\ntimeout, maxsize, headers, etc.\n```\n\nExample:\n\n```\n>>> conn = connection_from_url('http://google.com/')\n>>> r = conn.request('GET', '/')\n```\n"]}, {"name": "urllib3.connectionpool._normalize_host", "asynchronous": false, "params": [{"name": "host", "type": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool._normalize_host", "asynchronous": false, "params": [{"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool._normalize_host", "asynchronous": false, "params": [{"name": "host", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Normalize hosts for comparisons and use with sockets."]}, {"name": "urllib3.connectionpool._url_from_pool", "asynchronous": false, "params": [{"name": "pool", "type": {"name": "HTTPConnectionPool | HTTPSConnectionPool", "xref": null, "params": null}, "default": null}, {"name": "path", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Returns the URL from a given connection pool. This is mainly used for testing and logging."]}, {"name": "urllib3.connectionpool._close_pool_connections", "asynchronous": false, "params": [{"name": "pool", "type": {"name": "queue.LifoQueue", "xref": {"fqname": "queue.LifoQueue", "project": "--std--"}, "params": [{"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Drains a queue of connections and closes each one."]}], "variables": [{"name": "urllib3.connectionpool.log", "type": null, "documentation": []}, {"name": "urllib3.connectionpool._TYPE_TIMEOUT", "type": null, "documentation": []}, {"name": "urllib3.connectionpool._blocking_errnos", "type": null, "documentation": []}], "classes": [{"name": "urllib3.connectionpool.ConnectionPool", "bases": [], "methods": [{"name": "urllib3.connectionpool.ConnectionPool.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool.ConnectionPool.__str__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool.ConnectionPool.__enter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool.ConnectionPool.__exit__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "exc_type", "type": {"name": "type[BaseException] | None", "xref": null, "params": null}, "default": null}, {"name": "exc_val", "type": {"name": "BaseException | None", "xref": null, "params": null}, "default": null}, {"name": "exc_tb", "type": {"name": "TracebackType | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "typing.Literal", "xref": {"fqname": "typing.Literal", "project": "--std--"}, "params": [{"name": "False", "xref": null, "params": null}]}, "documentation": []}, {"name": "urllib3.connectionpool.ConnectionPool.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Close all pooled connections and disable the pool."]}], "class_variables": [{"name": "urllib3.connectionpool.ConnectionPool.scheme", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool.ConnectionPool.QueueCls", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Base class for all connection pools, such as\n{class}`.HTTPConnectionPool` and {class}`.HTTPSConnectionPool`.\n\n:::{note}\nConnectionPool.urlopen() does not normalize or percent-encode target URIs\nwhich is useful if your target server doesn't support percent-encoded\ntarget URIs.\n:::\n", "Pool objects"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool", "bases": ["ConnectionPool", "RequestMethods"], "methods": [{"name": "urllib3.connectionpool.HTTPConnectionPool.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT | None", "xref": null, "params": null}, "default": "..."}, {"name": "maxsize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "block", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "retries", "type": {"name": "Retry | bool | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "_proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "_proxy_headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "_proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}, {"name": "**conn_kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": null, "documentation": []}, {"name": "urllib3.connectionpool.HTTPConnectionPool._new_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "documentation": ["Return a fresh {class}`HTTPConnection`.\n"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool._get_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "timeout", "type": {"name": "float | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "documentation": ["Get a connection. Will return a pooled connection if one is available.\n\nIf no connections are available and {prop}`.block` is `False`, then a\nfresh connection is returned.\n\n```\nparam timeout\n\nSeconds to wait before giving up and raising\n if the pool is empty and\n is True.\n```\n"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool._put_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": {"name": "BaseHTTPConnection | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Put a connection back into the pool.\n\n```\nparam conn\n\nConnection object for the current host and port as returned by\n or .\n```\n\nIf the pool is already full, the connection is closed and discarded\nbecause we exceeded maxsize. If connections are discarded frequently,\nthen maxsize should be increased.\n\nIf the pool is closed, then the connection will be closed and discarded.\n"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool._validate_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Called right before a request is made, after the socket is created."]}, {"name": "urllib3.connectionpool.HTTPConnectionPool._prepare_proxy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool.HTTPConnectionPool._get_timeout", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": null}], "returns": {"name": "Timeout", "xref": {"fqname": "urllib3.connectionpool.util.timeout.Timeout", "project": null}, "params": null}, "documentation": ["Helper that always returns a {class}`urllib3.util.Timeout`\n"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool._raise_timeout", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "err", "type": {"name": "BaseSSLError | OSError | SocketTimeout", "xref": null, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "timeout_value", "type": {"name": "_TYPE_TIMEOUT | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Is the error actually a timeout? Will raise a ReadTimeout or pass"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool._make_request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "retries", "type": {"name": "Retry | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "chunked", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "response_conn", "type": {"name": "BaseHTTPConnection | None", "xref": null, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enforce_content_length", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.connectionpool.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": ["Perform a request on a given urllib connection object taken from our\npool.\n\n```\nparam conn\n\na connection from one of our connection pools\n\nparam method\n\nHTTP request method (such as GET, POST, PUT, etc.)\n\nparam url\n\nThe URL to perform the request on.\n\nparam body\n\nData to send in the request body, either , ,\nan iterable of /, or a file-like object.\n\nparam headers\n\nDictionary of custom headers to send, such as User-Agent,\nIf-None-Match, etc. If None, pool headers are used. If provided,\nthese headers completely replace any pool-specific headers.\n\nparam retries\n\nConfigure the number of retries to allow before raising a\n exception.\n\nPass None to retry until you receive a response. Pass a\n object for fine-grained control\nover different types of retries.\nPass an integer number to retry connection errors that many times,\nbut no other types of errors. Pass zero to never retry.\n\nIf False, then retries are disabled and any exception is raised\nimmediately. Also, instead of raising a MaxRetryError on redirects,\nthe redirect response will be returned.\n\ntype retries\n\n, False, or an int.\n\nparam timeout\n\nIf specified, overrides the default timeout for this one\nrequest. It may be a float (in seconds) or an instance of\n.\n\nparam chunked\n\nIf True, urllib3 will send the body using chunked transfer\nencoding. Otherwise, urllib3 will send the body using the standard\ncontent-length form. Defaults to False.\n\nparam response_conn\n\nSet this to None if you will handle releasing the connection or\nset the connection to have the response release it.\n\nparam preload_content\n\nIf True, the response's body will be preloaded during construction.\n\nparam decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n\nparam enforce_content_length\n\nEnforce content length checking. Body returned by server must match\nvalue of Content-Length header, if present. Otherwise, raise error.\n```\n"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Close all pooled connections and disable the pool."]}, {"name": "urllib3.connectionpool.HTTPConnectionPool.is_same_host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Check if the given `url` is a member of the same host as this\nconnection pool.\n"]}, {"name": "urllib3.connectionpool.HTTPConnectionPool.urlopen", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "retries", "type": {"name": "Retry | bool | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "redirect", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "assert_same_host", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "pool_timeout", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "release_conn", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "chunked", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "body_pos", "type": {"name": "_TYPE_BODY_POSITION | None", "xref": null, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "**response_kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.connectionpool.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": ["Get a connection from the pool and perform an HTTP request. This is the\nlowest level call for making a request, so you'll need to specify all\nthe raw details.\n\n:::{note}\nMore commonly, it's appropriate to use a convenience method\nsuch as {meth}`request`.\n:::\n\n:::{note}\n`release_conn` will only behave as expected if\n`preload_content=False` because we want to make\n`preload_content=False` the default behaviour someday soon without\nbreaking backwards compatibility.\n:::\n\n```\nparam method\n\nHTTP request method (such as GET, POST, PUT, etc.)\n\nparam url\n\nThe URL to perform the request on.\n\nparam body\n\nData to send in the request body, either , ,\nan iterable of /, or a file-like object.\n\nparam headers\n\nDictionary of custom headers to send, such as User-Agent,\nIf-None-Match, etc. If None, pool headers are used. If provided,\nthese headers completely replace any pool-specific headers.\n\nparam retries\n\nConfigure the number of retries to allow before raising a\n exception.\n\nIf None (default) will retry 3 times, see Retry.DEFAULT. Pass a\n object for fine-grained control\nover different types of retries.\nPass an integer number to retry connection errors that many times,\nbut no other types of errors. Pass zero to never retry.\n\nIf False, then retries are disabled and any exception is raised\nimmediately. Also, instead of raising a MaxRetryError on redirects,\nthe redirect response will be returned.\n\ntype retries\n\n, False, or an int.\n\nparam redirect\n\nIf True, automatically handle redirects (status codes 301, 302,\n303, 307, 308). Each redirect counts as a retry. Disabling retries\nwill disable redirect, too.\n\nparam assert_same_host\n\nIf True, will make sure that the host of the pool requests is\nconsistent else will raise HostChangedError. When False, you can\nuse the pool on an HTTP proxy and request foreign hosts.\n\nparam timeout\n\nIf specified, overrides the default timeout for this one\nrequest. It may be a float (in seconds) or an instance of\n.\n\nparam pool_timeout\n\nIf set and the pool is set to block=True, then this method will\nblock for pool_timeout seconds and raise EmptyPoolError if no\nconnection is available within the time period.\n\nparam bool preload_content\n\nIf True, the response's body will be preloaded into memory.\n\nparam bool decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n\nparam release_conn\n\nIf False, then the urlopen call will not release the connection\nback into the pool once a response is received (but will release if\nyou read the entire contents of the response such as when\n). This is useful if you're not preloading\nthe response's content immediately. You will need to call\nr.release_conn() on the response r to return the connection\nback into the pool. If None, it takes the value of preload_content\nwhich defaults to True.\n\nparam bool chunked\n\nIf True, urllib3 will send the body using chunked transfer\nencoding. Otherwise, urllib3 will send the body using the standard\ncontent-length form. Defaults to False.\n\nparam int body_pos\n\nPosition to seek to in file-like body in the event of a retry or\nredirect. Typically this won't need to be set because urllib3 will\nauto-populate the value when needed.\n```\n"]}], "class_variables": [{"name": "urllib3.connectionpool.HTTPConnectionPool.scheme", "type": null, "documentation": []}, {"name": "urllib3.connectionpool.HTTPConnectionPool.ConnectionCls", "type": {"name": "type[BaseHTTPConnection] | type[BaseHTTPSConnection]", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Thread-safe connection pool for one host.\n\n```\nparam host\n\nHost used for this HTTP Connection (e.g. \"localhost\"), passed into\n.\n\nparam port\n\nPort used for this HTTP Connection (None is equivalent to 80), passed\ninto .\n\nparam timeout\n\nSocket timeout in seconds for each individual connection. This can\nbe a float or integer, which sets the timeout for the HTTP request,\nor an instance of  which gives you more\nfine-grained control over request timeouts. After the constructor has\nbeen parsed, this is always a  object.\n\nparam maxsize\n\nNumber of connections to save that can be reused. More than 1 is useful\nin multithreaded situations. If block is set to False, more\nconnections will be created but they will not be saved once they've\nbeen used.\n\nparam block\n\nIf set to True, no more than maxsize connections will be used at\na time. When no free connections are available, the call will block\nuntil a connection has been released. This is a useful side effect for\nparticular multithreaded situations where one does not want to use more\nthan maxsize connections per host to prevent flooding.\n\nparam headers\n\nHeaders to include with all requests, unless other headers are given\nexplicitly.\n\nparam retries\n\nRetry configuration to use by default with requests in this pool.\n\nparam _proxy\n\nParsed proxy URL, should not be used directly, instead, see\n\n\nparam _proxy_headers\n\nA dictionary with proxy headers, should not be used directly,\ninstead, see \n\nparam **conn_kw\n\nAdditional parameters are used to create fresh ,\n instances.\n```\n"]}, {"name": "urllib3.connectionpool.HTTPSConnectionPool", "bases": ["HTTPConnectionPool"], "methods": [{"name": "urllib3.connectionpool.HTTPSConnectionPool.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT | None", "xref": null, "params": null}, "default": "..."}, {"name": "maxsize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "block", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "retries", "type": {"name": "Retry | bool | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "_proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "_proxy_headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_minimum_version", "type": {"name": "ssl.TLSVersion | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_maximum_version", "type": {"name": "ssl.TLSVersion | None", "xref": null, "params": null}, "default": "..."}, {"name": "assert_hostname", "type": {"name": "str | typing.Literal[False] | None", "xref": null, "params": null}, "default": "..."}, {"name": "assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "**conn_kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.connectionpool.HTTPSConnectionPool._prepare_proxy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": {"name": "HTTPSConnection", "xref": {"fqname": "urllib3.connectionpool.connection.HTTPSConnection", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Establishes a tunnel connection through HTTP CONNECT."]}, {"name": "urllib3.connectionpool.HTTPSConnectionPool._new_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "BaseHTTPSConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPSConnection", "project": null}, "params": null}, "documentation": ["Return a fresh {class}`urllib3.connection.HTTPConnection`.\n"]}, {"name": "urllib3.connectionpool.HTTPSConnectionPool._validate_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Called right before a request is made, after the socket is created."]}], "class_variables": [{"name": "urllib3.connectionpool.HTTPSConnectionPool.scheme", "type": null, "documentation": []}, {"name": "urllib3.connectionpool.HTTPSConnectionPool.ConnectionCls", "type": {"name": "type", "xref": {"fqname": "functions.type", "project": "--std--"}, "params": [{"name": "BaseHTTPSConnection", "xref": {"fqname": "urllib3.connectionpool._base_connection.BaseHTTPSConnection", "project": null}, "params": null}]}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Same as {class}`.HTTPConnectionPool`, but HTTPS.\n\n{class}`.HTTPSConnection` uses one of `assert_fingerprint`,\n`assert_hostname` and `host` in this order to verify connections.\nIf `assert_hostname` is False, no verification is done.\n\nThe `key_file`, `cert_file`, `cert_reqs`, `ca_certs`,\n`ca_cert_dir`, `ssl_version`, `key_password` are only used if {mod}`ssl`\nis available and are fed into {meth}`urllib3.util.ssl_wrap_socket` to upgrade\nthe connection socket into an SSL socket.\n"]}], "exports": []}, {"name": "urllib3.util.ssl_match_hostname", "documentation": ["The match_hostname() function from Python 3.5, essential when using SSL."], "functions": [{"name": "urllib3.util.ssl_match_hostname._dnsname_match", "asynchronous": false, "params": [{"name": "dn", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "hostname", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "max_wildcards", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "typing.Match[str] | None | bool", "xref": null, "params": null}, "documentation": ["Matching according to RFC 6125, section 6.4.3\n\nhttp://tools.ietf.org/html/rfc6125#section-6.4.3"]}, {"name": "urllib3.util.ssl_match_hostname._ipaddress_match", "asynchronous": false, "params": [{"name": "ipname", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "host_ip", "type": {"name": "IPv4Address | IPv6Address", "xref": null, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Exact matching of IP addresses.\n\nRFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\nbytes of the IP address. An IP version 4 address is 4 octets, and an IP\nversion 6 address is 16 octets. [...] A reference identity of type IP-ID\nmatches if the address is identical to an iPAddress value of the\nsubjectAltName extension of the certificate.\""]}, {"name": "urllib3.util.ssl_match_hostname.match_hostname", "asynchronous": false, "params": [{"name": "cert", "type": {"name": "_TYPE_PEER_CERT_RET_DICT | None", "xref": null, "params": null}, "default": null}, {"name": "hostname", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "hostname_checks_common_name", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Verify that *cert* (in decoded format as returned by\nSSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\nrules are followed, but IP addresses are not accepted for *hostname*.\n\nCertificateError is raised on failure. On success, the function\nreturns nothing."]}], "variables": [{"name": "urllib3.util.ssl_match_hostname.__version__", "type": null, "documentation": []}], "classes": [{"name": "urllib3.util.ssl_match_hostname.CertificateError", "bases": ["ValueError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.util.url", "documentation": [], "functions": [{"name": "urllib3.util.url._encode_invalid_chars", "asynchronous": false, "params": [{"name": "component", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "allowed_chars", "type": {"name": "typing.Container", "xref": {"fqname": "typing.Container", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.url._encode_invalid_chars", "asynchronous": false, "params": [{"name": "component", "type": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "default": null}, {"name": "allowed_chars", "type": {"name": "typing.Container", "xref": {"fqname": "typing.Container", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.url._encode_invalid_chars", "asynchronous": false, "params": [{"name": "component", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "allowed_chars", "type": {"name": "typing.Container", "xref": {"fqname": "typing.Container", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Percent-encodes a URI component without reapplying\nonto an already percent-encoded component."]}, {"name": "urllib3.util.url._remove_path_dot_segments", "asynchronous": false, "params": [{"name": "path", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.url._normalize_host", "asynchronous": false, "params": [{"name": "host", "type": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.url._normalize_host", "asynchronous": false, "params": [{"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.url._normalize_host", "asynchronous": false, "params": [{"name": "host", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.url._idna_encode", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.url._encode_target", "asynchronous": false, "params": [{"name": "target", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Percent-encodes a request target so that there are no invalid characters\n\nPre-condition for this function is that 'target' must start with '/'.\nIf that is the case then _TARGET_RE will always produce a match."]}, {"name": "urllib3.util.url.parse_url", "asynchronous": false, "params": [{"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "Url", "xref": {"fqname": "urllib3.util.url.Url", "project": null}, "params": null}, "documentation": ["Given a url, return a parsed {class}`.Url` namedtuple. Best-effort is\nperformed to parse incomplete urls. Fields not provided will be None.\nThis parser is RFC 3986 and RFC 6874 compliant.\n\nThe parser logic and helper functions are based heavily on\nwork done in the `rfc3986` module.\n\n```\nparam str url\n\nURL to parse into a  namedtuple.\n```\n\nPartly backwards-compatible with {mod}`urllib.parse`.\n\nExample:\n\n```python\nimport urllib3\n\nprint( urllib3.util.parse_url('http://google.com/mail/'))\n# Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n\nprint( urllib3.util.parse_url('google.com:80'))\n# Url(scheme=None, host='google.com', port=80, path=None, ...)\n\nprint( urllib3.util.parse_url('/foo?bar'))\n# Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n```\n"]}], "variables": [{"name": "urllib3.util.url._NORMALIZABLE_SCHEMES", "type": null, "documentation": []}, {"name": "urllib3.util.url._PERCENT_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._SCHEME_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._URI_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._IPV4_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._HEX_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._LS32_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._subs", "type": null, "documentation": []}, {"name": "urllib3.util.url._variations", "type": null, "documentation": []}, {"name": "urllib3.util.url._UNRESERVED_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._IPV6_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._ZONE_ID_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._IPV6_ADDRZ_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._REG_NAME_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._TARGET_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._IPV4_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._IPV6_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._IPV6_ADDRZ_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._BRACELESS_IPV6_ADDRZ_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._ZONE_ID_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._HOST_PORT_PAT", "type": null, "documentation": []}, {"name": "urllib3.util.url._HOST_PORT_RE", "type": null, "documentation": []}, {"name": "urllib3.util.url._UNRESERVED_CHARS", "type": null, "documentation": []}, {"name": "urllib3.util.url._SUB_DELIM_CHARS", "type": null, "documentation": []}, {"name": "urllib3.util.url._USERINFO_CHARS", "type": null, "documentation": []}, {"name": "urllib3.util.url._PATH_CHARS", "type": null, "documentation": []}], "classes": [{"name": "urllib3.util.url.Url", "bases": [], "methods": [{"name": "urllib3.util.url.Url.__new__", "asynchronous": false, "params": [{"name": "cls", "type": null, "default": null}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "auth", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "host", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "path", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "query", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "fragment", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": null, "documentation": []}, {"name": "urllib3.util.url.Url.hostname", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["For backwards-compatibility with urlparse. We're nice like that."]}, {"name": "urllib3.util.url.Url.request_uri", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Absolute path including the query string."]}, {"name": "urllib3.util.url.Url.authority", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Authority component as defined in RFC 3986 3.2.\nThis includes userinfo (auth), host and port.\n\ni.e.\n    userinfo@host:port"]}, {"name": "urllib3.util.url.Url.netloc", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Network location including host and port.\n\nIf you need the equivalent of urllib.parse's `netloc`,\nuse the `authority` property instead.\n"]}, {"name": "urllib3.util.url.Url.url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Convert self into a url\n\nThis function should more or less round-trip with {func}`.parse_url`. The\nreturned url may not be exactly the same as the url inputted to\n{func}`.parse_url`, but it should be equivalent by the RFC (e.g., urls\nwith a blank port will have : removed).\n\nExample:\n\n```python\nimport urllib3\n\nU = urllib3.util.parse_url(\"https://google.com/mail/\")\n\nprint(U.url)\n# \"https://google.com/mail/\"\n\nprint( urllib3.util.Url(\"https\", \"username:password\",\n                        \"host.com\", 80, \"/path\", \"query\", \"fragment\"\n                        ).url\n    )\n# \"https://username:password@host.com:80/path?query#fragment\"\n```\n"]}, {"name": "urllib3.util.url.Url.__str__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Data structure for representing an HTTP URL. Used as a return value for\n{func}`parse_url`. Both the scheme and host are normalized as they are\nboth case-insensitive according to RFC 3986.\n"]}], "exports": []}, {"name": "urllib3.util.timeout", "documentation": [], "functions": [], "variables": [{"name": "urllib3.util.timeout._DEFAULT_TIMEOUT", "type": {"name": "Final", "xref": {"fqname": "typing.Final", "project": "--std--"}, "params": [{"name": "_TYPE_DEFAULT", "xref": {"fqname": "urllib3.util.timeout._TYPE_DEFAULT", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3.util.timeout._TYPE_TIMEOUT", "type": null, "documentation": []}], "classes": [{"name": "urllib3.util.timeout._TYPE_DEFAULT", "bases": ["Enum"], "methods": [], "class_variables": [{"name": "urllib3.util.timeout._TYPE_DEFAULT.token", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.util.timeout.Timeout", "bases": [], "methods": [{"name": "urllib3.util.timeout.Timeout.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "total", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "connect", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "read", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.timeout.Timeout.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.util.timeout.Timeout.resolve_default_timeout", "asynchronous": false, "params": [{"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": null}], "returns": {"name": "float | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.util.timeout.Timeout._validate_timeout", "asynchronous": false, "params": [{"name": "cls", "type": null, "default": null}, {"name": "value", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": null}, {"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "documentation": ["Check that a timeout attribute is valid.\n\n```\nparam value\n\nThe timeout value to validate\n\nparam name\n\nThe name of the timeout attribute to validate. This is\nused to specify in error messages.\n\nreturn\n\nThe validated and casted version of the given value.\n\nraises ValueError\n\nIf it is a numeric value less than or equal to\nzero, or the type is not an integer, float, or None.\n```\n"]}, {"name": "urllib3.util.timeout.Timeout.from_float", "asynchronous": false, "params": [{"name": "cls", "type": null, "default": null}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "default": null}], "returns": {"name": "Timeout", "xref": {"fqname": "urllib3.util.timeout.Timeout", "project": null}, "params": null}, "documentation": ["Create a new Timeout from a legacy timeout value.\n\nThe timeout value used by httplib.py sets the same timeout on the\nconnect(), and recv() socket requests. This creates a {class}`Timeout`\nobject that sets the individual timeouts to the `timeout` value\npassed to this function.\n\n```\nparam timeout\n\nThe legacy timeout value.\n\ntype timeout\n\ninteger, float, , or None\n\nreturn\n\nTimeout object\n\nrtype\n\n```\n"]}, {"name": "urllib3.util.timeout.Timeout.clone", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Timeout", "xref": {"fqname": "urllib3.util.timeout.Timeout", "project": null}, "params": null}, "documentation": ["Create a copy of the timeout object\n\nTimeout properties are stored per-pool but each request needs a fresh\nTimeout object to ensure each one has its own start/stop configured.\n\n```\nreturn\n\na copy of the timeout object\n\nrtype\n\n```\n"]}, {"name": "urllib3.util.timeout.Timeout.start_connect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": ["Start the timeout clock, used during a connect() attempt\n\n```\nraises urllib3.exceptions.TimeoutStateError\n\nif you attempt\nto start a timer that has been started already.\n```\n"]}, {"name": "urllib3.util.timeout.Timeout.get_connect_duration", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": ["Gets the time elapsed since the call to {meth}`start_connect`.\n\n```\nreturn\n\nElapsed time in seconds.\n\nrtype\n\nfloat\n\nraises urllib3.exceptions.TimeoutStateError\n\nif you attempt\nto get duration for a timer that hasn't been started.\n```\n"]}, {"name": "urllib3.util.timeout.Timeout.connect_timeout", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "documentation": ["Get the value to use when setting a connection timeout.\n\nThis will be a positive float or integer, the value None\n(never timeout), or the default system timeout.\n\n```\nreturn\n\nConnect timeout.\n\nrtype\n\nint, float,  or None\n```\n"]}, {"name": "urllib3.util.timeout.Timeout.read_timeout", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "float | None", "xref": null, "params": null}, "documentation": ["Get the value for the read timeout.\n\nThis assumes some time has elapsed in the connection timeout and\ncomputes the read timeout appropriately.\n\nIf self.total is set, the read timeout is dependent on the amount of\ntime taken by the connect timeout. If the connection time has not been\nestablished, a {exc}`~urllib3.exceptions.TimeoutStateError` will be\nraised.\n\n```\nreturn\n\nValue to use for the read timeout.\n\nrtype\n\nint, float or None\n\nraises urllib3.exceptions.TimeoutStateError\n\nIf \nhas not yet been called on this object.\n```\n"]}], "class_variables": [{"name": "urllib3.util.timeout.Timeout.DEFAULT_TIMEOUT", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "_TYPE_TIMEOUT", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.util.timeout.Timeout.__str__", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Timeout configuration.\n\nTimeouts can be defined as a default for a pool:\n\n```python\nimport urllib3\n\ntimeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n\nhttp = urllib3.PoolManager(timeout=timeout)\n\nresp = http.request(\"GET\", \"https://example.com/\")\n\nprint(resp.status)\n```\n\nOr per-request (which overrides the default for the pool):\n\n```python\nresponse = http.request(\"GET\", \"https://example.com/\", timeout=Timeout(10))\n```\n\nTimeouts can be disabled by setting all the parameters to `None`:\n\n```python\nno_timeout = Timeout(connect=None, read=None)\nresponse = http.request(\"GET\", \"https://example.com/\", timeout=no_timeout)\n```\n\n```\nparam total\n\nThis combines the connect and read timeouts into one; the read timeout\nwill be set to the time leftover from the connect attempt. In the\nevent that both a connect timeout and a total are specified, or a read\ntimeout and a total are specified, the shorter timeout will be applied.\n\nDefaults to None.\n\ntype total\n\nint, float, or None\n\nparam connect\n\nThe maximum amount of time (in seconds) to wait for a connection\nattempt to a server to succeed. Omitting the parameter will default the\nconnect timeout to the system default, probably the global default\ntimeout in socket.py.\nNone will set an infinite timeout for connection attempts.\n\ntype connect\n\nint, float, or None\n\nparam read\n\nThe maximum amount of time (in seconds) to wait between consecutive\nread operations for a response from the server. Omitting the parameter\nwill default the read timeout to the system default, probably the\nglobal default timeout in socket.py.\nNone will set an infinite timeout.\n\ntype read\n\nint, float, or None\n```\n\n:::{note}\nMany factors can affect the total amount of time for urllib3 to return\nan HTTP response.\n\nFor example, Python's DNS resolver does not obey the timeout specified\non the socket. Other factors that can affect total request time include\nhigh CPU load, high swap, the program running at a low priority level,\nor other behaviors.\n\nIn addition, the read and total timeouts only measure the time between\nread operations on the socket connecting the client and the server,\nnot the total amount of time for the request to return a complete\nresponse. For most requests, the timeout is raised because the server\nhas not sent the first byte in the specified time. This is not always\nthe case; if a server streams one byte every fifteen seconds, a timeout\nof 20 seconds will not trigger, even though the request will take\nseveral minutes to complete.\n:::\n"]}], "exports": []}, {"name": "urllib3._request_methods", "documentation": [], "functions": [], "variables": [{"name": "urllib3._request_methods._TYPE_ENCODE_URL_FIELDS", "type": null, "documentation": []}], "classes": [{"name": "urllib3._request_methods.RequestMethods", "bases": [], "methods": [{"name": "urllib3._request_methods.RequestMethods.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3._request_methods.RequestMethods.urlopen", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "encode_multipart", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "multipart_boundary", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "**kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3._request_methods.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3._request_methods.RequestMethods.request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "fields", "type": {"name": "_TYPE_FIELDS | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "json", "type": {"name": "typing.Any | None", "xref": null, "params": null}, "default": "..."}, {"name": "**urlopen_kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3._request_methods.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": ["Make a request using {meth}`urlopen` with the appropriate encoding of\n`fields` based on the `method` used.\n\nThis is a convenience method that requires the least amount of manual\neffort. It can be used in most situations, while still having the\noption to drop down to more specific methods when necessary, such as\n{meth}`request_encode_url`, {meth}`request_encode_body`,\nor even the lowest level {meth}`urlopen`.\n\n```\nparam method\n\nHTTP request method (such as GET, POST, PUT, etc.)\n\nparam url\n\nThe URL to perform the request on.\n\nparam body\n\nData to send in the request body, either , ,\nan iterable of /, or a file-like object.\n\nparam fields\n\nData to encode and send in the URL or request body, depending on method.\n\nparam headers\n\nDictionary of custom headers to send, such as User-Agent,\nIf-None-Match, etc. If None, pool headers are used. If provided,\nthese headers completely replace any pool-specific headers.\n\nparam json\n\nData to encode and send as JSON with UTF-encoded in the request body.\nThe \"Content-Type\" header will be set to \"application/json\"\nunless specified otherwise.\n```\n"]}, {"name": "urllib3._request_methods.RequestMethods.request_encode_url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "fields", "type": {"name": "_TYPE_ENCODE_URL_FIELDS | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "**urlopen_kw", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3._request_methods.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": ["Make a request using {meth}`urlopen` with the `fields` encoded in\nthe url. This is useful for request methods like GET, HEAD, DELETE, etc.\n\n```\nparam method\n\nHTTP request method (such as GET, POST, PUT, etc.)\n\nparam url\n\nThe URL to perform the request on.\n\nparam fields\n\nData to encode and send in the URL.\n\nparam headers\n\nDictionary of custom headers to send, such as User-Agent,\nIf-None-Match, etc. If None, pool headers are used. If provided,\nthese headers completely replace any pool-specific headers.\n```\n"]}, {"name": "urllib3._request_methods.RequestMethods.request_encode_body", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "fields", "type": {"name": "_TYPE_FIELDS | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "encode_multipart", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "multipart_boundary", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "**urlopen_kw", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3._request_methods.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": ["Make a request using {meth}`urlopen` with the `fields` encoded in\nthe body. This is useful for request methods like POST, PUT, PATCH, etc.\n\nWhen `encode_multipart=True` (default), then\n{func}`urllib3.encode_multipart_formdata` is used to encode\nthe payload with the appropriate content type. Otherwise\n{func}`urllib.parse.urlencode` is used with the\n'application/x-www-form-urlencoded' content type.\n\nMultipart encoding must be used when posting files, and it's reasonably\nsafe to use it in other times too. However, it may break request\nsigning, such as with OAuth.\n\nSupports an optional `fields` parameter of key/value strings AND\nkey/filetuple. A filetuple is a (filename, data, MIME type) tuple where\nthe MIME type is optional. For example:\n\n```\nfields = {\n    'foo': 'bar',\n    'fakefile': ('foofile.txt', 'contents of foofile'),\n    'realfile': ('barfile.txt', open('realfile').read()),\n    'typedfile': ('bazfile.bin', open('bazfile').read(),\n                  'image/jpeg'),\n    'nonamefile': 'contents of nonamefile field',\n}\n```\n\nWhen uploading a file, providing a filename (the first parameter of the\ntuple) is optional but recommended to best mimic behavior of browsers.\n\nNote that if `headers` are supplied, the 'Content-Type' header will\nbe overwritten because it depends on the dynamic random boundary string\nwhich is used to compose the body of the request. The random boundary\nstring can be explicitly set with the `multipart_boundary` parameter.\n\n```\nparam method\n\nHTTP request method (such as GET, POST, PUT, etc.)\n\nparam url\n\nThe URL to perform the request on.\n\nparam fields\n\nData to encode and send in the request body.\n\nparam headers\n\nDictionary of custom headers to send, such as User-Agent,\nIf-None-Match, etc. If None, pool headers are used. If provided,\nthese headers completely replace any pool-specific headers.\n\nparam encode_multipart\n\nIf True, encode the fields using the multipart/form-data MIME\nformat.\n\nparam multipart_boundary\n\nIf not specified, then a random boundary will be generated using\n.\n```\n"]}], "class_variables": [{"name": "urllib3._request_methods.RequestMethods._encode_url_methods", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Convenience mixin for classes who implement a {meth}`urlopen` method, such\nas {class}`urllib3.HTTPConnectionPool` and\n{class}`urllib3.PoolManager`.\n\nProvides behavior for making common types of HTTP request methods and\ndecides which type of request field encoding to use.\n\nSpecifically,\n\n{meth}`.request_encode_url` is for sending requests whose fields are\nencoded in the URL (such as GET, HEAD, DELETE).\n\n{meth}`.request_encode_body` is for sending requests whose fields are\nencoded in the *body* of the request using multipart or www-form-urlencoded\n(such as for POST, PUT, PATCH).\n\n{meth}`.request` is for making any kind of request, it will look up the\nappropriate encoding format and use one of the above two methods to make\nthe request.\n\nInitializer parameters:\n\n```\nparam headers\n\nHeaders to include with all requests, unless other headers are given\nexplicitly.\n```\n"]}], "exports": [{"name": "urllib3._request_methods.RequestMethods", "xref": {"fqname": "urllib3._request_methods.RequestMethods", "project": null}}]}, {"name": "urllib3.fields", "documentation": [], "functions": [{"name": "urllib3.fields.guess_content_type", "asynchronous": false, "params": [{"name": "filename", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "default", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Guess the \"Content-Type\" of a file.\n\n```\nparam filename\n\nThe filename to guess the \"Content-Type\" of using .\n\nparam default\n\nIf no \"Content-Type\" can be guessed, default to .\n```\n"]}, {"name": "urllib3.fields.format_header_param_rfc2231", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "value", "type": {"name": "_TYPE_FIELD_VALUE", "xref": {"fqname": "_TYPE_FIELD_VALUE", "project": null}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Helper function to format and quote a single header parameter using the\nstrategy defined in RFC 2231.\n\nParticularly useful for header parameters which might contain\nnon-ASCII values, like file names. This follows\n[RFC 2388 Section 4.4](https://tools.ietf.org/html/rfc2388#section-4.4).\n\n```\nparam name\n\nThe name of the parameter, a string expected to be ASCII only.\n\nparam value\n\nThe value of the parameter, provided as bytes or .\n\nreturns\n\nAn RFC-2231-formatted unicode string.\n```\n\n:::{deprecated} 2.0.0 Will be removed in urllib3 v2.1.0. This is not valid for ``multipart/form-data`` header parameters.\n:::\n"]}, {"name": "urllib3.fields.format_multipart_header_param", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "value", "type": {"name": "_TYPE_FIELD_VALUE", "xref": {"fqname": "_TYPE_FIELD_VALUE", "project": null}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Format and quote a single multipart header parameter.\n\nThis follows the [WHATWG HTML Standard] as of 2021/06/10, matching\nthe behavior of current browser and curl versions. Values are\nassumed to be UTF-8. The `\\n`, `\\r`, and `\"` characters are\npercent encoded.\n\n```\nparam name\n\nThe name of the parameter, an ASCII-only str.\n\nparam value\n\nThe value of the parameter, a str or UTF-8 encoded\nbytes.\n\nreturns\n\nA string name=\"value\" with the escaped value.\n```\n\n:::{versionchanged} 2.0.0 Matches the WHATWG HTML Standard as of 2021/06/10. Control characters are no longer percent encoded.\n:::\n\n:::{versionchanged} 2.0.0 Renamed from ``format_header_param_html5`` and ``format_header_param``. The old names will be removed in urllib3 v2.1.0.\n:::\n\n[whatwg html standard]: https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#multipart-form-data\n"]}, {"name": "urllib3.fields.format_header_param_html5", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "value", "type": {"name": "_TYPE_FIELD_VALUE", "xref": {"fqname": "_TYPE_FIELD_VALUE", "project": null}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": [":::{deprecated} 2.0.0 Renamed to :func:`format_multipart_header_param`. Will be removed in urllib3 v2.1.0.\n:::\n"]}, {"name": "urllib3.fields.format_header_param", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "value", "type": {"name": "_TYPE_FIELD_VALUE", "xref": {"fqname": "_TYPE_FIELD_VALUE", "project": null}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": [":::{deprecated} 2.0.0 Renamed to :func:`format_multipart_header_param`. Will be removed in urllib3 v2.1.0.\n:::\n"]}], "variables": [{"name": "urllib3.fields._TYPE_FIELD_VALUE", "type": null, "documentation": []}, {"name": "urllib3.fields._TYPE_FIELD_VALUE_TUPLE", "type": null, "documentation": []}], "classes": [{"name": "urllib3.fields.RequestField", "bases": [], "methods": [{"name": "urllib3.fields.RequestField.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "data", "type": {"name": "_TYPE_FIELD_VALUE", "xref": {"fqname": "_TYPE_FIELD_VALUE", "project": null}, "params": null}, "default": null}, {"name": "filename", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "header_formatter", "type": {"name": "typing.Callable[[str, _TYPE_FIELD_VALUE], str] | None", "xref": null, "params": null}, "default": "..."}], "returns": null, "documentation": []}, {"name": "urllib3.fields.RequestField.from_tuples", "asynchronous": false, "params": [{"name": "cls", "type": null, "default": null}, {"name": "fieldname", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "value", "type": {"name": "_TYPE_FIELD_VALUE_TUPLE", "xref": {"fqname": "_TYPE_FIELD_VALUE_TUPLE", "project": null}, "params": null}, "default": null}, {"name": "header_formatter", "type": {"name": "typing.Callable[[str, _TYPE_FIELD_VALUE], str] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "RequestField", "xref": {"fqname": "urllib3.fields.RequestField", "project": null}, "params": null}, "documentation": ["A {class}`~urllib3.fields.RequestField` factory from old-style tuple parameters.\n\nSupports constructing {class}`~urllib3.fields.RequestField` from\nparameter of key/value strings AND key/filetuple. A filetuple is a\n(filename, data, MIME type) tuple where the MIME type is optional.\nFor example:\n\n```\n'foo': 'bar',\n'fakefile': ('foofile.txt', 'contents of foofile'),\n'realfile': ('barfile.txt', open('realfile').read()),\n'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),\n'nonamefile': 'contents of nonamefile field',\n```\n\nField names and filenames must be unicode.\n"]}, {"name": "urllib3.fields.RequestField._render_part", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "value", "type": {"name": "_TYPE_FIELD_VALUE", "xref": {"fqname": "_TYPE_FIELD_VALUE", "project": null}, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Override this method to change how each multipart header\nparameter is formatted. By default, this calls\n{func}`format_multipart_header_param`.\n\n```\nparam name\n\nThe name of the parameter, an ASCII-only str.\n\nparam value\n\nThe value of the parameter, a str or UTF-8 encoded\nbytes.\n\nmeta public\n\n```\n"]}, {"name": "urllib3.fields.RequestField._render_parts", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "header_parts", "type": {"name": "(\n        dict[str, _TYPE_FIELD_VALUE | None]\n        | typing.Sequence[tuple[str, _TYPE_FIELD_VALUE | None]]\n    )", "xref": null, "params": null}, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Helper function to format and quote a single header.\n\nUseful for single headers that are composed of multiple items. E.g.,\n'Content-Disposition' fields.\n\n```\nparam header_parts\n\nA sequence of (k, v) tuples or a  of (k, v) to format\nas .\n```\n"]}, {"name": "urllib3.fields.RequestField.render_headers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": ["Renders the headers for this request field."]}, {"name": "urllib3.fields.RequestField.make_multipart", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "content_disposition", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "content_type", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "content_location", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Makes this request field into a multipart request field.\n\nThis method overrides \"Content-Disposition\", \"Content-Type\" and\n\"Content-Location\" headers to the request parameter.\n\n```\nparam content_disposition\n\nThe 'Content-Disposition' of the request body. Defaults to 'form-data'\n\nparam content_type\n\nThe 'Content-Type' of the request body.\n\nparam content_location\n\nThe 'Content-Location' of the request body.\n```\n"]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A data container for request body parameters.\n\n```\nparam name\n\nThe name of this request field. Must be unicode.\n\nparam data\n\nThe data/value body.\n\nparam filename\n\nAn optional filename of the request field. Must be unicode.\n\nparam headers\n\nAn optional dict-like object of headers to initially use for the field.\n```\n\n:::{versionchanged} 2.0.0 The ``header_formatter`` parameter is deprecated and will be removed in urllib3 v2.1.0.\n:::\n"]}], "exports": []}, {"name": "urllib3.contrib.emscripten.connection", "documentation": [], "functions": [], "variables": [{"name": "urllib3.contrib.emscripten.connection._supports_http_protocol", "type": {"name": "BaseHTTPConnection", "xref": {"fqname": "urllib3.contrib._base_connection.BaseHTTPConnection", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection._supports_https_protocol", "type": {"name": "BaseHTTPSConnection", "xref": {"fqname": "urllib3.contrib._base_connection.BaseHTTPSConnection", "project": null}, "params": null}, "documentation": []}], "classes": [{"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection", "bases": [], "methods": [{"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "urllib3.contrib.util.timeout._TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "socket_options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.set_tunnel", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "scheme", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.connect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "chunked", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "enforce_content_length", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.getresponse", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.contrib.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.is_closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Whether the connection either is brand new or has been previously closed.\nIf this property is True then both `is_connected` and `has_connected_to_proxy`\nproperties must be False.\n"]}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.is_connected", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Whether the connection is actively connected to any origin (proxy or target)"]}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.has_connected_to_proxy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Whether the connection has successfully connected to its proxy.\nThis returns False if no proxy is in use. Used to determine whether\nerrors are coming from the proxy layer or from tunnelling to the target origin."]}], "class_variables": [{"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.default_port", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.default_socket_options", "type": {"name": "typing.ClassVar", "xref": {"fqname": "typing.ClassVar", "project": "--std--"}, "params": [{"name": "_TYPE_SOCKET_OPTIONS", "xref": {"fqname": "urllib3.contrib.util.connection._TYPE_SOCKET_OPTIONS", "project": null}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.timeout", "type": {"name": "None | (float)", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.port", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.socket_options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.is_verified", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection.proxy_is_verified", "type": {"name": "bool | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection._response", "type": {"name": "EmscriptenResponse | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection", "bases": ["EmscriptenHTTPConnection"], "methods": [{"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "_TYPE_TIMEOUT", "xref": {"fqname": "urllib3.contrib.util.timeout._TYPE_TIMEOUT", "project": null}, "params": null}, "default": "..."}, {"name": "source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "default": "..."}, {"name": "blocksize", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "socket_options", "type": {"name": "(\n        None | _TYPE_SOCKET_OPTIONS\n    )", "xref": null, "params": null}, "default": "..."}, {"name": "proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "default": "..."}, {"name": "assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_context", "type": {"name": "typing.Any | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.set_cert", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "default": "..."}, {"name": "key_password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "default": "..."}, {"name": "assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.default_port", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.cert_reqs", "type": {"name": "int | str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.ca_cert_data", "type": {"name": "None | str | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.key_file", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.key_password", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.ssl_context", "type": {"name": "typing.Any | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.ssl_minimum_version", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.ssl_maximum_version", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection.assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.contrib.pyopenssl", "documentation": ["Module for using pyOpenSSL as a TLS backend. This module was relevant before\nthe standard library `ssl` module supported SNI, but now that we've dropped\nsupport for Python 2.7 all relevant Python versions support SNI so\n**this module is no longer recommended**.\n\nThis needs the following packages installed:\n\n- [pyOpenSSL] (tested with 16.0.0)\n- [cryptography] (minimum 1.3.4, from pyopenssl)\n- [idna] (minimum 2.0)\n\nHowever, pyOpenSSL depends on cryptography, so while we use all three directly here we\nend up having relatively few packages required.\n\nYou can install them with the following command:\n\n```bash\n$ python -m pip install pyopenssl cryptography idna\n```\n\nTo activate certificate checking, call\n{func}`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code\nbefore you begin making HTTP requests. This can be done in a `sitecustomize`\nmodule, or at any other time before your application begins using `urllib3`,\nlike this:\n\n```python\ntry:\n    import urllib3.contrib.pyopenssl\n    urllib3.contrib.pyopenssl.inject_into_urllib3()\nexcept ImportError:\n    pass\n```\n\n[cryptography]: https://cryptography.io\n[idna]: https://github.com/kjd/idna\n[pyopenssl]: https://www.pyopenssl.org\n"], "functions": [{"name": "urllib3.contrib.pyopenssl.inject_into_urllib3", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.extract_from_urllib3", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._validate_dependencies_met", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Verifies that PyOpenSSL's package-level dependencies have been met.\nThrows `ImportError` if they are not met."]}, {"name": "urllib3.contrib.pyopenssl._dnsname_to_stdlib", "asynchronous": false, "params": [{"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Converts a dNSName SubjectAlternativeName field to the form used by the\nstandard library on the given Python version.\n\nCryptography produces a dNSName as a unicode string that was idna-decoded\nfrom ASCII bytes. We need to idna-encode that string to get it back, and\nthen on Python 3 we also need to convert to unicode via UTF-8 (the stdlib\nuses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).\n\nIf the name cannot be idna-encoded then we return None signalling that\nthe name given should be skipped."]}, {"name": "urllib3.contrib.pyopenssl.get_subj_alt_name", "asynchronous": false, "params": [{"name": "peer_cert", "type": {"name": "X509", "xref": {"fqname": "OpenSSL.crypto.X509", "project": null}, "params": null}, "default": null}], "returns": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}]}, "documentation": ["Given an PyOpenSSL certificate, provides all the subject alternative names."]}, {"name": "urllib3.contrib.pyopenssl._verify_callback", "asynchronous": false, "params": [{"name": "cnx", "type": {"name": "OpenSSL.SSL.Connection", "xref": {"fqname": "OpenSSL.SSL.Connection", "project": null}, "params": null}, "default": null}, {"name": "x509", "type": {"name": "X509", "xref": {"fqname": "OpenSSL.crypto.X509", "project": null}, "params": null}, "default": null}, {"name": "err_no", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "err_depth", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "return_code", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}], "variables": [{"name": "urllib3.contrib.pyopenssl._openssl_versions", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._stdlib_to_openssl_verify", "type": null, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._openssl_to_stdlib_verify", "type": null, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._OP_NO_SSLv2_OR_SSLv3", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._OP_NO_TLSv1", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._OP_NO_TLSv1_1", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._OP_NO_TLSv1_2", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._OP_NO_TLSv1_3", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._openssl_to_ssl_minimum_version", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl._openssl_to_ssl_maximum_version", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.SSL_WRITE_BLOCKSIZE", "type": null, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.orig_util_SSLContext", "type": null, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.log", "type": null, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.makefile", "type": null, "documentation": ["type: ignore[attr-defined]"]}], "classes": [{"name": "urllib3.contrib.pyopenssl.UnsupportedExtension", "bases": ["Exception"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["UnsupportedExtension is gone in cryptography >= 2.1.0"]}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket", "bases": [], "methods": [{"name": "urllib3.contrib.pyopenssl.WrappedSocket.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "connection", "type": {"name": "OpenSSL.SSL.Connection", "xref": {"fqname": "OpenSSL.SSL.Connection", "project": null}, "params": null}, "default": null}, {"name": "socket", "type": {"name": "socket_cls", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "suppress_ragged_eofs", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.fileno", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket._decref_socketios", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Copy-pasted from Python 3.5 source code"]}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.recv", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*args", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "**kwargs", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.recv_into", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*args", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "**kwargs", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.settimeout", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "timeout", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket._send_until_done", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.sendall", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.shutdown", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "how", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket._real_close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.getpeercert", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "binary_form", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "dict[str, list[typing.Any]] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.version", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.WrappedSocket.selected_alpn_protocol", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["API-compatibility wrapper for Python OpenSSL's Connection-class."]}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext", "bases": [], "methods": [{"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "protocol", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.options", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.options", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "value", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.verify_mode", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.verify_mode", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "value", "type": {"name": "ssl.VerifyMode", "xref": {"fqname": "ssl.VerifyMode", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.set_default_verify_paths", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.set_ciphers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "ciphers", "type": {"name": "bytes | str", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.load_verify_locations", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "cafile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "capath", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "cadata", "type": {"name": "bytes | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.load_cert_chain", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "certfile", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "keyfile", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.set_alpn_protocols", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "protocols", "type": {"name": "list", "xref": {"fqname": "functions.list", "project": "--std--"}, "params": [{"name": "bytes | str", "xref": null, "params": null}]}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.wrap_socket", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "sock", "type": {"name": "socket_cls", "xref": {"fqname": "socket.socket", "project": "--std--"}, "params": null}, "default": null}, {"name": "server_side", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "do_handshake_on_connect", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "suppress_ragged_eofs", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "server_hostname", "type": {"name": "bytes | str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "WrappedSocket", "xref": {"fqname": "urllib3.contrib.pyopenssl.WrappedSocket", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext._set_ctx_options", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.minimum_version", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.minimum_version", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "minimum_version", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.maximum_version", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.pyopenssl.PyOpenSSLContext.maximum_version", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "maximum_version", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["I am a wrapper class for the PyOpenSSL `Context` object. I am responsible\nfor translating the interface of the standard library `SSLContext` object\nto calls into PyOpenSSL.\n"]}], "exports": [{"name": "urllib3.contrib.pyopenssl.extract_from_urllib3", "xref": {"fqname": "urllib3.contrib.pyopenssl.extract_from_urllib3", "project": null}}, {"name": "urllib3.contrib.pyopenssl.inject_into_urllib3", "xref": {"fqname": "urllib3.contrib.pyopenssl.inject_into_urllib3", "project": null}}]}, {"name": "urllib3.contrib.emscripten.response", "documentation": [], "functions": [], "variables": [{"name": "urllib3.contrib.emscripten.response.log", "type": null, "documentation": []}], "classes": [{"name": "urllib3.contrib.emscripten.response.EmscriptenResponse", "bases": [], "methods": [], "class_variables": [{"name": "urllib3.contrib.emscripten.response.EmscriptenResponse.status_code", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenResponse.headers", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenResponse.body", "type": {"name": "IOBase | bytes", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenResponse.request", "type": {"name": "EmscriptenRequest", "xref": {"fqname": "urllib3.contrib.emscripten.response.request.EmscriptenRequest", "project": null}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper", "bases": ["BaseHTTPResponse"], "methods": [{"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "internal_response", "type": {"name": "EmscriptenResponse", "xref": {"fqname": "urllib3.contrib.emscripten.response.EmscriptenResponse", "project": null}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "connection", "type": {"name": "BaseHTTPConnection | BaseHTTPSConnection | None", "xref": null, "params": null}, "default": "..."}], "returns": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.connection", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "BaseHTTPConnection | BaseHTTPSConnection | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.retries", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Retry | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.retries", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "retries", "type": {"name": "Retry | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.stream", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.Generator", "xref": {"fqname": "typing.Generator", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": ["A generator wrapper for the read() method. A call will block until\n`amt` bytes have been read from the connection or until the\nconnection is closed.\n\n```\nparam amt\n\nHow much of the content to read. The generator will return up to\nmuch data per iteration, but may return less. This is particularly\nlikely when using compressed data. However, the empty string will\nnever be returned.\n\nparam decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n```\n"]}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper._init_length", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request_method", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.read", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "cache_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.read_chunked", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.Generator", "xref": {"fqname": "typing.Generator", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.release_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.drain_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.data", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.json", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "documentation": ["Deserializes the body of the HTTP response as a Python object.\n\nThe body of the HTTP response must be encoded using UTF-8, as per\n[RFC 8529 Section 8.1](https://www.rfc-editor.org/rfc/rfc8259#section-8.1).\n\nTo use a custom JSON decoder pass the result of {attr}`HTTPResponse.data` to\nyour custom decoder instead.\n\nIf the body of the HTTP response is not decodable to UTF-8, a\n`UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\nvalid JSON document, a `json.JSONDecodeError` will be raised.\n\nRead more {ref}`here <json_content>`.\n\n```\nreturns\n\nThe body of the HTTP response as a Python object.\n```\n"]}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.response.EmscriptenHttpResponseWrapper._error_catcher", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Generator", "xref": {"fqname": "typing.Generator", "project": "--std--"}, "params": [{"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}]}, "documentation": ["Catch Emscripten specific exceptions thrown by fetch.py,\ninstead re-raising urllib3 variants, so that low-level exceptions\nare not leaked in the high-level api.\n\nOn exit, release the connection back to the pool."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.contrib.emscripten", "documentation": [], "functions": [{"name": "urllib3.contrib.emscripten.inject_into_urllib3", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "variables": [], "classes": [], "exports": [{"name": "urllib3.contrib.emscripten.annotations", "xref": {"fqname": "__future__.annotations", "project": null}}, {"name": "urllib3.contrib.emscripten.EmscriptenHTTPConnection", "xref": {"fqname": "urllib3.contrib.emscripten.connection.EmscriptenHTTPConnection", "project": null}}, {"name": "urllib3.contrib.emscripten.EmscriptenHTTPSConnection", "xref": {"fqname": "urllib3.contrib.emscripten.connection.EmscriptenHTTPSConnection", "project": null}}, {"name": "urllib3.contrib.emscripten.HTTPConnectionPool", "xref": {"fqname": "urllib3.connectionpool.HTTPConnectionPool", "project": null}}, {"name": "urllib3.contrib.emscripten.HTTPSConnectionPool", "xref": {"fqname": "urllib3.connectionpool.HTTPSConnectionPool", "project": null}}]}, {"name": "urllib3.contrib.emscripten.request", "documentation": [], "functions": [], "variables": [], "classes": [{"name": "urllib3.contrib.emscripten.request.EmscriptenRequest", "bases": [], "methods": [{"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.set_header", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "value", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.set_body", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.params", "type": {"name": "dict[str, str] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.headers", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.timeout", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.request.EmscriptenRequest.decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}], "exports": []}, {"name": "urllib3.contrib", "documentation": [], "functions": [], "variables": [], "classes": [], "exports": []}, {"name": "urllib3.contrib.socks", "documentation": ["This module contains provisional support for SOCKS proxies from within\nurllib3. This module supports SOCKS4, SOCKS4A (an extension of SOCKS4), and\nSOCKS5. To enable its functionality, either install PySocks or install this\nmodule with the `socks` extra.\n\nThe SOCKS implementation supports the full range of urllib3 features. It also\nsupports the following SOCKS features:\n\n- SOCKS4A (`proxy_url='socks4a://...`)\n- SOCKS4 (`proxy_url='socks4://...`)\n- SOCKS5 with remote DNS (`proxy_url='socks5h://...`)\n- SOCKS5 with local DNS (`proxy_url='socks5://...`)\n- Usernames and passwords for the SOCKS proxy\n\n:::{note}\nIt is recommended to use `socks5h://` or `socks4a://` schemes in\nyour `proxy_url` to ensure that DNS resolution is done from the remote\nserver instead of client-side when connecting to a domain name.\n:::\n\nSOCKS4 supports IPv4 and domain names with the SOCKS4A extension. SOCKS5\nsupports IPv4, IPv6, and domain names.\n\nWhen connecting to a SOCKS4 proxy the `username` portion of the `proxy_url`\nwill be sent as the `userid` section of the SOCKS request:\n\n```python\nproxy_url=\"socks4a://<userid>@proxy-host\"\n```\n\nWhen connecting to a SOCKS5 proxy the `username` and `password` portion\nof the `proxy_url` will be sent as the username/password to authenticate\nwith the proxy:\n\n```python\nproxy_url=\"socks5h://<username>:<password>@proxy-host\"\n```\n"], "functions": [], "variables": [{"name": "urllib3.contrib.socks.ssl", "type": null, "documentation": ["type: ignore[assignment]"]}], "classes": [{"name": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS", "bases": ["typing.TypedDict"], "methods": [], "class_variables": [{"name": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS.socks_version", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS.proxy_host", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS.proxy_port", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS.username", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS.password", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS.rdns", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.socks.SOCKSConnection", "bases": ["HTTPConnection"], "methods": [{"name": "urllib3.contrib.socks.SOCKSConnection.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "_socks_options", "type": {"name": "_TYPE_SOCKS_OPTIONS", "xref": {"fqname": "urllib3.contrib.socks._TYPE_SOCKS_OPTIONS", "project": null}, "params": null}, "default": null}, {"name": "*args", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "**kwargs", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.socks.SOCKSConnection._new_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "socks.socksocket", "xref": {"fqname": "socks.socksocket", "project": null}, "params": null}, "documentation": ["Establish a new connection via the SOCKS proxy."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A plain-text HTTP connection that connects via a SOCKS proxy."]}, {"name": "urllib3.contrib.socks.SOCKSHTTPSConnection", "bases": ["SOCKSConnection", "HTTPSConnection"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["We don't need to duplicate the Verified/Unverified distinction from", "urllib3/connection.py here because the HTTPSConnection will already have been", "correctly set to either the Verified or Unverified form by that module. This", "means the SOCKSHTTPSConnection will automatically be the correct type."]}, {"name": "urllib3.contrib.socks.SOCKSHTTPConnectionPool", "bases": ["HTTPConnectionPool"], "methods": [], "class_variables": [{"name": "urllib3.contrib.socks.SOCKSHTTPConnectionPool.ConnectionCls", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.socks.SOCKSHTTPSConnectionPool", "bases": ["HTTPSConnectionPool"], "methods": [], "class_variables": [{"name": "urllib3.contrib.socks.SOCKSHTTPSConnectionPool.ConnectionCls", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.socks.SOCKSProxyManager", "bases": ["PoolManager"], "methods": [{"name": "urllib3.contrib.socks.SOCKSProxyManager.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "proxy_url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "username", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "password", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "num_pools", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "**connection_pool_kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": null, "documentation": []}], "class_variables": [{"name": "urllib3.contrib.socks.SOCKSProxyManager.pool_classes_by_scheme", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["A version of the urllib3 ProxyManager that routes connections via the\ndefined SOCKS proxy."]}], "exports": []}, {"name": "urllib3", "documentation": ["Python HTTP library with thread-safe connection pooling, file post support, user friendly, and more"], "functions": [{"name": "urllib3.add_stderr_logger", "asynchronous": false, "params": [{"name": "level", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "logging.StreamHandler", "xref": {"fqname": "logging.StreamHandler", "project": "--std--"}, "params": [{"name": "typing.TextIO", "xref": {"fqname": "typing.TextIO", "project": "--std--"}, "params": null}]}, "documentation": ["Helper for quickly adding a StreamHandler to the logger. Useful for\ndebugging.\n\nReturns the handler after adding it."]}, {"name": "urllib3.disable_warnings", "asynchronous": false, "params": [{"name": "category", "type": {"name": "type", "xref": {"fqname": "functions.type", "project": "--std--"}, "params": [{"name": "Warning", "xref": {"fqname": "functions.Warning", "project": "--std--"}, "params": null}]}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Helper for quickly disabling all urllib3 warnings."]}, {"name": "urllib3.request", "asynchronous": false, "params": [{"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY | None", "xref": null, "params": null}, "default": "..."}, {"name": "fields", "type": {"name": "_TYPE_FIELDS | None", "xref": null, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "redirect", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "retries", "type": {"name": "Retry | bool | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "timeout", "type": {"name": "Timeout | float | int | None", "xref": null, "params": null}, "default": "..."}, {"name": "json", "type": {"name": "typing.Any | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": ["A convenience, top-level request method. It uses a module-global `PoolManager` instance.\nTherefore, its side effects could be shared across dependencies relying on it.\nTo avoid side effects create a new `PoolManager` instance and use it instead.\nThe method does not accept low-level `**urlopen_kw` keyword arguments.\n\n```\nparam method\n\nHTTP request method (such as GET, POST, PUT, etc.)\n\nparam url\n\nThe URL to perform the request on.\n\nparam body\n\nData to send in the request body, either , ,\nan iterable of /, or a file-like object.\n\nparam fields\n\nData to encode and send in the request body.\n\nparam headers\n\nDictionary of custom headers to send, such as User-Agent,\nIf-None-Match, etc.\n\nparam bool preload_content\n\nIf True, the response's body will be preloaded into memory.\n\nparam bool decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n\nparam redirect\n\nIf True, automatically handle redirects (status codes 301, 302,\n303, 307, 308). Each redirect counts as a retry. Disabling retries\nwill disable redirect, too.\n\nparam retries\n\nConfigure the number of retries to allow before raising a\n exception.\n\nIf None (default) will retry 3 times, see Retry.DEFAULT. Pass a\n object for fine-grained control\nover different types of retries.\nPass an integer number to retry connection errors that many times,\nbut no other types of errors. Pass zero to never retry.\n\nIf False, then retries are disabled and any exception is raised\nimmediately. Also, instead of raising a MaxRetryError on redirects,\nthe redirect response will be returned.\n\ntype retries\n\n, False, or an int.\n\nparam timeout\n\nIf specified, overrides the default timeout for this one\nrequest. It may be a float (in seconds) or an instance of\n.\n\nparam json\n\nData to encode and send as JSON with UTF-encoded in the request body.\nThe \"Content-Type\" header will be set to \"application/json\"\nunless specified otherwise.\n```\n"]}], "variables": [{"name": "urllib3.__author__", "type": null, "documentation": []}, {"name": "urllib3.__license__", "type": null, "documentation": []}, {"name": "urllib3.__version__", "type": null, "documentation": []}, {"name": "urllib3._DEFAULT_POOL", "type": null, "documentation": []}], "classes": [], "exports": [{"name": "urllib3.add_stderr_logger", "xref": {"fqname": "urllib3.add_stderr_logger", "project": null}}, {"name": "urllib3.BaseHTTPResponse", "xref": {"fqname": "urllib3.response.BaseHTTPResponse", "project": null}}, {"name": "urllib3.connection_from_url", "xref": {"fqname": "urllib3.connectionpool.connection_from_url", "project": null}}, {"name": "urllib3.disable_warnings", "xref": {"fqname": "urllib3.disable_warnings", "project": null}}, {"name": "urllib3.encode_multipart_formdata", "xref": {"fqname": "urllib3.filepost.encode_multipart_formdata", "project": null}}, {"name": "urllib3.HTTPConnectionPool", "xref": {"fqname": "urllib3.connectionpool.HTTPConnectionPool", "project": null}}, {"name": "urllib3.HTTPHeaderDict", "xref": {"fqname": "urllib3._collections.HTTPHeaderDict", "project": null}}, {"name": "urllib3.HTTPResponse", "xref": {"fqname": "urllib3.response.HTTPResponse", "project": null}}, {"name": "urllib3.HTTPSConnectionPool", "xref": {"fqname": "urllib3.connectionpool.HTTPSConnectionPool", "project": null}}, {"name": "urllib3.make_headers", "xref": {"fqname": "urllib3.util.request.make_headers", "project": null}}, {"name": "urllib3.PoolManager", "xref": {"fqname": "urllib3.poolmanager.PoolManager", "project": null}}, {"name": "urllib3.proxy_from_url", "xref": {"fqname": "urllib3.poolmanager.proxy_from_url", "project": null}}, {"name": "urllib3.ProxyManager", "xref": {"fqname": "urllib3.poolmanager.ProxyManager", "project": null}}, {"name": "urllib3.request", "xref": {"fqname": "urllib3.request", "project": null}}, {"name": "urllib3.Retry", "xref": {"fqname": "urllib3.util.retry.Retry", "project": null}}, {"name": "urllib3.Timeout", "xref": {"fqname": "urllib3.util.timeout.Timeout", "project": null}}]}, {"name": "urllib3.contrib.emscripten.fetch", "documentation": ["Support for streaming http requests in emscripten.\n\nA few caveats -\n\nIf your browser (or Node.js) has WebAssembly JavaScript Promise Integration enabled\nhttps://github.com/WebAssembly/js-promise-integration/blob/main/proposals/js-promise-integration/Overview.md\n*and* you launch pyodide using `pyodide.runPythonAsync`, this will fetch data using the\nJavaScript asynchronous fetch api (wrapped via `pyodide.ffi.call_sync`). In this case\ntimeouts and streaming should just work.\n\nOtherwise, it uses a combination of XMLHttpRequest and a web-worker for streaming.\n\nThis approach has several caveats:\n\nFirstly, you can't do streaming http in the main UI thread, because atomics.wait isn't allowed.\nStreaming only works if you're running pyodide in a web worker.\n\nSecondly, this uses an extra web worker and SharedArrayBuffer to do the asynchronous fetch\noperation, so it requires that you have crossOriginIsolation enabled, by serving over https\n(or from localhost) with the two headers below set:\n\n    Cross-Origin-Opener-Policy: same-origin\n    Cross-Origin-Embedder-Policy: require-corp\n\nYou can tell if cross origin isolation is successfully enabled by looking at the global crossOriginIsolated variable in\nJavaScript console. If it isn't, streaming requests will fallback to XMLHttpRequest, i.e. getting the whole\nrequest into a buffer and then returning it. it shows a warning in the JavaScript console in this case.\n\nFinally, the webworker which does the streaming fetch is created on initial import, but will only be started once\ncontrol is returned to javascript. Call `await wait_for_streaming_ready()` to wait for streaming fetch.\n\nNB: in this code, there are a lot of JavaScript objects. They are named js_*\nto make it clear what type of object they are."], "functions": [{"name": "urllib3.contrib.emscripten.fetch._obj_from_dict", "asynchronous": false, "params": [{"name": "dict_val", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "JsProxy", "xref": {"fqname": "pyodide.ffi.JsProxy", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.is_in_browser_main_thread", "asynchronous": false, "params": [], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["check if we are in a worker or not"]}, {"name": "urllib3.contrib.emscripten.fetch.is_cross_origin_isolated", "asynchronous": false, "params": [], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.is_in_node", "asynchronous": false, "params": [], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.is_worker_available", "asynchronous": false, "params": [], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.send_streaming_request", "asynchronous": false, "params": [{"name": "request", "type": {"name": "EmscriptenRequest", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.request.EmscriptenRequest", "project": null}, "params": null}, "default": null}], "returns": {"name": "EmscriptenResponse | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._show_timeout_warning", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._show_streaming_warning", "asynchronous": false, "params": [], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.send_request", "asynchronous": false, "params": [{"name": "request", "type": {"name": "EmscriptenRequest", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.request.EmscriptenRequest", "project": null}, "params": null}, "default": null}], "returns": {"name": "EmscriptenResponse", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.response.EmscriptenResponse", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.send_jspi_request", "asynchronous": false, "params": [{"name": "request", "type": {"name": "EmscriptenRequest", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.request.EmscriptenRequest", "project": null}, "params": null}, "default": null}, {"name": "streaming", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "EmscriptenResponse", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.response.EmscriptenResponse", "project": null}, "params": null}, "documentation": ["Send a request using WebAssembly JavaScript Promise Integration\nto wrap the asynchronous JavaScript fetch api (experimental).\n\n```\nparam request\n\nRequest to send\n\nparam streaming\n\nWhether to stream the response\n\nreturn\n\nThe response object\n\nrtype\n\nEmscriptenResponse\n```\n"]}, {"name": "urllib3.contrib.emscripten.fetch._run_sync_with_timeout", "asynchronous": false, "params": [{"name": "promise", "type": {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "timeout", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": null}, {"name": "js_abort_controller", "type": {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "request", "type": {"name": "EmscriptenRequest | None", "xref": null, "params": null}, "default": null}, {"name": "response", "type": {"name": "EmscriptenResponse | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "documentation": ["Await a JavaScript promise synchronously with a timeout which is implemented\nvia the AbortController\n\n```\nparam promise\n\nJavascript promise to await\n\nparam timeout\n\nTimeout in seconds\n\nparam js_abort_controller\n\nA JavaScript AbortController object, used on timeout\n\nparam request\n\nThe request being handled\n\nparam response\n\nThe response being handled (if it exists yet)\n\nraises _TimeoutError\n\nIf the request times out\n\nraises _RequestError\n\nIf the request raises a JavaScript exception\n\nreturn\n\nThe result of awaiting the promise.\n```\n"]}, {"name": "urllib3.contrib.emscripten.fetch.has_jspi", "asynchronous": false, "params": [], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Return true if jspi can be used.\n\nThis requires both browser support and also WebAssembly\nto be in the correct state - i.e. that the javascript\ncall into python was async not sync.\n\n```\nreturn\n\nTrue if jspi can be used.\n\nrtype\n\nbool\n```\n"]}, {"name": "urllib3.contrib.emscripten.fetch.streaming_ready", "asynchronous": false, "params": [], "returns": {"name": "bool | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.wait_for_streaming_ready", "asynchronous": true, "params": [], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}], "variables": [{"name": "urllib3.contrib.emscripten.fetch.HEADERS_TO_IGNORE", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.SUCCESS_HEADER", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.SUCCESS_EOF", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.ERROR_TIMEOUT", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.ERROR_EXCEPTION", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._STREAMING_WORKER_CODE", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._fetcher", "type": {"name": "_StreamingFetcher | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._fetcher", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._fetcher", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch.NODE_JSPI_ERROR", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._SHOWN_TIMEOUT_WARNING", "type": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._SHOWN_STREAMING_WARNING", "type": null, "documentation": []}], "classes": [{"name": "urllib3.contrib.emscripten.fetch._RequestError", "bases": ["Exception"], "methods": [{"name": "urllib3.contrib.emscripten.fetch._RequestError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "message", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "request", "type": {"name": "EmscriptenRequest | None", "xref": null, "params": null}, "default": "..."}, {"name": "response", "type": {"name": "EmscriptenResponse | None", "xref": null, "params": null}, "default": "..."}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._StreamingError", "bases": ["_RequestError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._TimeoutError", "bases": ["_RequestError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream", "bases": ["io.RawIOBase"], "methods": [{"name": "urllib3.contrib.emscripten.fetch._ReadStream.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "int_buffer", "type": {"name": "JsArray", "xref": {"fqname": "pyodide.ffi.JsArray", "project": null}, "params": null}, "default": null}, {"name": "byte_buffer", "type": {"name": "JsArray", "xref": {"fqname": "pyodide.ffi.JsArray", "project": null}, "params": null}, "default": null}, {"name": "timeout", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": null}, {"name": "worker", "type": {"name": "JsProxy", "xref": {"fqname": "pyodide.ffi.JsProxy", "project": null}, "params": null}, "default": null}, {"name": "connection_id", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "request", "type": {"name": "EmscriptenRequest", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.request.EmscriptenRequest", "project": null}, "params": null}, "default": null}], "returns": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.__del__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.is_closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["this is compatible with _base_connection"]}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["for compatibility with RawIOBase"]}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.readable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.writable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.seekable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._ReadStream.readinto", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "byte_obj", "type": {"name": "Buffer", "xref": {"fqname": "typing_extensions.Buffer", "project": null}, "params": null}, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._StreamingFetcher", "bases": [], "methods": [{"name": "urllib3.contrib.emscripten.fetch._StreamingFetcher.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._StreamingFetcher.send", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": {"name": "EmscriptenRequest", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.request.EmscriptenRequest", "project": null}, "params": null}, "default": null}], "returns": {"name": "EmscriptenResponse", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.response.EmscriptenResponse", "project": null}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream", "bases": ["io.RawIOBase"], "methods": [{"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "js_read_stream", "type": {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}, {"name": "timeout", "type": {"name": "float", "xref": {"fqname": "functions.float", "project": "--std--"}, "params": null}, "default": null}, {"name": "request", "type": {"name": "EmscriptenRequest", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.request.EmscriptenRequest", "project": null}, "params": null}, "default": null}, {"name": "response", "type": {"name": "EmscriptenResponse", "xref": {"fqname": "urllib3.contrib.emscripten.fetch.response.EmscriptenResponse", "project": null}, "params": null}, "default": null}, {"name": "js_abort_controller", "type": {"name": "Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": null, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.__del__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.is_closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["this is compatible with _base_connection"]}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["for compatibility with RawIOBase"]}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.readable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.writable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.seekable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream._get_next_buffer", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.contrib.emscripten.fetch._JSPIReadStream.readinto", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "byte_obj", "type": {"name": "Buffer", "xref": {"fqname": "typing_extensions.Buffer", "project": null}, "params": null}, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A read stream that uses pyodide.ffi.run_sync to read from a JavaScript fetch\nresponse. This requires support for WebAssembly JavaScript Promise Integration\nin the containing browser, and for pyodide to be launched via runPythonAsync.\n\n```\nparam js_read_stream\n\nThe JavaScript stream reader\n\nparam timeout\n\nTimeout in seconds\n\nparam request\n\nThe request we're handling\n\nparam response\n\nThe response this stream relates to\n\nparam js_abort_controller\n\nA JavaScript AbortController object, used for timeouts\n```\n"]}], "exports": []}, {"name": "urllib3.response", "documentation": [], "functions": [{"name": "urllib3.response._get_decoder", "asynchronous": false, "params": [{"name": "mode", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "ContentDecoder", "xref": {"fqname": "urllib3.response.ContentDecoder", "project": null}, "params": null}, "documentation": []}], "variables": [{"name": "urllib3.response.brotli", "type": null, "documentation": []}, {"name": "urllib3.response.HAS_ZSTD", "type": null, "documentation": []}, {"name": "urllib3.response._zstd_version", "type": null, "documentation": []}, {"name": "urllib3.response.HAS_ZSTD", "type": null, "documentation": []}, {"name": "urllib3.response.HAS_ZSTD", "type": null, "documentation": []}, {"name": "urllib3.response.log", "type": null, "documentation": []}], "classes": [{"name": "urllib3.response.ContentDecoder", "bases": [], "methods": [{"name": "urllib3.response.ContentDecoder.decompress", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.ContentDecoder.flush", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.response.DeflateDecoder", "bases": ["ContentDecoder"], "methods": [{"name": "urllib3.response.DeflateDecoder.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.DeflateDecoder.decompress", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.DeflateDecoder.flush", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.response.GzipDecoderState", "bases": [], "methods": [], "class_variables": [{"name": "urllib3.response.GzipDecoderState.FIRST_MEMBER", "type": null, "documentation": []}, {"name": "urllib3.response.GzipDecoderState.OTHER_MEMBERS", "type": null, "documentation": []}, {"name": "urllib3.response.GzipDecoderState.SWALLOW_DATA", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.response.GzipDecoder", "bases": ["ContentDecoder"], "methods": [{"name": "urllib3.response.GzipDecoder.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.GzipDecoder.decompress", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.GzipDecoder.flush", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.response.BrotliDecoder", "bases": ["ContentDecoder"], "methods": [{"name": "urllib3.response.BrotliDecoder.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Supports both 'brotlipy' and 'Brotli' packages", "since they share an import name. The top branches", "are for 'brotlipy' and bottom branches for 'Brotli'"]}, {"name": "urllib3.response.BrotliDecoder.flush", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.response.ZstdDecoder", "bases": ["ContentDecoder"], "methods": [{"name": "urllib3.response.ZstdDecoder.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.ZstdDecoder.decompress", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.ZstdDecoder.flush", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.response.MultiDecoder", "bases": ["ContentDecoder"], "methods": [{"name": "urllib3.response.MultiDecoder.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "modes", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.MultiDecoder.flush", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.MultiDecoder.decompress", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["From RFC7231:\n    If one or more encodings have been applied to a representation, the\n    sender that applied the encodings MUST generate a Content-Encoding\n    header field that lists the content codings in the order in which\n    they were applied."]}, {"name": "urllib3.response.BytesQueueBuffer", "bases": [], "methods": [{"name": "urllib3.response.BytesQueueBuffer.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BytesQueueBuffer.__len__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BytesQueueBuffer.put", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BytesQueueBuffer.get", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "n", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BytesQueueBuffer.get_all", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Memory-efficient bytes buffer\n\nTo return decoded data in read() and still follow the BufferedIOBase API, we need a\nbuffer to always return the correct amount of bytes.\n\nThis buffer should be filled using calls to put()\n\nOur maximum memory usage is determined by the sum of the size of:\n\n * self.buffer, which contains the full data\n * the largest chunk that we will copy in get()\n\nThe worst case scenario is a single chunk, in which case we'll make a full copy of\nthe data inside get()."]}, {"name": "urllib3.response.BaseHTTPResponse", "bases": ["io.IOBase"], "methods": [{"name": "urllib3.response.BaseHTTPResponse.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None", "xref": null, "params": null}, "default": "..."}, {"name": "status", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "version", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "version_string", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "reason", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}, {"name": "request_url", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "retries", "type": {"name": "Retry | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.get_redirect_location", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None | typing.Literal[False]", "xref": null, "params": null}, "documentation": ["Should we redirect and where to?\n\n```\nreturns\n\nTruthy redirect location string if we got a redirect status\ncode and valid location. None if redirect status and no\nlocation. False if not a redirect status code.\n```\n"]}, {"name": "urllib3.response.BaseHTTPResponse.data", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.json", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "documentation": ["Deserializes the body of the HTTP response as a Python object.\n\nThe body of the HTTP response must be encoded using UTF-8, as per\n[RFC 8529 Section 8.1](https://www.rfc-editor.org/rfc/rfc8259#section-8.1).\n\nTo use a custom JSON decoder pass the result of {attr}`HTTPResponse.data` to\nyour custom decoder instead.\n\nIf the body of the HTTP response is not decodable to UTF-8, a\n`UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\nvalid JSON document, a `json.JSONDecodeError` will be raised.\n\nRead more {ref}`here <json_content>`.\n\n```\nreturns\n\nThe body of the HTTP response as a Python object.\n```\n"]}, {"name": "urllib3.response.BaseHTTPResponse.url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.connection", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "BaseHTTPConnection | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.retries", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Retry | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.retries", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "retries", "type": {"name": "Retry | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.stream", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.read", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "cache_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.read1", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.read_chunked", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.release_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.drain_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.shutdown", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse._init_decoder", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Set-up the _decoder attribute if necessary."]}, {"name": "urllib3.response.BaseHTTPResponse._decode", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "default": null}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": null}, {"name": "flush_decoder", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Decode the data passed in and potentially flush the decoder."]}, {"name": "urllib3.response.BaseHTTPResponse._flush_decoder", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Flushes the decoder. Should only be called if the decoder is actually\nbeing used."]}, {"name": "urllib3.response.BaseHTTPResponse.readinto", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "b", "type": {"name": "bytearray", "xref": {"fqname": "functions.bytearray", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": ["Compatibility methods for `io` module"]}, {"name": "urllib3.response.BaseHTTPResponse.getheaders", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "HTTPHeaderDict", "xref": {"fqname": "urllib3.response._collections.HTTPHeaderDict", "project": null}, "params": null}, "documentation": ["Compatibility methods for http.client.HTTPResponse"]}, {"name": "urllib3.response.BaseHTTPResponse.getheader", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "default", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.info", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "HTTPHeaderDict", "xref": {"fqname": "urllib3.response._collections.HTTPHeaderDict", "project": null}, "params": null}, "documentation": ["Compatibility method for http.cookiejar"]}, {"name": "urllib3.response.BaseHTTPResponse.geturl", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": []}], "class_variables": [{"name": "urllib3.response.BaseHTTPResponse.CONTENT_DECODERS", "type": null, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.REDIRECT_STATUSES", "type": null, "documentation": []}, {"name": "urllib3.response.BaseHTTPResponse.DECODER_ERROR_CLASSES", "type": {"name": "tuple", "xref": {"fqname": "functions.tuple", "project": "--std--"}, "params": [{"name": "type", "xref": {"fqname": "functions.type", "project": "--std--"}, "params": [{"name": "Exception", "xref": {"fqname": "functions.Exception", "project": "--std--"}, "params": null}]}, {"name": "...", "xref": null, "params": null}]}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "urllib3.response.HTTPResponse", "bases": ["BaseHTTPResponse"], "methods": [{"name": "urllib3.response.HTTPResponse.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "body", "type": {"name": "_TYPE_BODY", "xref": {"fqname": "urllib3.response._base_connection._TYPE_BODY", "project": null}, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None", "xref": null, "params": null}, "default": "..."}, {"name": "status", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "version", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "version_string", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "reason", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "preload_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "original_response", "type": {"name": "_HttplibHTTPResponse | None", "xref": null, "params": null}, "default": "..."}, {"name": "pool", "type": {"name": "HTTPConnectionPool | None", "xref": null, "params": null}, "default": "..."}, {"name": "connection", "type": {"name": "HTTPConnection | None", "xref": null, "params": null}, "default": "..."}, {"name": "msg", "type": {"name": "_HttplibHTTPMessage | None", "xref": null, "params": null}, "default": "..."}, {"name": "retries", "type": {"name": "Retry | None", "xref": null, "params": null}, "default": "..."}, {"name": "enforce_content_length", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "request_method", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "request_url", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "auto_close", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "sock_shutdown", "type": {"name": "typing.Callable[[int], None] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.release_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.drain_conn", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Read and discard any remaining HTTP response data in the response connection.\n\nUnread data in the HTTPResponse connection blocks the connection from being released back to the pool."]}, {"name": "urllib3.response.HTTPResponse.data", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.connection", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "HTTPConnection | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.isclosed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.tell", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": ["Obtain the number of bytes pulled over the wire so far. May differ from\nthe amount of content returned by :meth:`urllib3.response.HTTPResponse.read`\nif bytes are encoded on the wire (e.g, compressed).\n"]}, {"name": "urllib3.response.HTTPResponse._init_length", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request_method", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "int | None", "xref": null, "params": null}, "documentation": ["Set initial length value for Response content if available."]}, {"name": "urllib3.response.HTTPResponse._error_catcher", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Generator", "xref": {"fqname": "typing.Generator", "project": "--std--"}, "params": [{"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}]}, "documentation": ["Catch low-level python exceptions, instead re-raising urllib3\nvariants, so that low-level exceptions are not leaked in the\nhigh-level api.\n\nOn exit, release the connection back to the pool."]}, {"name": "urllib3.response.HTTPResponse._fp_read", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "read1", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Read a response with the thought that reading the number of bytes\nlarger than can fit in a 32-bit int at a time via SSL in some\nknown cases leads to an overflow error that has to be prevented\nif `amt` or `self.length_remaining` indicate that a problem may\nhappen.\n\nThe known cases:\n  * CPython < 3.9.7 because of a bug\n    https://github.com/urllib3/urllib3/issues/2513#issuecomment-1152559900.\n  * urllib3 injected with pyOpenSSL-backed SSL-support.\n  * CPython < 3.10 only when `amt` does not fit 32-bit int."]}, {"name": "urllib3.response.HTTPResponse._raw_read", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "read1", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Reads `amt` of bytes from the socket."]}, {"name": "urllib3.response.HTTPResponse.read", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}, {"name": "cache_content", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Similar to {meth}`http.client.HTTPResponse.read`, but with two additional\nparameters: `decode_content` and `cache_content`.\n\n```\nparam amt\n\nHow much of the content to read. If specified, caching is skipped\nbecause it doesn't make sense to cache partial content as the full\nresponse.\n\nparam decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n\nparam cache_content\n\nIf True, will save the returned data such that the same result is\nreturned despite of the state of the underlying file object. This\nis useful if you want the .data property to continue working\nafter having .read() the file object. (Overridden if amt is\nset.)\n```\n"]}, {"name": "urllib3.response.HTTPResponse.read1", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": ["Similar to `http.client.HTTPResponse.read1` and documented\nin {meth}`io.BufferedReader.read1`, but with an additional parameter:\n`decode_content`.\n\n```\nparam amt\n\nHow much of the content to read.\n\nparam decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n```\n"]}, {"name": "urllib3.response.HTTPResponse.stream", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.Generator", "xref": {"fqname": "typing.Generator", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": ["A generator wrapper for the read() method. A call will block until\n`amt` bytes have been read from the connection or until the\nconnection is closed.\n\n```\nparam amt\n\nHow much of the content to read. The generator will return up to\nmuch data per iteration, but may return less. This is particularly\nlikely when using compressed data. However, the empty string will\nnever be returned.\n\nparam decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n```\n"]}, {"name": "urllib3.response.HTTPResponse.readable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Overrides from io.IOBase"]}, {"name": "urllib3.response.HTTPResponse.shutdown", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.closed", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.fileno", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.flush", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.supports_chunked_reads", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Checks if the underlying file-like object looks like a\n{class}`http.client.HTTPResponse` object. We do this by testing for\nthe fp attribute. If it is present we assume it returns raw chunks as\nprocessed by read_chunked().\n"]}, {"name": "urllib3.response.HTTPResponse._update_chunk_length", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse._handle_chunk", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.read_chunked", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "amt", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "decode_content", "type": {"name": "bool | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.Generator", "xref": {"fqname": "typing.Generator", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": ["Similar to {meth}`HTTPResponse.read`, but with an additional\nparameter: `decode_content`.\n\n```\nparam amt\n\nHow much of the content to read. If specified, caching is skipped\nbecause it doesn't make sense to cache partial content as the full\nresponse.\n\nparam decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n```\n"]}, {"name": "urllib3.response.HTTPResponse.url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "str | None", "xref": null, "params": null}, "documentation": ["Returns the URL that was the source of this response.\nIf the request that generated this response redirected, this method\nwill return the final redirect location."]}, {"name": "urllib3.response.HTTPResponse.url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.response.HTTPResponse.__iter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "typing.Iterator", "xref": {"fqname": "typing.Iterator", "project": "--std--"}, "params": [{"name": "bytes", "xref": {"fqname": "functions.bytes", "project": "--std--"}, "params": null}]}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["HTTP Response container.\n\nBackwards-compatible with {class}`http.client.HTTPResponse` but the response `body` is\nloaded and decoded on-demand when the `data` property is accessed. This\nclass is also compatible with the Python standard library's {mod}`io`\nmodule, and can hence be treated as a readable object in the context of that\nframework.\n\nExtra parameters for behaviour not present in {class}`http.client.HTTPResponse`:\n\n```\nparam preload_content\n\nIf True, the response's body will be preloaded during construction.\n\nparam decode_content\n\nIf True, will attempt to decode the body based on the\n'content-encoding' header.\n\nparam original_response\n\nWhen this HTTPResponse wrapper is generated from an \nobject, it's convenient to include the original for debug purposes. It's\notherwise unused.\n\nparam retries\n\nThe retries contains the last  that\nwas used during the request.\n\nparam enforce_content_length\n\nEnforce content length checking. Body returned by server must match\nvalue of Content-Length header, if present. Otherwise, raise error.\n```\n"]}], "exports": []}, {"name": "urllib3.poolmanager", "documentation": [], "functions": [{"name": "urllib3.poolmanager._default_key_normalizer", "asynchronous": false, "params": [{"name": "key_class", "type": {"name": "type", "xref": {"fqname": "functions.type", "project": "--std--"}, "params": [{"name": "PoolKey", "xref": {"fqname": "urllib3.poolmanager.PoolKey", "project": null}, "params": null}]}, "default": null}, {"name": "request_context", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "PoolKey", "xref": {"fqname": "urllib3.poolmanager.PoolKey", "project": null}, "params": null}, "documentation": ["Create a pool key out of a request context dictionary.\n\nAccording to RFC 3986, both the scheme and host are case-insensitive.\nTherefore, this function normalizes both before constructing the pool\nkey for an HTTPS request. If you wish to change this behaviour, provide\nalternate callables to `key_fn_by_scheme`.\n\n```\nparam key_class\n\nThe class to use when constructing the key. This should be a namedtuple\nwith the scheme and host keys at a minimum.\n\ntype  key_class\n\nnamedtuple\n\nparam request_context\n\nA dictionary-like object that contain the context for a request.\n\ntype  request_context\n\ndict\n\nreturn\n\nA namedtuple that can be used as a connection pool key.\n\nrtype\n\nPoolKey\n```\n"]}, {"name": "urllib3.poolmanager.proxy_from_url", "asynchronous": false, "params": [{"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "**kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "ProxyManager", "xref": {"fqname": "urllib3.poolmanager.ProxyManager", "project": null}, "params": null}, "documentation": []}], "variables": [{"name": "urllib3.poolmanager.log", "type": null, "documentation": []}, {"name": "urllib3.poolmanager.SSL_KEYWORDS", "type": null, "documentation": []}, {"name": "urllib3.poolmanager._DEFAULT_BLOCKSIZE", "type": null, "documentation": []}, {"name": "urllib3.poolmanager.key_fn_by_scheme", "type": null, "documentation": []}, {"name": "urllib3.poolmanager.pool_classes_by_scheme", "type": null, "documentation": []}], "classes": [{"name": "urllib3.poolmanager.PoolKey", "bases": ["typing.NamedTuple"], "methods": [], "class_variables": [{"name": "urllib3.poolmanager.PoolKey.key_scheme", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_port", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_timeout", "type": {"name": "Timeout | float | int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_retries", "type": {"name": "Retry | bool | int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_block", "type": {"name": "bool | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_source_address", "type": {"name": "tuple[str, int] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_key_file", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_key_password", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_cert_file", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_cert_reqs", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_ca_certs", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_ca_cert_data", "type": {"name": "str | bytes | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_ssl_version", "type": {"name": "int | str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_ssl_minimum_version", "type": {"name": "ssl.TLSVersion | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_ssl_maximum_version", "type": {"name": "ssl.TLSVersion | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_ca_cert_dir", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_maxsize", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_headers", "type": {"name": "frozenset[tuple[str, str]] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key__proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key__proxy_headers", "type": {"name": "frozenset[tuple[str, str]] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key__proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_socket_options", "type": {"name": "_TYPE_SOCKET_OPTIONS | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key__socks_options", "type": {"name": "frozenset[tuple[str, str]] | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_assert_hostname", "type": {"name": "bool | str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_server_hostname", "type": {"name": "str | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolKey.key_blocksize", "type": {"name": "int | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["All known keyword arguments that could be provided to the pool manager, its\npools, or the underlying connections.\n\nAll custom key schemes should include the fields in this key at a minimum."]}, {"name": "urllib3.poolmanager.PoolManager", "bases": ["RequestMethods"], "methods": [{"name": "urllib3.poolmanager.PoolManager.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "num_pools", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "**connection_pool_kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolManager.__enter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "Self", "xref": {"fqname": "typing_extensions.Self", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolManager.__exit__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "exc_type", "type": {"name": "type[BaseException] | None", "xref": null, "params": null}, "default": null}, {"name": "exc_val", "type": {"name": "BaseException | None", "xref": null, "params": null}, "default": null}, {"name": "exc_tb", "type": {"name": "TracebackType | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "typing.Literal", "xref": {"fqname": "typing.Literal", "project": "--std--"}, "params": [{"name": "False", "xref": null, "params": null}]}, "documentation": []}, {"name": "urllib3.poolmanager.PoolManager._new_pool", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "scheme", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "host", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "port", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": null}, {"name": "request_context", "type": {"name": "dict[str, typing.Any] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "HTTPConnectionPool", "xref": {"fqname": "urllib3.poolmanager.connectionpool.HTTPConnectionPool", "project": null}, "params": null}, "documentation": ["Create a new {class}`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\nany additional pool keyword arguments.\n\nIf `request_context` is provided, it is provided as keyword arguments\nto the pool class used. This method is used to actually create the\nconnection pools handed out by {meth}`connection_from_url` and\ncompanion methods. It is intended to be overridden for customization.\n"]}, {"name": "urllib3.poolmanager.PoolManager.clear", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": ["Empty our store of pools and direct them all to close.\n\nThis will not affect in-flight connections, but they will not be\nre-used after completion."]}, {"name": "urllib3.poolmanager.PoolManager.connection_from_host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "pool_kwargs", "type": {"name": "dict[str, typing.Any] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "HTTPConnectionPool", "xref": {"fqname": "urllib3.poolmanager.connectionpool.HTTPConnectionPool", "project": null}, "params": null}, "documentation": ["Get a {class}`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\nIf `port` isn't given, it will be derived from the `scheme` using\n`urllib3.connectionpool.port_by_scheme`. If `pool_kwargs` is\nprovided, it is merged with the instance's `connection_pool_kw`\nvariable and used to create the new connection pool, if one is\nneeded.\n"]}, {"name": "urllib3.poolmanager.PoolManager.connection_from_context", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request_context", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "HTTPConnectionPool", "xref": {"fqname": "urllib3.poolmanager.connectionpool.HTTPConnectionPool", "project": null}, "params": null}, "documentation": ["Get a {class}`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n`request_context` must at least contain the `scheme` key and its\nvalue must be a key in `key_fn_by_scheme` instance variable.\n"]}, {"name": "urllib3.poolmanager.PoolManager.connection_from_pool_key", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "pool_key", "type": {"name": "PoolKey", "xref": {"fqname": "urllib3.poolmanager.PoolKey", "project": null}, "params": null}, "default": null}, {"name": "request_context", "type": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}]}, "default": null}], "returns": {"name": "HTTPConnectionPool", "xref": {"fqname": "urllib3.poolmanager.connectionpool.HTTPConnectionPool", "project": null}, "params": null}, "documentation": ["Get a {class}`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n`pool_key` should be a namedtuple that only contains immutable\nobjects. At a minimum it must have the `scheme`, `host`, and\n`port` fields.\n"]}, {"name": "urllib3.poolmanager.PoolManager.connection_from_url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "pool_kwargs", "type": {"name": "dict[str, typing.Any] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "HTTPConnectionPool", "xref": {"fqname": "urllib3.poolmanager.connectionpool.HTTPConnectionPool", "project": null}, "params": null}, "documentation": ["Similar to {func}`urllib3.connectionpool.connection_from_url`.\n\nIf `pool_kwargs` is not provided and a new pool needs to be\nconstructed, `self.connection_pool_kw` is used to initialize\nthe {class}`urllib3.connectionpool.ConnectionPool`. If `pool_kwargs`\nis provided, it is used instead. Note that if a new pool does not\nneed to be created for the request, the provided `pool_kwargs` are\nnot used.\n"]}, {"name": "urllib3.poolmanager.PoolManager._merge_pool_kwargs", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "override", "type": {"name": "dict[str, typing.Any] | None", "xref": null, "params": null}, "default": null}], "returns": {"name": "dict", "xref": {"fqname": "functions.dict", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}]}, "documentation": ["Merge a dictionary of override values for self.connection_pool_kw.\n\nThis does not modify self.connection_pool_kw and returns a new dict.\nAny keys in the override dictionary with a value of `None` are\nremoved from the merged dictionary.\n"]}, {"name": "urllib3.poolmanager.PoolManager._proxy_requires_url_absolute_form", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "parsed_url", "type": {"name": "Url", "xref": {"fqname": "urllib3.poolmanager.util.url.Url", "project": null}, "params": null}, "default": null}], "returns": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "documentation": ["Indicates if the proxy requires the complete destination URL in the\nrequest.  Normally this is only needed when not using an HTTP CONNECT\ntunnel."]}, {"name": "urllib3.poolmanager.PoolManager.urlopen", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "redirect", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "**kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.poolmanager.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": ["Same as {meth}`urllib3.HTTPConnectionPool.urlopen`\nwith custom cross-host redirect logic and only sends the request-uri\nportion of the `url`.\n\nThe given `url` parameter must be absolute, such that an appropriate\n{class}`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n"]}], "class_variables": [{"name": "urllib3.poolmanager.PoolManager.proxy", "type": {"name": "Url | None", "xref": null, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.PoolManager.proxy_config", "type": {"name": "ProxyConfig | None", "xref": null, "params": null}, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["Allows for arbitrary requests while transparently keeping track of\nnecessary connection pools for you.\n\n```\nparam num_pools\n\nNumber of connection pools to cache before discarding the least\nrecently used pool.\n\nparam headers\n\nHeaders to include with all requests, unless other headers are given\nexplicitly.\n\nparam **connection_pool_kw\n\nAdditional parameters are used to create fresh\n instances.\n```\n\nExample:\n\n```python\nimport urllib3\n\nhttp = urllib3.PoolManager(num_pools=2)\n\nresp1 = http.request(\"GET\", \"https://google.com/\")\nresp2 = http.request(\"GET\", \"https://google.com/mail\")\nresp3 = http.request(\"GET\", \"https://yahoo.com/\")\n\nprint(len(http.pools))\n# 2\n```\n"]}, {"name": "urllib3.poolmanager.ProxyManager", "bases": ["PoolManager"], "methods": [{"name": "urllib3.poolmanager.ProxyManager.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "proxy_url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "num_pools", "type": {"name": "int", "xref": {"fqname": "functions.int", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_ssl_context", "type": {"name": "ssl.SSLContext | None", "xref": null, "params": null}, "default": "..."}, {"name": "use_forwarding_for_https", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "proxy_assert_hostname", "type": {"name": "None | str | typing.Literal[False]", "xref": null, "params": null}, "default": "..."}, {"name": "proxy_assert_fingerprint", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "**connection_pool_kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "None", "xref": {"fqname": "constants.None", "project": "--std--"}, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.ProxyManager.connection_from_host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "host", "type": {"name": "str | None", "xref": null, "params": null}, "default": null}, {"name": "port", "type": {"name": "int | None", "xref": null, "params": null}, "default": "..."}, {"name": "scheme", "type": {"name": "str | None", "xref": null, "params": null}, "default": "..."}, {"name": "pool_kwargs", "type": {"name": "dict[str, typing.Any] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "HTTPConnectionPool", "xref": {"fqname": "urllib3.poolmanager.connectionpool.HTTPConnectionPool", "project": null}, "params": null}, "documentation": []}, {"name": "urllib3.poolmanager.ProxyManager._set_proxy_headers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "headers", "type": {"name": "typing.Mapping[str, str] | None", "xref": null, "params": null}, "default": "..."}], "returns": {"name": "typing.Mapping", "xref": {"fqname": "typing.Mapping", "project": "--std--"}, "params": [{"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}]}, "documentation": ["Sets headers needed by proxies: specifically, the Accept and Host\nheaders. Only sets headers not provided by the user."]}, {"name": "urllib3.poolmanager.ProxyManager.urlopen", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "url", "type": {"name": "str", "xref": {"fqname": "functions.str", "project": "--std--"}, "params": null}, "default": null}, {"name": "redirect", "type": {"name": "bool", "xref": {"fqname": "functions.bool", "project": "--std--"}, "params": null}, "default": "..."}, {"name": "**kw", "type": {"name": "typing.Any", "xref": {"fqname": "typing.Any", "project": "--std--"}, "params": null}, "default": null}], "returns": {"name": "BaseHTTPResponse", "xref": {"fqname": "urllib3.poolmanager.response.BaseHTTPResponse", "project": null}, "params": null}, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Behaves just like {class}`PoolManager`, but sends all requests through\nthe defined proxy, using the CONNECT method for HTTPS URLs.\n\n```\nparam proxy_url\n\nThe URL of the proxy to be used.\n\nparam proxy_headers\n\nA dictionary containing headers that will be sent to the proxy. In case\nof HTTP they are being sent with each request, while in the\nHTTPS/CONNECT case they are sent only once. Could be used for proxy\nauthentication.\n\nparam proxy_ssl_context\n\nThe proxy SSL context is used to establish the TLS connection to the\nproxy when using HTTPS proxies.\n\nparam use_forwarding_for_https\n\n(Defaults to False) If set to True will forward requests to the HTTPS\nproxy to be made on behalf of the client instead of creating a TLS\ntunnel via the CONNECT method. Enabling this flag means that request\nand response headers and content will be visible from the HTTPS proxy\nwhereas tunneling keeps request and response headers and content\nprivate.  IP address, target hostname, SNI, and port are always visible\nto an HTTPS proxy even when this flag is disabled.\n\nparam proxy_assert_hostname\n\nThe hostname of the certificate to verify against.\n\nparam proxy_assert_fingerprint\n\nThe fingerprint of the certificate to verify against.\n```\n\nExample:\n\n```python\nimport urllib3\n\nproxy = urllib3.ProxyManager(\"https://localhost:3128/\")\n\nresp1 = proxy.request(\"GET\", \"https://google.com/\")\nresp2 = proxy.request(\"GET\", \"https://httpbin.org/\")\n\nprint(len(proxy.pools))\n# 1\n\nresp3 = proxy.request(\"GET\", \"https://httpbin.org/\")\nresp4 = proxy.request(\"GET\", \"https://twitter.com/\")\n\nprint(len(proxy.pools))\n# 3\n```\n"]}], "exports": [{"name": "urllib3.poolmanager.PoolManager", "xref": {"fqname": "urllib3.poolmanager.PoolManager", "project": null}}, {"name": "urllib3.poolmanager.proxy_from_url", "xref": {"fqname": "urllib3.poolmanager.proxy_from_url", "project": null}}, {"name": "urllib3.poolmanager.ProxyManager", "xref": {"fqname": "urllib3.poolmanager.ProxyManager", "project": null}}]}]}