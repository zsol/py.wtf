{"name": "requests", "metadata": {"name": "requests", "version": "2.32.3", "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3 :: Only", "Programming Language :: Python :: 3.10", "Programming Language :: Python :: 3.11", "Programming Language :: Python :: 3.12", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3.9", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development :: Libraries"], "home_page": "https://requests.readthedocs.io", "license": "Apache-2.0", "documentation_url": "https://requests.readthedocs.io", "dependencies": ["charset-normalizer", "idna", "urllib3", "certifi"], "summary": "Python HTTP for Humans.", "upload_time": 1716997067}, "documentation": ["# Requests\n\n**Requests** is a simple, yet elegant, HTTP library.\n\n```python\n>>> import requests\n>>> r = requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass'))\n>>> r.status_code\n200\n>>> r.headers['content-type']\n'application/json; charset=utf8'\n>>> r.encoding\n'utf-8'\n>>> r.text\n'{\"authenticated\": true, ...'\n>>> r.json()\n{'authenticated': True, ...}\n```\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There\u2019s no need to manually add query strings to your URLs, or to form-encode your `PUT` & `POST` data \u2014 but nowadays, just use the `json` method!\n\nRequests is one of the most downloaded Python packages today, pulling in around `30M downloads / week`\u2014 according to GitHub, Requests is currently [depended upon](https://github.com/psf/requests/network/dependents?package_id=UGFja2FnZS01NzA4OTExNg%3D%3D) by `1,000,000+` repositories. You may certainly put your trust in this code.\n\n[![Downloads](https://static.pepy.tech/badge/requests/month)](https://pepy.tech/project/requests)\n[![Supported Versions](https://img.shields.io/pypi/pyversions/requests.svg)](https://pypi.org/project/requests)\n[![Contributors](https://img.shields.io/github/contributors/psf/requests.svg)](https://github.com/psf/requests/graphs/contributors)\n\n## Installing Requests and Supported Versions\n\nRequests is available on PyPI:\n\n```console\n$ python -m pip install requests\n```\n\nRequests officially supports Python 3.8+.\n\n## Supported Features & Best\u2013Practices\n\nRequests is ready for the demands of building robust and reliable HTTP\u2013speaking applications, for the needs of today.\n\n- Keep-Alive & Connection Pooling\n- International Domains and URLs\n- Sessions with Cookie Persistence\n- Browser-style TLS/SSL Verification\n- Basic & Digest Authentication\n- Familiar `dict`\u2013like Cookies\n- Automatic Content Decompression and Decoding\n- Multi-part File Uploads\n- SOCKS Proxy Support\n- Connection Timeouts\n- Streaming Downloads\n- Automatic honoring of `.netrc`\n- Chunked HTTP Requests\n\n## API Reference and User Guide available on [Read the Docs](https://requests.readthedocs.io)\n\n[![Read the Docs](https://raw.githubusercontent.com/psf/requests/main/ext/ss.png)](https://requests.readthedocs.io)\n\n## Cloning the repository\n\nWhen cloning the Requests repository, you may need to add the `-c\nfetch.fsck.badTimezone=ignore` flag to avoid an error about a bad commit (see\n[this issue](https://github.com/psf/requests/issues/2690) for more background):\n\n```shell\ngit clone -c fetch.fsck.badTimezone=ignore https://github.com/psf/requests.git\n```\n\nYou can also apply this setting to your global Git config:\n\n```shell\ngit config --global fetch.fsck.badTimezone ignore\n```\n\n---\n\n[![Kenneth Reitz](https://raw.githubusercontent.com/psf/requests/main/ext/kr.png)](https://kennethreitz.org) [![Python Software Foundation](https://raw.githubusercontent.com/psf/requests/main/ext/psf.png)](https://www.python.org/psf)\n"], "modules": [{"name": "requests.certs", "documentation": ["requests.certs\n~~~~~~~~~~~~~~\n\nThis module returns the preferred default CA certificate bundle. There is\nonly one \u2014 the one from the certifi package.\n\nIf you are packaging Requests, e.g., for a Linux distribution or a managed\nenvironment, you can change the definition of where() to return a separately\npackaged CA bundle.", "!/usr/bin/env python"], "functions": [], "variables": [], "classes": [], "exports": []}, {"name": "requests.packages", "documentation": [], "functions": [], "variables": [{"name": "requests.packages.target", "type": null, "documentation": []}, {"name": "requests.packages.imported_mod", "type": null, "documentation": []}, {"name": "requests.packages.mod", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "requests.__version__", "documentation": [".-. .-. .-. . . .-. .-. .-. .-.", "|(  |-  |.| | | |-  `-.  |  `-.", "' ' `-' `-`.`-' `-' `-'  '  `-'"], "functions": [], "variables": [{"name": "requests.__version__.__title__", "type": null, "documentation": []}, {"name": "requests.__version__.__description__", "type": null, "documentation": []}, {"name": "requests.__version__.__url__", "type": null, "documentation": []}, {"name": "requests.__version__.__version__", "type": null, "documentation": []}, {"name": "requests.__version__.__build__", "type": null, "documentation": []}, {"name": "requests.__version__.__author__", "type": null, "documentation": []}, {"name": "requests.__version__.__author_email__", "type": null, "documentation": []}, {"name": "requests.__version__.__license__", "type": null, "documentation": []}, {"name": "requests.__version__.__copyright__", "type": null, "documentation": []}, {"name": "requests.__version__.__cake__", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "requests.compat", "documentation": ["requests.compat\n~~~~~~~~~~~~~~~\n\nThis module previously handled import compatibility issues\nbetween Python 2 and Python 3. It remains for backwards\ncompatibility until the next major version."], "functions": [{"name": "requests.compat._resolve_char_detection", "asynchronous": false, "params": [], "returns": null, "documentation": ["Find supported character detection libraries.", "-------------------", "Character Detection", "-------------------"]}], "variables": [{"name": "requests.compat.chardet", "type": null, "documentation": []}, {"name": "requests.compat._ver", "type": null, "documentation": []}, {"name": "requests.compat.is_py2", "type": null, "documentation": []}, {"name": "requests.compat.is_py3", "type": null, "documentation": []}, {"name": "requests.compat.has_simplejson", "type": null, "documentation": []}, {"name": "requests.compat.has_simplejson", "type": null, "documentation": []}, {"name": "requests.compat.builtin_str", "type": null, "documentation": []}, {"name": "requests.compat.str", "type": null, "documentation": []}, {"name": "requests.compat.bytes", "type": null, "documentation": []}, {"name": "requests.compat.basestring", "type": null, "documentation": []}, {"name": "requests.compat.numeric_types", "type": null, "documentation": []}, {"name": "requests.compat.integer_types", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "requests.hooks", "documentation": ["# requests.hooks\n\nThis module provides the capabilities for the Requests hooks system.\n\nAvailable hooks:\n\n`response`:\n\n: The response generated from a Request.\n"], "functions": [{"name": "requests.hooks.default_hooks", "asynchronous": false, "params": [], "returns": null, "documentation": []}, {"name": "requests.hooks.dispatch_hook", "asynchronous": false, "params": [{"name": "key", "type": null, "default": null}, {"name": "hooks", "type": null, "default": null}, {"name": "hook_data", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Dispatches a hook dictionary on a given piece of data.", "TODO: response is the only one"]}], "variables": [{"name": "requests.hooks.HOOKS", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "requests._internal_utils", "documentation": ["requests._internal_utils\n~~~~~~~~~~~~~~\n\nProvides utility functions that are consumed internally by Requests\nwhich depend on extremely few external helpers (such as compat)"], "functions": [{"name": "requests._internal_utils.to_native_string", "asynchronous": false, "params": [{"name": "string", "type": null, "default": null}, {"name": "encoding", "type": null, "default": "..."}], "returns": null, "documentation": ["Given a string object, regardless of type, returns a representation of\nthat string in the native string type, encoding and decoding where\nnecessary. This assumes ASCII unless told otherwise."]}, {"name": "requests._internal_utils.unicode_is_ascii", "asynchronous": false, "params": [{"name": "u_string", "type": null, "default": null}], "returns": null, "documentation": ["Determine if unicode string only contains ASCII characters.\n\n```\nparam str u_string\n\nunicode string to check. Must be unicode\nand not Python 2 .\n\nrtype\n\nbool\n```\n"]}], "variables": [{"name": "requests._internal_utils._VALID_HEADER_NAME_RE_BYTE", "type": null, "documentation": []}, {"name": "requests._internal_utils._VALID_HEADER_NAME_RE_STR", "type": null, "documentation": []}, {"name": "requests._internal_utils._VALID_HEADER_VALUE_RE_BYTE", "type": null, "documentation": []}, {"name": "requests._internal_utils._VALID_HEADER_VALUE_RE_STR", "type": null, "documentation": []}, {"name": "requests._internal_utils._HEADER_VALIDATORS_STR", "type": null, "documentation": []}, {"name": "requests._internal_utils._HEADER_VALIDATORS_BYTE", "type": null, "documentation": []}, {"name": "requests._internal_utils.HEADER_VALIDATORS", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "requests.help", "documentation": ["Module containing bug report helper(s)."], "functions": [{"name": "requests.help._implementation", "asynchronous": false, "params": [], "returns": null, "documentation": ["Return a dict with the Python implementation and version.\n\nProvide both the name and the version of the Python implementation\ncurrently running. For example, on CPython 3.10.3 it will return\n{'name': 'CPython', 'version': '3.10.3'}.\n\nThis function works best on CPython and PyPy: in particular, it probably\ndoesn't work for Jython or IronPython. Future investigation should be done\nto work out the correct shape of the code for those platforms."]}, {"name": "requests.help.info", "asynchronous": false, "params": [], "returns": null, "documentation": ["Generate information for a bug report."]}, {"name": "requests.help.main", "asynchronous": false, "params": [], "returns": null, "documentation": ["Pretty-print the bug information as JSON."]}], "variables": [{"name": "requests.help.charset_normalizer", "type": null, "documentation": []}, {"name": "requests.help.chardet", "type": null, "documentation": []}, {"name": "requests.help.pyopenssl", "type": null, "documentation": []}, {"name": "requests.help.OpenSSL", "type": null, "documentation": []}, {"name": "requests.help.cryptography", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "requests", "documentation": ["Requests HTTP Library\n~~~~~~~~~~~~~~~~~~~~~\n\nRequests is an HTTP library, written in Python, for human beings.\nBasic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n   True\n\n... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n     \"form\": {\n       \"key1\": \"value1\",\n       \"key2\": \"value2\"\n     },\n     ...\n   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.", "__", "/__)  _  _     _   _ _/   _", "/ (   (- (/ (/ (- _)  /  _)", "/"], "functions": [{"name": "requests.check_compatibility", "asynchronous": false, "params": [{"name": "urllib3_version", "type": null, "default": null}, {"name": "chardet_version", "type": null, "default": null}, {"name": "charset_normalizer_version", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests._check_cryptography", "asynchronous": false, "params": [{"name": "cryptography_version", "type": null, "default": null}], "returns": null, "documentation": []}], "variables": [{"name": "requests.charset_normalizer_version", "type": null, "documentation": []}, {"name": "requests.chardet_version", "type": null, "documentation": []}, {"name": "requests.ssl", "type": null, "documentation": []}], "classes": [], "exports": [{"name": "requests.__author__", "xref": {"fqname": "requests.__version__.__author__", "project": null}}, {"name": "requests.__author_email__", "xref": {"fqname": "requests.__version__.__author_email__", "project": null}}, {"name": "requests.__build__", "xref": {"fqname": "requests.__version__.__build__", "project": null}}, {"name": "requests.__cake__", "xref": {"fqname": "requests.__version__.__cake__", "project": null}}, {"name": "requests.__copyright__", "xref": {"fqname": "requests.__version__.__copyright__", "project": null}}, {"name": "requests.__description__", "xref": {"fqname": "requests.__version__.__description__", "project": null}}, {"name": "requests.__license__", "xref": {"fqname": "requests.__version__.__license__", "project": null}}, {"name": "requests.__title__", "xref": {"fqname": "requests.__version__.__title__", "project": null}}, {"name": "requests.__url__", "xref": {"fqname": "requests.__version__.__url__", "project": null}}, {"name": "requests.__version__", "xref": {"fqname": "requests.__version__.__version__", "project": null}}, {"name": "requests.chardet_version", "xref": {"fqname": "chardet.__version__", "project": null}}, {"name": "requests.charset_normalizer_version", "xref": {"fqname": "charset_normalizer.__version__", "project": "charset-normalizer"}}, {"name": "requests.codes", "xref": {"fqname": "requests.status_codes.codes", "project": null}}, {"name": "requests.ConnectionError", "xref": {"fqname": "requests.exceptions.ConnectionError", "project": null}}, {"name": "requests.ConnectTimeout", "xref": {"fqname": "requests.exceptions.ConnectTimeout", "project": null}}, {"name": "requests.cryptography_version", "xref": {"fqname": "cryptography.__version__", "project": null}}, {"name": "requests.delete", "xref": {"fqname": "requests.api.delete", "project": null}}, {"name": "requests.DependencyWarning", "xref": {"fqname": "urllib3.exceptions.DependencyWarning", "project": "urllib3"}}, {"name": "requests.FileModeWarning", "xref": {"fqname": "requests.exceptions.FileModeWarning", "project": null}}, {"name": "requests.get", "xref": {"fqname": "requests.api.get", "project": null}}, {"name": "requests.head", "xref": {"fqname": "requests.api.head", "project": null}}, {"name": "requests.HTTPError", "xref": {"fqname": "requests.exceptions.HTTPError", "project": null}}, {"name": "requests.JSONDecodeError", "xref": {"fqname": "requests.exceptions.JSONDecodeError", "project": null}}, {"name": "requests.NullHandler", "xref": {"fqname": "logging.NullHandler", "project": null}}, {"name": "requests.options", "xref": {"fqname": "requests.api.options", "project": null}}, {"name": "requests.packages", "xref": {"fqname": "requests..packages", "project": null}}, {"name": "requests.patch", "xref": {"fqname": "requests.api.patch", "project": null}}, {"name": "requests.post", "xref": {"fqname": "requests.api.post", "project": null}}, {"name": "requests.PreparedRequest", "xref": {"fqname": "requests.models.PreparedRequest", "project": null}}, {"name": "requests.put", "xref": {"fqname": "requests.api.put", "project": null}}, {"name": "requests.pyopenssl", "xref": {"fqname": "urllib3.contrib.pyopenssl", "project": "urllib3"}}, {"name": "requests.ReadTimeout", "xref": {"fqname": "requests.exceptions.ReadTimeout", "project": null}}, {"name": "requests.request", "xref": {"fqname": "requests.api.request", "project": null}}, {"name": "requests.Request", "xref": {"fqname": "requests.models.Request", "project": null}}, {"name": "requests.RequestException", "xref": {"fqname": "requests.exceptions.RequestException", "project": null}}, {"name": "requests.RequestsDependencyWarning", "xref": {"fqname": "requests.exceptions.RequestsDependencyWarning", "project": null}}, {"name": "requests.Response", "xref": {"fqname": "requests.models.Response", "project": null}}, {"name": "requests.Session", "xref": {"fqname": "requests.sessions.Session", "project": null}}, {"name": "requests.session", "xref": {"fqname": "requests.sessions.session", "project": null}}, {"name": "requests.Timeout", "xref": {"fqname": "requests.exceptions.Timeout", "project": null}}, {"name": "requests.TooManyRedirects", "xref": {"fqname": "requests.exceptions.TooManyRedirects", "project": null}}, {"name": "requests.URLRequired", "xref": {"fqname": "requests.exceptions.URLRequired", "project": null}}, {"name": "requests.utils", "xref": {"fqname": "requests..utils", "project": null}}]}, {"name": "requests.exceptions", "documentation": ["requests.exceptions\n~~~~~~~~~~~~~~~~~~~\n\nThis module contains the set of Requests' exceptions."], "functions": [], "variables": [], "classes": [{"name": "requests.exceptions.RequestException", "bases": ["IOError"], "methods": [{"name": "requests.exceptions.RequestException.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*args", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Initialize RequestException with `request` and `response` objects."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["There was an ambiguous exception that occurred while handling your\nrequest."]}, {"name": "requests.exceptions.InvalidJSONError", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A JSON error occurred."]}, {"name": "requests.exceptions.JSONDecodeError", "bases": ["InvalidJSONError", "CompatJSONDecodeError"], "methods": [{"name": "requests.exceptions.JSONDecodeError.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*args", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Construct the JSONDecodeError instance first with all\nargs. Then use it's args to construct the IOError so that\nthe json specific args aren't used as IOError specific args\nand the error message from JSONDecodeError is preserved."]}, {"name": "requests.exceptions.JSONDecodeError.__reduce__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["The __reduce__ method called when pickling the object must\nbe the one from the JSONDecodeError (be it json/simplejson)\nas it expects all the arguments for instantiation, not just\none like the IOError, and the MRO would by default call the\n__reduce__ method from the IOError due to the inheritance order."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Couldn't decode the text into json"]}, {"name": "requests.exceptions.HTTPError", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["An HTTP error occurred."]}, {"name": "requests.exceptions.ConnectionError", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A Connection error occurred."]}, {"name": "requests.exceptions.ProxyError", "bases": ["ConnectionError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A proxy error occurred."]}, {"name": "requests.exceptions.SSLError", "bases": ["ConnectionError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["An SSL error occurred."]}, {"name": "requests.exceptions.Timeout", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The request timed out.\n\nCatching this error will catch both\n{exc}`~requests.exceptions.ConnectTimeout` and\n{exc}`~requests.exceptions.ReadTimeout` errors.\n"]}, {"name": "requests.exceptions.ConnectTimeout", "bases": ["ConnectionError", "Timeout"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The request timed out while trying to connect to the remote server.\n\nRequests that produced this error are safe to retry."]}, {"name": "requests.exceptions.ReadTimeout", "bases": ["Timeout"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The server did not send any data in the allotted amount of time."]}, {"name": "requests.exceptions.URLRequired", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A valid URL is required to make a request."]}, {"name": "requests.exceptions.TooManyRedirects", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Too many redirects."]}, {"name": "requests.exceptions.MissingSchema", "bases": ["RequestException", "ValueError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The URL scheme (e.g. http or https) is missing."]}, {"name": "requests.exceptions.InvalidSchema", "bases": ["RequestException", "ValueError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The URL scheme provided is either invalid or unsupported."]}, {"name": "requests.exceptions.InvalidURL", "bases": ["RequestException", "ValueError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The URL provided was somehow invalid."]}, {"name": "requests.exceptions.InvalidHeader", "bases": ["RequestException", "ValueError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The header value provided was somehow invalid."]}, {"name": "requests.exceptions.InvalidProxyURL", "bases": ["InvalidURL"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The proxy URL provided is invalid."]}, {"name": "requests.exceptions.ChunkedEncodingError", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The server declared chunked encoding but sent an invalid chunk."]}, {"name": "requests.exceptions.ContentDecodingError", "bases": ["RequestException", "BaseHTTPError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Failed to decode response content."]}, {"name": "requests.exceptions.StreamConsumedError", "bases": ["RequestException", "TypeError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The content for this response was already consumed."]}, {"name": "requests.exceptions.RetryError", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Custom retries logic failed"]}, {"name": "requests.exceptions.UnrewindableBodyError", "bases": ["RequestException"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Requests encountered an error when trying to rewind a body."]}, {"name": "requests.exceptions.RequestsWarning", "bases": ["Warning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Base warning for Requests.", "Warnings"]}, {"name": "requests.exceptions.FileModeWarning", "bases": ["RequestsWarning", "DeprecationWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A file was opened in text mode, but Requests determined its binary length."]}, {"name": "requests.exceptions.RequestsDependencyWarning", "bases": ["RequestsWarning"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["An imported dependency doesn't match the expected version range."]}], "exports": []}, {"name": "requests.status_codes", "documentation": ["The `codes` object defines a mapping from common names for HTTP statuses\nto their numerical codes, accessible either as attributes or as dictionary\nitems.\n\nExample:\n\n```\n>>> import requests\n>>> requests.codes['temporary_redirect']\n307\n>>> requests.codes.teapot\n418\n>>> requests.codes['\\o/']\n200\n```\n\nSome codes have multiple names, and both upper- and lower-case versions of\nthe names are allowed. For example, `codes.ok`, `codes.OK`, and\n`codes.okay` all correspond to the HTTP status code 200.\n"], "functions": [{"name": "requests.status_codes._init", "asynchronous": false, "params": [], "returns": null, "documentation": []}], "variables": [{"name": "requests.status_codes._codes", "type": null, "documentation": []}, {"name": "requests.status_codes.codes", "type": null, "documentation": []}], "classes": [], "exports": []}, {"name": "requests.structures", "documentation": ["requests.structures\n~~~~~~~~~~~~~~~~~~~\n\nData structures that power Requests."], "functions": [], "variables": [], "classes": [{"name": "requests.structures.CaseInsensitiveDict", "bases": ["MutableMapping"], "methods": [{"name": "requests.structures.CaseInsensitiveDict.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.CaseInsensitiveDict.__setitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": null, "default": null}, {"name": "value", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.CaseInsensitiveDict.__getitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.CaseInsensitiveDict.__delitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.CaseInsensitiveDict.__iter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.CaseInsensitiveDict.__len__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.CaseInsensitiveDict.lower_items", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Like iteritems(), but with all lowercase keys."]}, {"name": "requests.structures.CaseInsensitiveDict.__eq__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.CaseInsensitiveDict.copy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Copy is required"]}, {"name": "requests.structures.CaseInsensitiveDict.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A case-insensitive `dict`-like object.\n\nImplements all methods and operations of\n`MutableMapping` as well as dict's `copy`. Also\nprovides `lower_items`.\n\nAll keys are expected to be strings. The structure remembers the\ncase of the last key to be set, and `iter(instance)`,\n`keys()`, `items()`, `iterkeys()`, and `iteritems()`\nwill contain case-sensitive keys. However, querying and contains\ntesting is case insensitive:\n\n```\ncid = CaseInsensitiveDict()\ncid['Accept'] = 'application/json'\ncid['aCCEPT'] == 'application/json'  # True\nlist(cid) == ['Accept']  # True\n```\n\nFor example, `headers['content-encoding']` will return the\nvalue of a `'Content-Encoding'` response header, regardless\nof how the header name was originally stored.\n\nIf the constructor, `.update`, or equality comparison\noperations are given keys that have equal .lower()\\`\\`s, the\nbehavior is undefined.\n"]}, {"name": "requests.structures.LookupDict", "bases": ["dict"], "methods": [{"name": "requests.structures.LookupDict.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": "..."}], "returns": null, "documentation": []}, {"name": "requests.structures.LookupDict.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.LookupDict.__getitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.structures.LookupDict.get", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": null, "default": null}, {"name": "default", "type": null, "default": "..."}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Dictionary lookup object."]}], "exports": []}, {"name": "requests.api", "documentation": ["requests.api\n~~~~~~~~~~~~\n\nThis module implements the Requests API.\n\n:copyright: (c) 2012 by Kenneth Reitz.\n:license: Apache2, see LICENSE for more details."], "functions": [{"name": "requests.api.request", "asynchronous": false, "params": [{"name": "method", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Constructs and sends a {class}`Request <Request>`.\n\n```\nparam method\n\nmethod for the new  object: GET, OPTIONS, HEAD, POST, PUT, PATCH, or DELETE.\n\nparam url\n\nURL for the new  object.\n\nparam params\n\n(optional) Dictionary, list of tuples or bytes to send\nin the query string for the .\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam json\n\n(optional) A JSON serializable Python object to send in the body of the .\n\nparam headers\n\n(optional) Dictionary of HTTP Headers to send with the .\n\nparam cookies\n\n(optional) Dict or CookieJar object to send with the .\n\nparam files\n\n(optional) Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.\nfile-tuple can be a 2-tuple ('filename', fileobj), 3-tuple ('filename', fileobj, 'content_type')\nor a 4-tuple ('filename', fileobj, 'content_type', custom_headers), where 'content_type' is a string\ndefining the content type of the given file and custom_headers a dict-like object containing additional headers\nto add for the file.\n\nparam auth\n\n(optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n\nparam timeout\n\n(optional) How many seconds to wait for the server to send data\nbefore giving up, as a float, or a  tuple.\n\ntype timeout\n\nfloat or tuple\n\nparam allow_redirects\n\n(optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to True.\n\ntype allow_redirects\n\nbool\n\nparam proxies\n\n(optional) Dictionary mapping protocol to the URL of the proxy.\n\nparam verify\n\n(optional) Either a boolean, in which case it controls whether we verify\nthe server's TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use. Defaults to True.\n\nparam stream\n\n(optional) if False, the response content will be immediately downloaded.\n\nparam cert\n\n(optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n\nUsage:\n\n```\n>>> import requests\n>>> req = requests.request('GET', 'https://httpbin.org/get')\n>>> req\n<Response [200]>\n```\n"]}, {"name": "requests.api.get", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "params", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a GET request.\n\n```\nparam url\n\nURL for the new  object.\n\nparam params\n\n(optional) Dictionary, list of tuples or bytes to send\nin the query string for the .\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.api.options", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends an OPTIONS request.\n\n```\nparam url\n\nURL for the new  object.\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.api.head", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a HEAD request.\n\n```\nparam url\n\nURL for the new  object.\n\nparam **kwargs\n\nOptional arguments that request takes. If\n is not provided, it will be set to  (as\nopposed to the default  behavior).\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.api.post", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "data", "type": null, "default": "..."}, {"name": "json", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a POST request.\n\n```\nparam url\n\nURL for the new  object.\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam json\n\n(optional) A JSON serializable Python object to send in the body of the .\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.api.put", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "data", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a PUT request.\n\n```\nparam url\n\nURL for the new  object.\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam json\n\n(optional) A JSON serializable Python object to send in the body of the .\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.api.patch", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "data", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a PATCH request.\n\n```\nparam url\n\nURL for the new  object.\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam json\n\n(optional) A JSON serializable Python object to send in the body of the .\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.api.delete", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a DELETE request.\n\n```\nparam url\n\nURL for the new  object.\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nreturn\n\n object\n\nrtype\n\nrequests.Response\n```\n"]}], "variables": [], "classes": [], "exports": []}, {"name": "requests.auth", "documentation": ["requests.auth\n~~~~~~~~~~~~~\n\nThis module contains the authentication handlers for Requests."], "functions": [{"name": "requests.auth._basic_auth_str", "asynchronous": false, "params": [{"name": "username", "type": null, "default": null}, {"name": "password", "type": null, "default": null}], "returns": null, "documentation": ["Returns a Basic Auth string."]}], "variables": [{"name": "requests.auth.CONTENT_TYPE_FORM_URLENCODED", "type": null, "documentation": []}, {"name": "requests.auth.CONTENT_TYPE_MULTI_PART", "type": null, "documentation": []}], "classes": [{"name": "requests.auth.AuthBase", "bases": [], "methods": [{"name": "requests.auth.AuthBase.__call__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "r", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Base class that all auth implementations derive from"]}, {"name": "requests.auth.HTTPBasicAuth", "bases": ["AuthBase"], "methods": [{"name": "requests.auth.HTTPBasicAuth.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "username", "type": null, "default": null}, {"name": "password", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.auth.HTTPBasicAuth.__eq__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.auth.HTTPBasicAuth.__ne__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.auth.HTTPBasicAuth.__call__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "r", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Attaches HTTP Basic Authentication to the given Request object."]}, {"name": "requests.auth.HTTPProxyAuth", "bases": ["HTTPBasicAuth"], "methods": [{"name": "requests.auth.HTTPProxyAuth.__call__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "r", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Attaches HTTP Proxy Authentication to a given Request object."]}, {"name": "requests.auth.HTTPDigestAuth", "bases": ["AuthBase"], "methods": [{"name": "requests.auth.HTTPDigestAuth.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "username", "type": null, "default": null}, {"name": "password", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.auth.HTTPDigestAuth.init_per_thread_state", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.auth.HTTPDigestAuth.build_digest_header", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": null, "default": null}, {"name": "url", "type": null, "default": null}], "returns": null, "documentation": ["---\nrtype: str\n---\n"]}, {"name": "requests.auth.HTTPDigestAuth.handle_redirect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "r", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Reset num_401_calls counter on redirects."]}, {"name": "requests.auth.HTTPDigestAuth.handle_401", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "r", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Takes the given response and tries digest-auth, if needed.\n\n```\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.auth.HTTPDigestAuth.__call__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "r", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.auth.HTTPDigestAuth.__eq__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.auth.HTTPDigestAuth.__ne__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Attaches HTTP Digest Authentication to the given Request object."]}], "exports": []}, {"name": "requests.adapters", "documentation": ["requests.adapters\n~~~~~~~~~~~~~~~~~\n\nThis module contains the transport adapters that Requests uses to define\nand maintain connections."], "functions": [{"name": "requests.adapters.SOCKSProxyManager", "asynchronous": false, "params": [{"name": "*args", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.adapters._urllib3_request_context", "asynchronous": false, "params": [{"name": "request", "type": {"name": "PreparedRequest", "xref": {"fqname": "requests.adapters.models.PreparedRequest", "project": null}, "params": null}, "default": null}, {"name": "verify", "type": {"name": "bool | str | None", "xref": null, "params": null}, "default": null}, {"name": "client_cert", "type": {"name": "typing.Tuple[str, str] | str | None", "xref": null, "params": null}, "default": null}, {"name": "poolmanager", "type": {"name": "PoolManager", "xref": {"fqname": "urllib3.poolmanager.PoolManager", "project": "urllib3"}, "params": null}, "default": null}], "returns": {"name": "(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])", "xref": null, "params": null}, "documentation": []}], "variables": [{"name": "requests.adapters.DEFAULT_POOLBLOCK", "type": null, "documentation": []}, {"name": "requests.adapters.DEFAULT_POOLSIZE", "type": null, "documentation": []}, {"name": "requests.adapters.DEFAULT_RETRIES", "type": null, "documentation": []}, {"name": "requests.adapters.DEFAULT_POOL_TIMEOUT", "type": null, "documentation": []}, {"name": "requests.adapters._preloaded_ssl_context", "type": null, "documentation": []}, {"name": "requests.adapters._preloaded_ssl_context", "type": null, "documentation": []}], "classes": [{"name": "requests.adapters.BaseAdapter", "bases": [], "methods": [{"name": "requests.adapters.BaseAdapter.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.adapters.BaseAdapter.send", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "stream", "type": null, "default": "..."}, {"name": "timeout", "type": null, "default": "..."}, {"name": "verify", "type": null, "default": "..."}, {"name": "cert", "type": null, "default": "..."}, {"name": "proxies", "type": null, "default": "..."}], "returns": null, "documentation": ["Sends PreparedRequest object. Returns Response object.\n\n```\nparam request\n\nThe  being sent.\n\nparam stream\n\n(optional) Whether to stream the request content.\n\nparam timeout\n\n(optional) How long to wait for the server to send\ndata before giving up, as a float, or a  tuple.\n\ntype timeout\n\nfloat or tuple\n\nparam verify\n\n(optional) Either a boolean, in which case it controls whether we verify\nthe server's TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\n\nparam cert\n\n(optional) Any user-provided SSL certificate to be trusted.\n\nparam proxies\n\n(optional) The proxies dictionary to apply to the request.\n```\n"]}, {"name": "requests.adapters.BaseAdapter.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Cleans up adapter specific items."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The Base Transport Adapter"]}, {"name": "requests.adapters.HTTPAdapter", "bases": ["BaseAdapter"], "methods": [{"name": "requests.adapters.HTTPAdapter.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "pool_connections", "type": null, "default": "..."}, {"name": "pool_maxsize", "type": null, "default": "..."}, {"name": "max_retries", "type": null, "default": "..."}, {"name": "pool_block", "type": null, "default": "..."}], "returns": null, "documentation": []}, {"name": "requests.adapters.HTTPAdapter.__getstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.adapters.HTTPAdapter.__setstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "state", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.adapters.HTTPAdapter.init_poolmanager", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "connections", "type": null, "default": null}, {"name": "maxsize", "type": null, "default": null}, {"name": "block", "type": null, "default": "..."}, {"name": "**pool_kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Initializes a urllib3 PoolManager.\n\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam connections\n\nThe number of urllib3 connection pools to cache.\n\nparam maxsize\n\nThe maximum number of connections to save in the pool.\n\nparam block\n\nBlock when no free connections are available.\n\nparam pool_kwargs\n\nExtra keyword arguments used to initialize the Pool Manager.\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.proxy_manager_for", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "proxy", "type": null, "default": null}, {"name": "**proxy_kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Return urllib3 ProxyManager for the given proxy.\n\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam proxy\n\nThe proxy to return a urllib3 ProxyManager for.\n\nparam proxy_kwargs\n\nExtra keyword arguments used to configure the Proxy Manager.\n\nreturns\n\nProxyManager\n\nrtype\n\nurllib3.ProxyManager\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.cert_verify", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "conn", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "verify", "type": null, "default": null}, {"name": "cert", "type": null, "default": null}], "returns": null, "documentation": ["Verify a SSL certificate. This method should not be called from user\ncode, and is only exposed for use when subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam conn\n\nThe urllib3 connection object associated with the cert.\n\nparam url\n\nThe requested URL.\n\nparam verify\n\nEither a boolean, in which case it controls whether we verify\nthe server's TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use\n\nparam cert\n\nThe SSL certificate to verify.\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.build_response", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "req", "type": null, "default": null}, {"name": "resp", "type": null, "default": null}], "returns": null, "documentation": ["Builds a {class}`Response <requests.Response>` object from a urllib3\nresponse. This should not be called from user code, and is only exposed\nfor use when subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`\n\n```\nparam req\n\nThe  used to generate the response.\n\nparam resp\n\nThe urllib3 response object.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.build_connection_pool_key_attributes", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "verify", "type": null, "default": null}, {"name": "cert", "type": null, "default": "..."}], "returns": null, "documentation": ["Build the PoolKey attributes used by urllib3 to return a connection.\n\nThis looks at the PreparedRequest, the user-specified verify value,\nand the value of the cert parameter to determine what PoolKey values\nto use to select a connection from a given urllib3 Connection Pool.\n\nThe SSL related pool key arguments are not consistently set. As of\nthis writing, use the following to determine what keys may be in that\ndictionary:\n\n- If `verify` is `True`, `\"ssl_context\"` will be set and will be the\n  default Requests SSL Context\n- If `verify` is `False`, `\"ssl_context\"` will not be set but\n  `\"cert_reqs\"` will be set\n- If `verify` is a string, (i.e., it is a user-specified trust bundle)\n  `\"ca_certs\"` will be set if the string is not a directory recognized\n  by {py:func}`os.path.isdir`, otherwise `\"ca_certs_dir\"` will be\n  set.\n- If `\"cert\"` is specified, `\"cert_file\"` will always be set. If\n  `\"cert\"` is a tuple with a second item, `\"key_file\"` will also\n  be present\n\nTo override these settings, one may subclass this class, call this\nmethod and use the above logic to change parameters as desired. For\nexample, if one wishes to use a custom {py:class}`ssl.SSLContext` one\nmust both set `\"ssl_context\"` and based on what else they require,\nalter the other keys to ensure the desired behaviour.\n\n```\nparam request\n\nThe PreparedReqest being sent over the connection.\n\ntype request\n\n\n\nparam verify\n\nEither a boolean, in which case it controls whether\nwe verify the server's TLS certificate, or a string, in which case it\nmust be a path to a CA bundle to use.\n\nparam cert\n\n(optional) Any user-provided SSL certificate for client\nauthentication (a.k.a., mTLS). This may be a string (i.e., just\nthe path to a file which holds both certificate and key) or a\ntuple of length 2 with the certificate file path and key file\npath.\n\nreturns\n\nA tuple of two dictionaries. The first is the \"host parameters\"\nportion of the Pool Key including scheme, hostname, and port. The\nsecond is a dictionary of SSLContext related parameters.\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.get_connection_with_tls_context", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "verify", "type": null, "default": null}, {"name": "proxies", "type": null, "default": "..."}, {"name": "cert", "type": null, "default": "..."}], "returns": null, "documentation": ["Returns a urllib3 connection for the given request and TLS settings.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the {class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam request\n\nThe  object to be sent\nover the connection.\n\nparam verify\n\nEither a boolean, in which case it controls whether we verify the\nserver's TLS certificate, or a string, in which case it must be a\npath to a CA bundle to use.\n\nparam proxies\n\n(optional) The proxies dictionary to apply to the request.\n\nparam cert\n\n(optional) Any user-provided SSL certificate to be used for client\nauthentication (a.k.a., mTLS).\n\nrtype\n\nurllib3.ConnectionPool\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.get_connection", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "proxies", "type": null, "default": "..."}], "returns": null, "documentation": ["DEPRECATED: Users should move to `get_connection_with_tls_context`\nfor all subclasses of HTTPAdapter using Requests>=2.32.2.\n\nReturns a urllib3 connection for the given URL. This should not be\ncalled from user code, and is only exposed for use when subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam url\n\nThe URL to connect to.\n\nparam proxies\n\n(optional) A Requests-style dictionary of proxies used on this request.\n\nrtype\n\nurllib3.ConnectionPool\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Disposes of any internal state.\n\nCurrently, this closes the PoolManager and any active ProxyManager,\nwhich closes any pooled connections."]}, {"name": "requests.adapters.HTTPAdapter.request_url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "proxies", "type": null, "default": null}], "returns": null, "documentation": ["Obtain the url to use when making the final request.\n\nIf the message is being sent through a HTTP proxy, the full URL has to\nbe used. Otherwise, we should only use the path portion of the URL.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam request\n\nThe  being sent.\n\nparam proxies\n\nA dictionary of schemes or schemes and hosts to proxy URLs.\n\nrtype\n\nstr\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.add_headers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Add any headers needed by the connection. As of v2.0 this does\nnothing by default, but is left for overriding by users that subclass\nthe {class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam request\n\nThe  to add headers to.\n\nparam kwargs\n\nThe keyword arguments from the call to send().\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.proxy_headers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "proxy", "type": null, "default": null}], "returns": null, "documentation": ["Returns a dictionary of the headers to add to any request sent\nthrough a proxy. This works with urllib3 magic to ensure that they are\ncorrectly sent to the proxy, rather than in a tunnelled request if\nCONNECT is being used.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n{class}`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n```\nparam proxy\n\nThe url of the proxy being used for this request.\n\nrtype\n\ndict\n```\n"]}, {"name": "requests.adapters.HTTPAdapter.send", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "stream", "type": null, "default": "..."}, {"name": "timeout", "type": null, "default": "..."}, {"name": "verify", "type": null, "default": "..."}, {"name": "cert", "type": null, "default": "..."}, {"name": "proxies", "type": null, "default": "..."}], "returns": null, "documentation": ["Sends PreparedRequest object. Returns Response object.\n\n```\nparam request\n\nThe  being sent.\n\nparam stream\n\n(optional) Whether to stream the request content.\n\nparam timeout\n\n(optional) How long to wait for the server to send\ndata before giving up, as a float, or a  tuple.\n\ntype timeout\n\nfloat or tuple or urllib3 Timeout object\n\nparam verify\n\n(optional) Either a boolean, in which case it controls whether\nwe verify the server's TLS certificate, or a string, in which case it\nmust be a path to a CA bundle to use\n\nparam cert\n\n(optional) Any user-provided SSL certificate to be trusted.\n\nparam proxies\n\n(optional) The proxies dictionary to apply to the request.\n\nrtype\n\nrequests.Response\n```\n"]}], "class_variables": [{"name": "requests.adapters.HTTPAdapter.__attrs__", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the {class}`Session <Session>` class under the\ncovers.\n\n```\nparam pool_connections\n\nThe number of urllib3 connection pools to cache.\n\nparam pool_maxsize\n\nThe maximum number of connections to save in the pool.\n\nparam max_retries\n\nThe maximum number of retries each connection\nshould attempt. Note, this applies only to failed DNS lookups, socket\nconnections and connection timeouts, never to requests where data has\nmade it to the server. By default, Requests does not retry failed\nconnections. If you need granular control over the conditions under\nwhich we retry a request, import urllib3's Retry class and pass\nthat instead.\n\nparam pool_block\n\nWhether the connection pool should block for connections.\n```\n\nUsage:\n\n```\n>>> import requests\n>>> s = requests.Session()\n>>> a = requests.adapters.HTTPAdapter(max_retries=3)\n>>> s.mount('http://', a)\n```\n"]}], "exports": []}, {"name": "requests.sessions", "documentation": ["requests.sessions\n~~~~~~~~~~~~~~~~~\n\nThis module provides a Session object to manage and persist settings across\nrequests (cookies, auth, proxies)."], "functions": [{"name": "requests.sessions.merge_setting", "asynchronous": false, "params": [{"name": "request_setting", "type": null, "default": null}, {"name": "session_setting", "type": null, "default": null}, {"name": "dict_class", "type": null, "default": "..."}], "returns": null, "documentation": ["Determines appropriate setting for a given request, taking into account\nthe explicit setting on that request, and the setting in the session. If a\nsetting is a dictionary, they will be merged together using `dict_class`"]}, {"name": "requests.sessions.merge_hooks", "asynchronous": false, "params": [{"name": "request_hooks", "type": null, "default": null}, {"name": "session_hooks", "type": null, "default": null}, {"name": "dict_class", "type": null, "default": "..."}], "returns": null, "documentation": ["Properly merges both requests and session hooks.\n\nThis is necessary because when request_hooks == {'response': []}, the\nmerge breaks Session hooks entirely."]}, {"name": "requests.sessions.session", "asynchronous": false, "params": [], "returns": null, "documentation": ["Returns a {class}`Session` for context-management.\n\n:::{deprecated} 1.0.0\nThis method has been deprecated since version 1.0.0 and is only kept for\nbackwards compatibility. New code should use {class}`~requests.sessions.Session`\nto create a session. This may be removed at a future date.\n:::\n\n```\nrtype\n\nSession\n```\n"]}], "variables": [{"name": "requests.sessions.preferred_clock", "type": null, "documentation": []}, {"name": "requests.sessions.preferred_clock", "type": null, "documentation": []}], "classes": [{"name": "requests.sessions.SessionRedirectMixin", "bases": [], "methods": [{"name": "requests.sessions.SessionRedirectMixin.get_redirect_target", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "resp", "type": null, "default": null}], "returns": null, "documentation": ["Receives a Response. Returns a redirect URI or ``None``"]}, {"name": "requests.sessions.SessionRedirectMixin.should_strip_auth", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "old_url", "type": null, "default": null}, {"name": "new_url", "type": null, "default": null}], "returns": null, "documentation": ["Decide whether Authorization header should be removed when redirecting"]}, {"name": "requests.sessions.SessionRedirectMixin.resolve_redirects", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "resp", "type": null, "default": null}, {"name": "req", "type": null, "default": null}, {"name": "stream", "type": null, "default": "..."}, {"name": "timeout", "type": null, "default": "..."}, {"name": "verify", "type": null, "default": "..."}, {"name": "cert", "type": null, "default": "..."}, {"name": "proxies", "type": null, "default": "..."}, {"name": "yield_requests", "type": null, "default": "..."}, {"name": "**adapter_kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Receives a Response. Returns a generator of Responses or Requests."]}, {"name": "requests.sessions.SessionRedirectMixin.rebuild_auth", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "prepared_request", "type": null, "default": null}, {"name": "response", "type": null, "default": null}], "returns": null, "documentation": ["When being redirected we may want to strip authentication from the\nrequest to avoid leaking credentials. This method intelligently removes\nand reapplies authentication where possible to avoid credential loss."]}, {"name": "requests.sessions.SessionRedirectMixin.rebuild_proxies", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "prepared_request", "type": null, "default": null}, {"name": "proxies", "type": null, "default": null}], "returns": null, "documentation": ["This method re-evaluates the proxy configuration by considering the\nenvironment variables. If we are redirected to a URL covered by\nNO_PROXY, we strip the proxy configuration. Otherwise, we set missing\nproxy keys for this URL (in case they were stripped by a previous\nredirect).\n\nThis method also replaces the Proxy-Authorization header where\nnecessary.\n\n```\nrtype\n\ndict\n```\n"]}, {"name": "requests.sessions.SessionRedirectMixin.rebuild_method", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "prepared_request", "type": null, "default": null}, {"name": "response", "type": null, "default": null}], "returns": null, "documentation": ["When being redirected we may want to change the method of the request\nbased on certain specs or browser behavior."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "requests.sessions.Session", "bases": ["SessionRedirectMixin"], "methods": [{"name": "requests.sessions.Session.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.sessions.Session.__enter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.sessions.Session.__exit__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*args", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.sessions.Session.prepare_request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}], "returns": null, "documentation": ["Constructs a {class}`PreparedRequest <PreparedRequest>` for\ntransmission and returns it. The {class}`PreparedRequest` has settings\nmerged from the {class}`Request <Request>` instance and those of the\n{class}`Session`.\n\n```\nparam request\n\n instance to prepare with this\nsession's settings.\n\nrtype\n\nrequests.PreparedRequest\n```\n"]}, {"name": "requests.sessions.Session.request", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "params", "type": null, "default": "..."}, {"name": "data", "type": null, "default": "..."}, {"name": "headers", "type": null, "default": "..."}, {"name": "cookies", "type": null, "default": "..."}, {"name": "files", "type": null, "default": "..."}, {"name": "auth", "type": null, "default": "..."}, {"name": "timeout", "type": null, "default": "..."}, {"name": "allow_redirects", "type": null, "default": "..."}, {"name": "proxies", "type": null, "default": "..."}, {"name": "hooks", "type": null, "default": "..."}, {"name": "stream", "type": null, "default": "..."}, {"name": "verify", "type": null, "default": "..."}, {"name": "cert", "type": null, "default": "..."}, {"name": "json", "type": null, "default": "..."}], "returns": null, "documentation": ["Constructs a {class}`Request <Request>`, prepares it and sends it.\nReturns {class}`Response <Response>` object.\n\n```\nparam method\n\nmethod for the new  object.\n\nparam url\n\nURL for the new  object.\n\nparam params\n\n(optional) Dictionary or bytes to be sent in the query\nstring for the .\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam json\n\n(optional) json to send in the body of the\n.\n\nparam headers\n\n(optional) Dictionary of HTTP Headers to send with the\n.\n\nparam cookies\n\n(optional) Dict or CookieJar object to send with the\n.\n\nparam files\n\n(optional) Dictionary of 'filename': file-like-objects\nfor multipart encoding upload.\n\nparam auth\n\n(optional) Auth tuple or callable to enable\nBasic/Digest/Custom HTTP Auth.\n\nparam timeout\n\n(optional) How long to wait for the server to send\ndata before giving up, as a float, or a  tuple.\n\ntype timeout\n\nfloat or tuple\n\nparam allow_redirects\n\n(optional) Set to True by default.\n\ntype allow_redirects\n\nbool\n\nparam proxies\n\n(optional) Dictionary mapping protocol or protocol and\nhostname to the URL of the proxy.\n\nparam hooks\n\n(optional) Dictionary mapping hook name to one event or\nlist of events, event must be callable.\n\nparam stream\n\n(optional) whether to immediately download the response\ncontent. Defaults to False.\n\nparam verify\n\n(optional) Either a boolean, in which case it controls whether we verify\nthe server's TLS certificate, or a string, in which case it must be a path\nto a CA bundle to use. Defaults to True. When set to\nFalse, requests will accept any TLS certificate presented by\nthe server, and will ignore hostname mismatches and/or expired\ncertificates, which will make your application vulnerable to\nman-in-the-middle (MitM) attacks. Setting verify to False\nmay be useful during local development or testing.\n\nparam cert\n\n(optional) if String, path to ssl client cert file (.pem).\nIf Tuple, ('cert', 'key') pair.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.get", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a GET request. Returns {class}`Response` object.\n\n```\nparam url\n\nURL for the new  object.\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.options", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a OPTIONS request. Returns {class}`Response` object.\n\n```\nparam url\n\nURL for the new  object.\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.head", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a HEAD request. Returns {class}`Response` object.\n\n```\nparam url\n\nURL for the new  object.\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.post", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "data", "type": null, "default": "..."}, {"name": "json", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a POST request. Returns {class}`Response` object.\n\n```\nparam url\n\nURL for the new  object.\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam json\n\n(optional) json to send in the body of the .\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.put", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "data", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a PUT request. Returns {class}`Response` object.\n\n```\nparam url\n\nURL for the new  object.\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.patch", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "data", "type": null, "default": "..."}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a PATCH request. Returns {class}`Response` object.\n\n```\nparam url\n\nURL for the new  object.\n\nparam data\n\n(optional) Dictionary, list of tuples, bytes, or file-like\nobject to send in the body of the .\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.delete", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Sends a DELETE request. Returns {class}`Response` object.\n\n```\nparam url\n\nURL for the new  object.\n\nparam **kwargs\n\nOptional arguments that request takes.\n\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.send", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Send a given PreparedRequest.\n\n```\nrtype\n\nrequests.Response\n```\n"]}, {"name": "requests.sessions.Session.merge_environment_settings", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "proxies", "type": null, "default": null}, {"name": "stream", "type": null, "default": null}, {"name": "verify", "type": null, "default": null}, {"name": "cert", "type": null, "default": null}], "returns": null, "documentation": ["Check the environment and merge it with some settings.\n\n```\nrtype\n\ndict\n```\n"]}, {"name": "requests.sessions.Session.get_adapter", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}], "returns": null, "documentation": ["Returns the appropriate connection adapter for the given URL.\n\n```\nrtype\n\nrequests.adapters.BaseAdapter\n```\n"]}, {"name": "requests.sessions.Session.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Closes all adapters and as such the session"]}, {"name": "requests.sessions.Session.mount", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "prefix", "type": null, "default": null}, {"name": "adapter", "type": null, "default": null}], "returns": null, "documentation": ["Registers a connection adapter to a prefix.\n\nAdapters are sorted in descending order by prefix length."]}, {"name": "requests.sessions.Session.__getstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.sessions.Session.__setstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "state", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [{"name": "requests.sessions.Session.__attrs__", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage:\n\n```\n>>> import requests\n>>> s = requests.Session()\n>>> s.get('https://httpbin.org/get')\n<Response [200]>\n```\n\nOr as a context manager:\n\n```\n>>> with requests.Session() as s:\n...     s.get('https://httpbin.org/get')\n<Response [200]>\n```\n"]}], "exports": []}, {"name": "requests.cookies", "documentation": ["requests.cookies\n~~~~~~~~~~~~~~~~\n\nCompatibility code to be able to use `http.cookiejar.CookieJar` with requests.\n\nrequests.utils imports from here, so be careful with imports."], "functions": [{"name": "requests.cookies.extract_cookies_to_jar", "asynchronous": false, "params": [{"name": "jar", "type": null, "default": null}, {"name": "request", "type": null, "default": null}, {"name": "response", "type": null, "default": null}], "returns": null, "documentation": ["Extract the cookies from the response into a CookieJar.\n\n```\nparam jar\n\nhttp.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n\nparam request\n\nour own requests.Request object\n\nparam response\n\nurllib3.HTTPResponse object\n```\n"]}, {"name": "requests.cookies.get_cookie_header", "asynchronous": false, "params": [{"name": "jar", "type": null, "default": null}, {"name": "request", "type": null, "default": null}], "returns": null, "documentation": ["Produce an appropriate Cookie header string to be sent with `request`, or None.\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.cookies.remove_cookie_by_name", "asynchronous": false, "params": [{"name": "cookiejar", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "domain", "type": null, "default": "..."}, {"name": "path", "type": null, "default": "..."}], "returns": null, "documentation": ["Unsets a cookie by name, by default over all domains and paths.\n\nWraps CookieJar.clear(), is O(n)."]}, {"name": "requests.cookies._copy_cookie_jar", "asynchronous": false, "params": [{"name": "jar", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.create_cookie", "asynchronous": false, "params": [{"name": "name", "type": null, "default": null}, {"name": "value", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Make a cookie from underspecified parameters.\n\nBy default, the pair of `name` and `value` will be set for the domain ''\nand sent on every request (this is sometimes called a \"supercookie\")."]}, {"name": "requests.cookies.morsel_to_cookie", "asynchronous": false, "params": [{"name": "morsel", "type": null, "default": null}], "returns": null, "documentation": ["Convert a Morsel object into a Cookie containing the one k/v pair."]}, {"name": "requests.cookies.cookiejar_from_dict", "asynchronous": false, "params": [{"name": "cookie_dict", "type": null, "default": null}, {"name": "cookiejar", "type": null, "default": "..."}, {"name": "overwrite", "type": null, "default": "..."}], "returns": null, "documentation": ["Returns a CookieJar from a key/value dictionary.\n\n```\nparam cookie_dict\n\nDict of key/values to insert into CookieJar.\n\nparam cookiejar\n\n(optional) A cookiejar to add the cookies to.\n\nparam overwrite\n\n(optional) If False, will not replace cookies\nalready in the jar with new ones.\n\nrtype\n\nCookieJar\n```\n"]}, {"name": "requests.cookies.merge_cookies", "asynchronous": false, "params": [{"name": "cookiejar", "type": null, "default": null}, {"name": "cookies", "type": null, "default": null}], "returns": null, "documentation": ["Add cookies to cookiejar and returns a merged CookieJar.\n\n```\nparam cookiejar\n\nCookieJar object to add the cookies to.\n\nparam cookies\n\nDictionary or CookieJar object to be added.\n\nrtype\n\nCookieJar\n```\n"]}], "variables": [], "classes": [{"name": "requests.cookies.MockRequest", "bases": [], "methods": [{"name": "requests.cookies.MockRequest.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "request", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.get_type", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.get_host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.get_origin_req_host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.get_full_url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.is_unverifiable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.has_header", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.get_header", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "default", "type": null, "default": "..."}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.add_header", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "key", "type": null, "default": null}, {"name": "val", "type": null, "default": null}], "returns": null, "documentation": ["cookiejar has no legitimate use for this method; add it back if you find one."]}, {"name": "requests.cookies.MockRequest.add_unredirected_header", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "value", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.get_new_headers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.unverifiable", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.origin_req_host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockRequest.host", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below."]}, {"name": "requests.cookies.MockResponse", "bases": [], "methods": [{"name": "requests.cookies.MockResponse.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "headers", "type": null, "default": null}], "returns": null, "documentation": ["Make a MockResponse for `cookiejar` to read.\n\n```\nparam headers\n\na httplib.HTTPMessage or analogous carrying the headers\n```\n"]}, {"name": "requests.cookies.MockResponse.info", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.MockResponse.getheaders", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}], "returns": null, "documentation": []}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n\n...what? Basically, expose the parsed HTTP headers from the server response\nthe way `http.cookiejar` expects to see them."]}, {"name": "requests.cookies.CookieConflictError", "bases": ["RuntimeError"], "methods": [], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["There are two cookies that meet the criteria specified in the cookie jar.\nUse .get and .set and include domain and path args in order to be more specific."]}, {"name": "requests.cookies.RequestsCookieJar", "bases": ["cookielib.CookieJar", "MutableMapping"], "methods": [{"name": "requests.cookies.RequestsCookieJar.get", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "default", "type": null, "default": "..."}, {"name": "domain", "type": null, "default": "..."}, {"name": "path", "type": null, "default": "..."}], "returns": null, "documentation": ["Dict-like get() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\n:::{warning}\noperation is O(n), not O(1).\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.set", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "value", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like set() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains."]}, {"name": "requests.cookies.RequestsCookieJar.iterkeys", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like iterkeys() that returns an iterator of names of cookies\nfrom the jar.\n\n:::{seealso}\nitervalues() and iteritems().\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.keys", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like keys() that returns a list of names of cookies from the\njar.\n\n:::{seealso}\nvalues() and items().\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.itervalues", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like itervalues() that returns an iterator of values of cookies\nfrom the jar.\n\n:::{seealso}\niterkeys() and iteritems().\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.values", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like values() that returns a list of values of cookies from the\njar.\n\n:::{seealso}\nkeys() and items().\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.iteritems", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like iteritems() that returns an iterator of name-value tuples\nfrom the jar.\n\n:::{seealso}\niterkeys() and itervalues().\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.items", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like items() that returns a list of name-value tuples from the\njar. Allows client-code to call `dict(RequestsCookieJar)` and get a\nvanilla python dict of key value pairs.\n\n:::{seealso}\nkeys() and values().\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.list_domains", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Utility method to list all the domains in the jar."]}, {"name": "requests.cookies.RequestsCookieJar.list_paths", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Utility method to list all the paths in the jar."]}, {"name": "requests.cookies.RequestsCookieJar.multiple_domains", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Returns True if there are multiple domains in the jar.\nReturns False otherwise.\n\n```\nrtype\n\nbool\n```\n"]}, {"name": "requests.cookies.RequestsCookieJar.get_dict", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "domain", "type": null, "default": "..."}, {"name": "path", "type": null, "default": "..."}], "returns": null, "documentation": ["Takes as an argument an optional domain and path and returns a plain\nold Python dict of name-value pairs of cookies that meet the\nrequirements.\n\n```\nrtype\n\ndict\n```\n"]}, {"name": "requests.cookies.RequestsCookieJar.__contains__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.RequestsCookieJar.__getitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like \\_\\_getitem\\_\\_() for compatibility with client code. Throws\nexception if there are more than one cookie with name. In that case,\nuse the more explicit get() method instead.\n\n:::{warning}\noperation is O(n), not O(1).\n:::\n"]}, {"name": "requests.cookies.RequestsCookieJar.__setitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "value", "type": null, "default": null}], "returns": null, "documentation": ["Dict-like __setitem__ for compatibility with client code. Throws\nexception if there is already a cookie of that name in the jar. In that\ncase, use the more explicit set() method instead."]}, {"name": "requests.cookies.RequestsCookieJar.__delitem__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}], "returns": null, "documentation": ["Deletes a cookie given a name. Wraps `http.cookiejar.CookieJar`'s\n`remove_cookie_by_name()`.\n"]}, {"name": "requests.cookies.RequestsCookieJar.set_cookie", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "cookie", "type": null, "default": null}, {"name": "*args", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.cookies.RequestsCookieJar.update", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "other", "type": null, "default": null}], "returns": null, "documentation": ["Updates this jar with cookies from another CookieJar or dict-like"]}, {"name": "requests.cookies.RequestsCookieJar._find", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "domain", "type": null, "default": "..."}, {"name": "path", "type": null, "default": "..."}], "returns": null, "documentation": ["Requests uses this method internally to get cookie values.\n\nIf there are conflicting cookies, \\_find arbitrarily chooses one.\nSee \\_find_no_duplicates if you want an exception thrown if there are\nconflicting cookies.\n\n```\nparam name\n\na string containing name of cookie\n\nparam domain\n\n(optional) string containing domain of cookie\n\nparam path\n\n(optional) string containing path of cookie\n\nreturn\n\ncookie.value\n```\n"]}, {"name": "requests.cookies.RequestsCookieJar._find_no_duplicates", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "name", "type": null, "default": null}, {"name": "domain", "type": null, "default": "..."}, {"name": "path", "type": null, "default": "..."}], "returns": null, "documentation": ["Both `__get_item__` and `get` call this function: it's never\nused elsewhere in Requests.\n\n```\nparam name\n\na string containing name of cookie\n\nparam domain\n\n(optional) string containing domain of cookie\n\nparam path\n\n(optional) string containing path of cookie\n\nraises KeyError\n\nif cookie is not found\n\nraises CookieConflictError\n\nif there are multiple cookies\nthat match name and optionally domain and path\n\nreturn\n\ncookie.value\n```\n"]}, {"name": "requests.cookies.RequestsCookieJar.__getstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Unlike a normal CookieJar, this class is pickleable."]}, {"name": "requests.cookies.RequestsCookieJar.__setstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "state", "type": null, "default": null}], "returns": null, "documentation": ["Unlike a normal CookieJar, this class is pickleable."]}, {"name": "requests.cookies.RequestsCookieJar.copy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Return a copy of this RequestsCookieJar."]}, {"name": "requests.cookies.RequestsCookieJar.get_policy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Return the CookiePolicy instance used."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of `CookieJar`, e.g.\n`LWPCookieJar` and `FileCookieJar`.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n:::{warning}\ndictionary operations that are normally O(1) may be O(n).\n:::\n"]}], "exports": []}, {"name": "requests.models", "documentation": ["requests.models\n~~~~~~~~~~~~~~~\n\nThis module contains the primary objects that power Requests."], "functions": [], "variables": [{"name": "requests.models.REDIRECT_STATI", "type": null, "documentation": []}, {"name": "requests.models.DEFAULT_REDIRECT_LIMIT", "type": null, "documentation": []}, {"name": "requests.models.CONTENT_CHUNK_SIZE", "type": null, "documentation": []}, {"name": "requests.models.ITER_CHUNK_SIZE", "type": null, "documentation": []}], "classes": [{"name": "requests.models.RequestEncodingMixin", "bases": [], "methods": [{"name": "requests.models.RequestEncodingMixin.path_url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Build the path URL to use."]}, {"name": "requests.models.RequestEncodingMixin._encode_params", "asynchronous": false, "params": [{"name": "data", "type": null, "default": null}], "returns": null, "documentation": ["Encode parameters in a piece of data.\n\nWill successfully encode parameters when passed as a dict or a list of\n2-tuples. Order is retained if data is a list of 2-tuples but arbitrary\nif parameters are supplied as a dict."]}, {"name": "requests.models.RequestEncodingMixin._encode_files", "asynchronous": false, "params": [{"name": "files", "type": null, "default": null}, {"name": "data", "type": null, "default": null}], "returns": null, "documentation": ["Build the body for a multipart/form-data request.\n\nWill successfully encode files when passed as a dict or a list of\ntuples. Order is retained if data is a list of tuples but arbitrary\nif parameters are supplied as a dict.\nThe tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)\nor 4-tuples (filename, fileobj, contentype, custom_headers)."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "requests.models.RequestHooksMixin", "bases": [], "methods": [{"name": "requests.models.RequestHooksMixin.register_hook", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "event", "type": null, "default": null}, {"name": "hook", "type": null, "default": null}], "returns": null, "documentation": ["Properly register a hook."]}, {"name": "requests.models.RequestHooksMixin.deregister_hook", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "event", "type": null, "default": null}, {"name": "hook", "type": null, "default": null}], "returns": null, "documentation": ["Deregister a previously registered hook.\nReturns True if the hook existed, False if not."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": []}, {"name": "requests.models.Request", "bases": ["RequestHooksMixin"], "methods": [{"name": "requests.models.Request.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": null, "default": "..."}, {"name": "url", "type": null, "default": "..."}, {"name": "headers", "type": null, "default": "..."}, {"name": "files", "type": null, "default": "..."}, {"name": "data", "type": null, "default": "..."}, {"name": "params", "type": null, "default": "..."}, {"name": "auth", "type": null, "default": "..."}, {"name": "cookies", "type": null, "default": "..."}, {"name": "hooks", "type": null, "default": "..."}, {"name": "json", "type": null, "default": "..."}], "returns": null, "documentation": []}, {"name": "requests.models.Request.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.Request.prepare", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Constructs a {class}`PreparedRequest <PreparedRequest>` for transmission and returns it.\n"]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["A user-created {class}`Request <Request>` object.\n\nUsed to prepare a {class}`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n```\nparam method\n\nHTTP method to use.\n\nparam url\n\nURL to send.\n\nparam headers\n\ndictionary of headers to send.\n\nparam files\n\ndictionary of {filename: fileobject} files to multipart upload.\n\nparam data\n\nthe body to attach to the request. If a dictionary or\nlist of tuples [(key, value)] is provided, form-encoding will\ntake place.\n\nparam json\n\njson for the body to attach to the request (if files or data is not specified).\n\nparam params\n\nURL parameters to append to the URL. If a dictionary or\nlist of tuples [(key, value)] is provided, form-encoding will\ntake place.\n\nparam auth\n\nAuth handler or (user, pass) tuple.\n\nparam cookies\n\ndictionary or CookieJar of cookies to attach to this request.\n\nparam hooks\n\ndictionary of callback hooks, for internal usage.\n```\n\nUsage:\n\n```\n>>> import requests\n>>> req = requests.Request('GET', 'https://httpbin.org/get')\n>>> req.prepare()\n<PreparedRequest [GET]>\n```\n"]}, {"name": "requests.models.PreparedRequest", "bases": ["RequestEncodingMixin", "RequestHooksMixin"], "methods": [{"name": "requests.models.PreparedRequest.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.PreparedRequest.prepare", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": null, "default": "..."}, {"name": "url", "type": null, "default": "..."}, {"name": "headers", "type": null, "default": "..."}, {"name": "files", "type": null, "default": "..."}, {"name": "data", "type": null, "default": "..."}, {"name": "params", "type": null, "default": "..."}, {"name": "auth", "type": null, "default": "..."}, {"name": "cookies", "type": null, "default": "..."}, {"name": "hooks", "type": null, "default": "..."}, {"name": "json", "type": null, "default": "..."}], "returns": null, "documentation": ["Prepares the entire request with the given parameters."]}, {"name": "requests.models.PreparedRequest.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.PreparedRequest.copy", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.PreparedRequest.prepare_method", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "method", "type": null, "default": null}], "returns": null, "documentation": ["Prepares the given HTTP method."]}, {"name": "requests.models.PreparedRequest._get_idna_encoded_host", "asynchronous": false, "params": [{"name": "host", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.PreparedRequest.prepare_url", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "url", "type": null, "default": null}, {"name": "params", "type": null, "default": null}], "returns": null, "documentation": ["Prepares the given HTTP URL."]}, {"name": "requests.models.PreparedRequest.prepare_headers", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "headers", "type": null, "default": null}], "returns": null, "documentation": ["Prepares the given HTTP headers."]}, {"name": "requests.models.PreparedRequest.prepare_body", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "data", "type": null, "default": null}, {"name": "files", "type": null, "default": null}, {"name": "json", "type": null, "default": "..."}], "returns": null, "documentation": ["Prepares the given HTTP body data."]}, {"name": "requests.models.PreparedRequest.prepare_content_length", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "body", "type": null, "default": null}], "returns": null, "documentation": ["Prepare Content-Length header based on request method and body"]}, {"name": "requests.models.PreparedRequest.prepare_auth", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "auth", "type": null, "default": null}, {"name": "url", "type": null, "default": "..."}], "returns": null, "documentation": ["Prepares the given HTTP auth data."]}, {"name": "requests.models.PreparedRequest.prepare_cookies", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "cookies", "type": null, "default": null}], "returns": null, "documentation": ["Prepares the given HTTP cookie data.\n\nThis function eventually generates a `Cookie` header from the\ngiven cookies using cookielib. Due to cookielib's design, the header\nwill not be regenerated if it already exists, meaning this function\ncan only be called once for the life of the\n{class}`PreparedRequest <PreparedRequest>` object. Any subsequent calls\nto `prepare_cookies` will have no actual effect, unless the \"Cookie\"\nheader is removed beforehand.\n"]}, {"name": "requests.models.PreparedRequest.prepare_hooks", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "hooks", "type": null, "default": null}], "returns": null, "documentation": ["Prepares the given hooks."]}], "class_variables": [], "instance_variables": [], "inner_classes": [], "documentation": ["The fully mutable {class}`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a {class}`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage:\n\n```\n>>> import requests\n>>> req = requests.Request('GET', 'https://httpbin.org/get')\n>>> r = req.prepare()\n>>> r\n<PreparedRequest [GET]>\n\n>>> s = requests.Session()\n>>> s.send(r)\n<Response [200]>\n```\n"]}, {"name": "requests.models.Response", "bases": [], "methods": [{"name": "requests.models.Response.__init__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.Response.__enter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.Response.__exit__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "*args", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.Response.__getstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.Response.__setstate__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "state", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.Response.__repr__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.models.Response.__bool__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Returns True if {attr}`status_code` is less than 400.\n\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code, is between 200 and 400, this will return True. This\nis **not** a check to see if the response code is `200 OK`.\n"]}, {"name": "requests.models.Response.__nonzero__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Returns True if {attr}`status_code` is less than 400.\n\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code, is between 200 and 400, this will return True. This\nis **not** a check to see if the response code is `200 OK`.\n"]}, {"name": "requests.models.Response.__iter__", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Allows you to use a response as an iterator."]}, {"name": "requests.models.Response.ok", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Returns True if {attr}`status_code` is less than 400, False if not.\n\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code is between 200 and 400, this will return True. This\nis **not** a check to see if the response code is `200 OK`.\n"]}, {"name": "requests.models.Response.is_redirect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["True if this Response is a well-formed HTTP redirect that could have\nbeen processed automatically (by {meth}`Session.resolve_redirects`).\n"]}, {"name": "requests.models.Response.is_permanent_redirect", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["True if this Response one of the permanent versions of redirect."]}, {"name": "requests.models.Response.next", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Returns a PreparedRequest for the next request in a redirect chain, if there is one."]}, {"name": "requests.models.Response.apparent_encoding", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["The apparent encoding, provided by the charset_normalizer or chardet libraries."]}, {"name": "requests.models.Response.iter_content", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "chunk_size", "type": null, "default": "..."}, {"name": "decode_unicode", "type": null, "default": "..."}], "returns": null, "documentation": ["Iterates over the response data.  When stream=True is set on the\nrequest, this avoids reading the content at once into memory for\nlarge responses.  The chunk size is the number of bytes it should\nread into memory.  This is not necessarily the length of each item\nreturned as decoding can take place.\n\nchunk_size must be of type int or None. A value of None will\nfunction differently depending on the value of `stream`.\nstream=True will read data as it arrives in whatever size the\nchunks are received. If stream=False, data is returned as\na single chunk.\n\nIf decode_unicode is True, content will be decoded using the best\navailable encoding based on the response."]}, {"name": "requests.models.Response.iter_lines", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "chunk_size", "type": null, "default": "..."}, {"name": "decode_unicode", "type": null, "default": "..."}, {"name": "delimiter", "type": null, "default": "..."}], "returns": null, "documentation": ["Iterates over the response data, one line at a time.  When\nstream=True is set on the request, this avoids reading the\ncontent at once into memory for large responses.\n\n:::{note}\nThis method is not reentrant safe.\n:::\n"]}, {"name": "requests.models.Response.content", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Content of the response, in bytes."]}, {"name": "requests.models.Response.text", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Content of the response, in unicode.\n\nIf Response.encoding is None, encoding will be guessed using\n`charset_normalizer` or `chardet`.\n\nThe encoding of the response content is determined based solely on HTTP\nheaders, following RFC 2616 to the letter. If you can take advantage of\nnon-HTTP knowledge to make a better guess at the encoding, you should\nset `r.encoding` appropriately before accessing this property.\n"]}, {"name": "requests.models.Response.json", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}, {"name": "**kwargs", "type": null, "default": null}], "returns": null, "documentation": ["Returns the json-encoded content of a response, if any.\n\n```\nparam **kwargs\n\nOptional arguments that json.loads takes.\n\nraises requests.exceptions.JSONDecodeError\n\nIf the response body does not\ncontain valid json.\n```\n"]}, {"name": "requests.models.Response.links", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Returns the parsed header links of the response, if any."]}, {"name": "requests.models.Response.raise_for_status", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Raises {class}`HTTPError`, if one occurred.\n"]}, {"name": "requests.models.Response.close", "asynchronous": false, "params": [{"name": "self", "type": null, "default": null}], "returns": null, "documentation": ["Releases the connection back to the pool. Once this method has been\ncalled the underlying `raw` object must not be accessed again.\n\n*Note: Should not normally need to be called explicitly.*\n"]}], "class_variables": [{"name": "requests.models.Response.__attrs__", "type": null, "documentation": []}], "instance_variables": [], "inner_classes": [], "documentation": ["The {class}`Response <Response>` object, which contains a\nserver's response to an HTTP request.\n"]}], "exports": []}, {"name": "requests.utils", "documentation": ["requests.utils\n~~~~~~~~~~~~~~\n\nThis module provides utility functions that are used within Requests\nthat are also useful for external consumption."], "functions": [{"name": "requests.utils.proxy_bypass_registry", "asynchronous": false, "params": [{"name": "host", "type": null, "default": null}], "returns": null, "documentation": ["provide a proxy_bypass version on Windows without DNS lookups"]}, {"name": "requests.utils.proxy_bypass", "asynchronous": false, "params": [{"name": "host", "type": null, "default": null}], "returns": null, "documentation": ["Return True, if the host should be bypassed.\n\nChecks proxy settings gathered from the environment, if specified,\nor the registry."]}, {"name": "requests.utils.dict_to_sequence", "asynchronous": false, "params": [{"name": "d", "type": null, "default": null}], "returns": null, "documentation": ["Returns an internal sequence dictionary update."]}, {"name": "requests.utils.super_len", "asynchronous": false, "params": [{"name": "o", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.utils.get_netrc_auth", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "raise_errors", "type": null, "default": "..."}], "returns": null, "documentation": ["Returns the Requests tuple auth for a given url from netrc."]}, {"name": "requests.utils.guess_filename", "asynchronous": false, "params": [{"name": "obj", "type": null, "default": null}], "returns": null, "documentation": ["Tries to guess the filename of the given object."]}, {"name": "requests.utils.extract_zipped_paths", "asynchronous": false, "params": [{"name": "path", "type": null, "default": null}], "returns": null, "documentation": ["Replace nonexistent paths that look like they refer to a member of a zip\narchive with the location of an extracted copy of the target, or else\njust return the provided path unchanged."]}, {"name": "requests.utils.atomic_open", "asynchronous": false, "params": [{"name": "filename", "type": null, "default": null}], "returns": null, "documentation": ["Write a file to the disk in an atomic fashion"]}, {"name": "requests.utils.from_key_val_list", "asynchronous": false, "params": [{"name": "value", "type": null, "default": null}], "returns": null, "documentation": ["Take an object and test to see if it can be represented as a\ndictionary. Unless it can not be represented as such, return an\nOrderedDict, e.g.,\n\n```\n>>> from_key_val_list([('key', 'val')])\nOrderedDict([('key', 'val')])\n>>> from_key_val_list('string')\nTraceback (most recent call last):\n...\nValueError: cannot encode objects that are not 2-tuples\n>>> from_key_val_list({'key': 'val'})\nOrderedDict([('key', 'val')])\n```\n\n```\nrtype\n\nOrderedDict\n```\n"]}, {"name": "requests.utils.to_key_val_list", "asynchronous": false, "params": [{"name": "value", "type": null, "default": null}], "returns": null, "documentation": ["Take an object and test to see if it can be represented as a\ndictionary. If it can be, return a list of tuples, e.g.,\n\n```\n>>> to_key_val_list([('key', 'val')])\n[('key', 'val')]\n>>> to_key_val_list({'key': 'val'})\n[('key', 'val')]\n>>> to_key_val_list('string')\nTraceback (most recent call last):\n...\nValueError: cannot encode objects that are not 2-tuples\n```\n\n```\nrtype\n\nlist\n```\n"]}, {"name": "requests.utils.parse_list_header", "asynchronous": false, "params": [{"name": "value", "type": null, "default": null}], "returns": null, "documentation": ["Parse lists as described by RFC 2068 Section 2.\n\nIn particular, parse comma-separated lists where the elements of\nthe list may include quoted-strings.  A quoted-string could\ncontain a comma.  A non-quoted string could have quotes in the\nmiddle.  Quotes are removed automatically after parsing.\n\nIt basically works like {func}`parse_set_header` just that items\nmay appear multiple times and case sensitivity is preserved.\n\nThe return value is a standard {class}`list`:\n\n```pycon\n>>> parse_list_header('token, \"quoted value\"')\n['token', 'quoted value']\n```\n\nTo create a header from the {class}`list` again, use the\n{func}`dump_header` function.\n\n```\nparam value\n\na string with a list header.\n\nreturn\n\n\n\nrtype\n\nlist\n```\n", "From mitsuhiko/werkzeug (used with permission)."]}, {"name": "requests.utils.parse_dict_header", "asynchronous": false, "params": [{"name": "value", "type": null, "default": null}], "returns": null, "documentation": ["Parse lists of key, value pairs as described by RFC 2068 Section 2 and\nconvert them into a python dict:\n\n```pycon\n>>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n>>> type(d) is dict\nTrue\n>>> sorted(d.items())\n[('bar', 'as well'), ('foo', 'is a fish')]\n```\n\nIf there is no value for a key it will be `None`:\n\n```pycon\n>>> parse_dict_header('key_without_value')\n{'key_without_value': None}\n```\n\nTo create a header from the {class}`dict` again, use the\n{func}`dump_header` function.\n\n```\nparam value\n\na string with a dict header.\n\nreturn\n\n\n\nrtype\n\ndict\n```\n", "From mitsuhiko/werkzeug (used with permission)."]}, {"name": "requests.utils.unquote_header_value", "asynchronous": false, "params": [{"name": "value", "type": null, "default": null}, {"name": "is_filename", "type": null, "default": "..."}], "returns": null, "documentation": ["Unquotes a header value.  (Reversal of {func}`quote_header_value`).\nThis does not use the real unquoting but what browsers are actually\nusing for quoting.\n\n```\nparam value\n\nthe header value to unquote.\n\nrtype\n\nstr\n```\n", "From mitsuhiko/werkzeug (used with permission)."]}, {"name": "requests.utils.dict_from_cookiejar", "asynchronous": false, "params": [{"name": "cj", "type": null, "default": null}], "returns": null, "documentation": ["Returns a key/value dictionary from a CookieJar.\n\n```\nparam cj\n\nCookieJar object to extract cookies from.\n\nrtype\n\ndict\n```\n"]}, {"name": "requests.utils.add_dict_to_cookiejar", "asynchronous": false, "params": [{"name": "cj", "type": null, "default": null}, {"name": "cookie_dict", "type": null, "default": null}], "returns": null, "documentation": ["Returns a CookieJar from a key/value dictionary.\n\n```\nparam cj\n\nCookieJar to insert cookies into.\n\nparam cookie_dict\n\nDict of key/values to insert into CookieJar.\n\nrtype\n\nCookieJar\n```\n"]}, {"name": "requests.utils.get_encodings_from_content", "asynchronous": false, "params": [{"name": "content", "type": null, "default": null}], "returns": null, "documentation": ["Returns encodings from given content string.\n\n```\nparam content\n\nbytestring to extract encodings from.\n```\n"]}, {"name": "requests.utils._parse_content_type_header", "asynchronous": false, "params": [{"name": "header", "type": null, "default": null}], "returns": null, "documentation": ["Returns content type and parameters from given header\n\n```\nparam header\n\nstring\n\nreturn\n\ntuple containing content type and dictionary of\nparameters\n```\n"]}, {"name": "requests.utils.get_encoding_from_headers", "asynchronous": false, "params": [{"name": "headers", "type": null, "default": null}], "returns": null, "documentation": ["Returns encodings from given HTTP Header Dict.\n\n```\nparam headers\n\ndictionary to extract encoding from.\n\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.stream_decode_response_unicode", "asynchronous": false, "params": [{"name": "iterator", "type": null, "default": null}, {"name": "r", "type": null, "default": null}], "returns": null, "documentation": ["Stream decodes an iterator."]}, {"name": "requests.utils.iter_slices", "asynchronous": false, "params": [{"name": "string", "type": null, "default": null}, {"name": "slice_length", "type": null, "default": null}], "returns": null, "documentation": ["Iterate over slices of a string."]}, {"name": "requests.utils.get_unicode_from_response", "asynchronous": false, "params": [{"name": "r", "type": null, "default": null}], "returns": null, "documentation": ["Returns the requested content back in unicode.\n\n```\nparam r\n\nResponse object to get unicode content from.\n```\n\nTried:\n\n1. charset from content-type\n2. fall back and replace all unicode characters\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.unquote_unreserved", "asynchronous": false, "params": [{"name": "uri", "type": null, "default": null}], "returns": null, "documentation": ["Un-escape any percent-escape sequences in a URI that are unreserved\ncharacters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.requote_uri", "asynchronous": false, "params": [{"name": "uri", "type": null, "default": null}], "returns": null, "documentation": ["Re-quote the given URI.\n\nThis function passes the given URI through an unquote/quote cycle to\nensure that it is fully and consistently quoted.\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.address_in_network", "asynchronous": false, "params": [{"name": "ip", "type": null, "default": null}, {"name": "net", "type": null, "default": null}], "returns": null, "documentation": ["This function allows you to check if an IP belongs to a network subnet\n\nExample: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n\n: returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n```\nrtype\n\nbool\n```\n"]}, {"name": "requests.utils.dotted_netmask", "asynchronous": false, "params": [{"name": "mask", "type": null, "default": null}], "returns": null, "documentation": ["Converts mask from /xx format to xxx.xxx.xxx.xxx\n\nExample: if mask is 24 function returns 255.255.255.0\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.is_ipv4_address", "asynchronous": false, "params": [{"name": "string_ip", "type": null, "default": null}], "returns": null, "documentation": ["---\nrtype: bool\n---\n"]}, {"name": "requests.utils.is_valid_cidr", "asynchronous": false, "params": [{"name": "string_network", "type": null, "default": null}], "returns": null, "documentation": ["Very simple check of the cidr format in no_proxy variable.\n\n```\nrtype\n\nbool\n```\n"]}, {"name": "requests.utils.set_environ", "asynchronous": false, "params": [{"name": "env_name", "type": null, "default": null}, {"name": "value", "type": null, "default": null}], "returns": null, "documentation": ["Set the environment variable 'env_name' to 'value'\n\nSave previous value, yield, and then restore the previous value stored in\nthe environment variable 'env_name'.\n\nIf 'value' is None, do nothing"]}, {"name": "requests.utils.should_bypass_proxies", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "no_proxy", "type": null, "default": null}], "returns": null, "documentation": ["Returns whether we should bypass proxies or not.\n\n```\nrtype\n\nbool\n```\n"]}, {"name": "requests.utils.get_environ_proxies", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "no_proxy", "type": null, "default": "..."}], "returns": null, "documentation": ["Return a dict of environment proxies.\n\n```\nrtype\n\ndict\n```\n"]}, {"name": "requests.utils.select_proxy", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "proxies", "type": null, "default": null}], "returns": null, "documentation": ["Select a proxy for the url, if applicable.\n\n```\nparam url\n\nThe url being for the request\n\nparam proxies\n\nA dictionary of schemes or schemes and hosts to proxy URLs\n```\n"]}, {"name": "requests.utils.resolve_proxies", "asynchronous": false, "params": [{"name": "request", "type": null, "default": null}, {"name": "proxies", "type": null, "default": null}, {"name": "trust_env", "type": null, "default": "..."}], "returns": null, "documentation": ["This method takes proxy information from a request and configuration\ninput to resolve a mapping of target proxies. This will consider settings\nsuch as NO_PROXY to strip proxy configurations.\n\n```\nparam request\n\nRequest or PreparedRequest\n\nparam proxies\n\nA dictionary of schemes or schemes and hosts to proxy URLs\n\nparam trust_env\n\nBoolean declaring whether to trust environment configs\n\nrtype\n\ndict\n```\n"]}, {"name": "requests.utils.default_user_agent", "asynchronous": false, "params": [{"name": "name", "type": null, "default": "..."}], "returns": null, "documentation": ["Return a string representing the default user agent.\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.default_headers", "asynchronous": false, "params": [], "returns": null, "documentation": ["---\nrtype: requests.structures.CaseInsensitiveDict\n---\n"]}, {"name": "requests.utils.parse_header_links", "asynchronous": false, "params": [{"name": "value", "type": null, "default": null}], "returns": null, "documentation": ["Return a list of parsed link headers proxies.\n\ni.e. Link: \\<<http:/.../front.jpeg>>; rel=front; type=\"image/jpeg\",\\<<http://.../back.jpeg>>; rel=back;type=\"image/jpeg\"\n\n```\nrtype\n\nlist\n```\n"]}, {"name": "requests.utils.guess_json_utf", "asynchronous": false, "params": [{"name": "data", "type": null, "default": null}], "returns": null, "documentation": ["---\nrtype: str\n---\n"]}, {"name": "requests.utils.prepend_scheme_if_needed", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}, {"name": "new_scheme", "type": null, "default": null}], "returns": null, "documentation": ["Given a URL that may or may not have a scheme, prepend the given scheme.\nDoes not replace a present scheme with the one provided as an argument.\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.get_auth_from_url", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}], "returns": null, "documentation": ["Given a url with authentication components, extract them into a tuple of\nusername,password.\n\n```\nrtype\n\n(str,str)\n```\n"]}, {"name": "requests.utils.check_header_validity", "asynchronous": false, "params": [{"name": "header", "type": null, "default": null}], "returns": null, "documentation": ["Verifies that header parts don't contain leading whitespace\nreserved characters, or return characters.\n\n```\nparam header\n\ntuple, in the format (name, value).\n```\n"]}, {"name": "requests.utils._validate_header_part", "asynchronous": false, "params": [{"name": "header", "type": null, "default": null}, {"name": "header_part", "type": null, "default": null}, {"name": "header_validator_index", "type": null, "default": null}], "returns": null, "documentation": []}, {"name": "requests.utils.urldefragauth", "asynchronous": false, "params": [{"name": "url", "type": null, "default": null}], "returns": null, "documentation": ["Given a url remove the fragment and the authentication part.\n\n```\nrtype\n\nstr\n```\n"]}, {"name": "requests.utils.rewind_body", "asynchronous": false, "params": [{"name": "prepared_request", "type": null, "default": null}], "returns": null, "documentation": ["Move file pointer back to its recorded starting position\nso it can be read again on redirect."]}], "variables": [{"name": "requests.utils.NETRC_FILES", "type": null, "documentation": []}, {"name": "requests.utils.DEFAULT_CA_BUNDLE_PATH", "type": null, "documentation": []}, {"name": "requests.utils.DEFAULT_PORTS", "type": null, "documentation": []}, {"name": "requests.utils.DEFAULT_ACCEPT_ENCODING", "type": null, "documentation": []}, {"name": "requests.utils.UNRESERVED_SET", "type": null, "documentation": []}, {"name": "requests.utils._null", "type": null, "documentation": ["encoding to ASCII for Python 3"]}, {"name": "requests.utils._null2", "type": null, "documentation": []}, {"name": "requests.utils._null3", "type": null, "documentation": []}], "classes": [], "exports": []}]}